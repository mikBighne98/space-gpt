# cloud.md

If you are migrating from Deta Cloud to Deta Space, take a look at our dedicated [Migration Hub](/migration).# help.md

## Getting Help

We have answered some General [FAQs](/docs/en/other/faq) in these docs, but we are here to help and would love to hear what you think!

If you have any questions or feedback, you can reach us:
- Chat: [Discord](https://go.deta.dev/discord), (#space-mission channel, ask for access if we forgot to add you).

## Reporting Abuse

If you detect any kind of fraudulent, abusive and/or malicious content hosted on Deta, please report the site(s) by sending an email to us at [abuse@deta.sh](mailto:abuse@deta.sh).

We review each report.


# links.md

- [Discord](https://go.deta.dev/discord)
- [Twitter](https://twitter.com/detahq)
- [GitHub](https://github.com/deta)# issues.md


## Creating releases

After you have [pushed changes](/docs/en/basics/revisions) to Space, you can turn a revision into an installable release.


### Releasing from the GUI

You can create a release for your project using [Builder](/docs/en/basics/projects#projects-in-builder).

Simply go to the "Develop" tab and click the "Create Release" button. The next page will let you select the [revision](/docs/en/basics/revisions) you would like to release and offer a version tag (this will be auto-generated if you leave it blank). After clicking next, you will be able to choose if your release should be `listed` on [Discovery](/discovery) or not and can optionally provide some [notes](#release-notes) for the release.

Once you are ready, click "Launch to Space". Then watch your app take off! Your app is now installable on Deta Space to anyone with the release url, which is provided on the following page.

### Releasing from the CLI

You can create a release using the [Space CLI](/docs/en/basics/cli). Simply use the following command:

```bash
space release
```

Pass the `--listed` argument to enable listing on [Discovery](/docs/en/basics/releases#discovery--app-pages).

Pass the `--notes` argument to add notes about the release (changes, features, etc). [More info below](#release-notes).

Then watch your app take off! Your app is now installable on Deta Space to anyone with the release url.

> You can provide specific options to your release (which revision to use, version tags, listed/unlisted) using specific options. See the cli reference for [`space release`](/docs/en/reference/cli#deta-release).

## Discovery & App Pages

Each release of your app is available for installation using [Discovery](/discovery) - Space's app marketplace.

![Screenshot of Discovery](/docs_assets/discovery.png)

There are two ways your app will be available on Discovery:

- **Unlisted**: If your app is *unlisted*, only people who have the link to your release will be able to view its page and install the app. This is the default behaviour when creating a release via the CLI or the UI.

- **Listed**: If your app is *listed*, it will be shown publicly on Discovery where other users can easily find and install it. To enable listing use the `--listed` argument in the CLI (`space release --listed`) or select "List on Discovery" when creating a release using Builder.

In both cases, your app will be available on its own page on Discovery.

Not only does your app's Discovery page allow users to install your app, it also gives you the opportunity to explain what your app does, how it is unique, and its features.

You can customize an app's Discovery page using a `Discovery.md` file, which gives you  a full Markdown description and options to specify things like an app title & tagline and links to a Git repository & homepage. More info on how to use the `Discovery.md` file to customize your app's Discovery page can be found in the [Discovery.md Reference](/docs/en/reference/discovery).

## App Updates

When you publish your app by creating a release, Deta creates an installable version of your app. If you update your app afterwards, you need to publish a new release. Anyone who has installed older versions of your app can update their instance to the latest release (they could also install a new instance). When updating an app, the data will be kept across the update.

> ‚ö†Ô∏è Important note: updates only work when the data your app stores are compatible with the new app version. In the future we will have data migrations to help with this. If a new release is not compatible with old versions, you need to create a separate app for it to prevent breaking installed apps.

Users of your app will be shown an update notification if you publish a **listed** release newer than the one they have installed. **Unlisted** releases will not be made available as updates.

## Release Notes

To notify your users of changes made with a new release you can add "Release Notes" to a release. These notes support the Markdown syntax with the [same limitations as the Discovery.md file](/docs/en/reference/discovery#supported-syntax).

Release notes will be shown to users of your app, before they install the release as an update and can be viewed on the app's Discovery page under "What's new?".

### Adding notes from the CLI

To add notes to a release you can use the `--notes` argument with the Space CLI:

```bash
space release --notes
```

It will prompt you to enter your release notes before creating the release. You can also provide a string to `--notes` directly to skip the prompt:

```bash
space release --notes="Fixed bug xyz"
```

### Adding notes from the GUI

During the publishing flow in Builder, you will be shown the option to add release notes as the second step.
# micros.mdx

## What's a Micro?

Deta Space can run almost any type of app. For example, Space supports:
- frontend sites built with frameworks like React, Vue and Svelte
- full-stack frameworks like Next, Nuxt or SvelteKit
- backend apps built with Node.js, Python and even Go, Rust or something more custom.

A Space app can also be built by combining these different technologies, for example, a SvelteKit app with a Go API, really any combination of up to 5 different languages/frameworks.

We call these individual parts of an app **Micros**. A Micro is a lightweight compute service running inside your app which can be exposed to the outside using HTTP.

Micros are defined in your project's [Spacefile](/docs/en/reference/spacefile), telling Deta Space what Micros your app contains and how to run them.

## Adding your first Micro

When you create a new project using the Space CLI, it will try to detect the type of app you want to deploy. This works for most frameworks like Next, Nuxt, SvelteKit, and backend runtimes like Node.js and Python.

If this detection works, it will show you what type of Micro is detected and its generated config. After you've confirmed the config is correct, the CLI will create the `Spacefile` in your local directory for you.

Even if this detection fails, Space supports almost any type of app via the `Spacefile`.

## Adding Micros via the Spacefile

If you want to run something more custom or need to add more Micros to an existing project, you can edit the project's `Spacefile` to add the required configuration.

Take a look at the [Spacefile reference](/docs/en/reference/spacefile) for a complete list of options.

Here's the `Spacefile` for an app consisting of a single Node.js Micro:

```yaml
v: 0
micros:
  - name: api
    src: ./node-api
    engine: nodejs16
    run: npm run start
```

The `name` field identifies your Micro inside your app and the `src` should point to the location of the Micro's source code relative to your project's root.

If your project contains more than one Micro, the `primary` field can be used to identify the entry point of your application (which Micro will be executed when the root path of your project is visited via HTTP).

## Directory structure

A Micro can be thought of as its own independent service. As a result, they need to be self-contained in their own directory in your project and your project root should not contain any Micro specific files.

Here's an example of the file & folder structure of an app with a Python backend and a Vue frontend:

```
Spacefile
backend/
    requirements.txt
    main.py
frontend/
    package.json
    src/
        index.vue
```

All files needed for the Vue frontend (including `package.json`) are inside the `frontend` directory, while all files needed for the Python backend are inside `backend`.

Here is the matching `Spacefile`:

```yaml
v: 0
micros:
  - name: frontend
    src: ./frontend
    engine: vue
    primary: true
  - name: backend
    src: ./backend
    engine: python3.9
```

> üîë It's recommended to put your first Micro in its own sub-directory of your project. A single Micro will work running in the root directory of your project, but this approach doesn't scale. You'll have to migrate this Micro as soon as you want to add a second Micro to your project.

## Micro Routing

Since your app can contain multiple Micros, the Space runtime needs to know what requests to route to which Micro.

On Space, this is handled by having a single primary Micro which receives all requests made to your app's root path `/`. Each other Micro defined in your [Spacefile](/docs/en/reference/spacefile) will be served under a specific path relative to your app's primary hostname. This is defined in the `path` field for each Micro in your `Spacefile`:

```yaml
v: 0
micros:
  - name: client
    src: ./client
    engine: svelte
    primary: true
    path: client
  - name: api
    src: ./api
    engine: nodejs16
    path: api
```
In this example, the `api` Micro will be available at `/api` while all other paths including the root `/` will be received by the primary Micro, in this case, the static Micro `client`.

If the path is missing, the path will fall back to the `name` field.

## Public Routes

If you want parts of your app to be available to the public (instead of being protected behind auth), you need to specify the routes with the `public_routes` keyword in your app's [Spacefile](/docs/en/reference/spacefile):

```yaml
micros:
  - name: backend
    src: backend
    engine: python3.9
    public_routes:
      - "/test" # exact match
      - "/public/*" # wildcards
      - "/api/*/docs" # wildcards can be placed anywhere
```

You can either match a route exactly, or use a wildcard (`*`) to match anything after it.

The paths specified with `public_routes` are _relative_ to a given Micro's root. This means you do not need to specify a Micro's own path as part of its own `public_routes`. For example, if `/api` is served by a secondary (backend) Micro, and you want to make the route `/api/public` public, then you only need to specify `/public` as a public route for this Micro:

```yaml
micros:
  - name: frontend
    src: frontend
    engine: static
    primary: true

  - name: backend
    src: backend
    path: api
    engine: python3.9
    public_routes:
    - "/public" # This Micro is served under `/api` so if we want to make `/api/public` available to the outside we only need to specify `/public`
```

Requests made to your Micro matching any of the routes defined in `public_routes` will bypass Space's authentication entirely.

## Cross Micro Communication

Micros within a project are independent services, but can call one another to get what they need.

How you can successfully call one Micro from another one depends on if the calling Micro is sending the request from the browser or server side (from).

### From the browser

If you are trying to call a backend Micro from another Micro in the browser, you can make requests to the relative path under which the Micro is served from:

```js
// In the browser
fetch('/api')
```

That's it. If Micros live in the same 'project', auth just works.

### Server side

If you are trying to call another Micro from the backend you need to get your app's assigned hostname to use as the origin, and use an api key to authenticate your request.

Both of these items are provided in the environment of the Micro:
- The primary hostname is under the `DETA_SPACE_APP_HOSTNAME` environment variable.
- The api key is under the `DETA_API_KEY` environment variable. This should be added as a header to your http request under `X-API-Key`.

Here's how you'd make a request to a second Micro (on the path `/second-micro`) within an app, using Python:

```python
import os

origin = f"https://{os.getenv('DETA_SPACE_APP_HOSTNAME')}"
api_key = os.getenv("DETA_API_KEY")
headers = {"x-api-key": api_key}

res = requests.get("/second-micro", headers=headers)
```

> ‚ö†Ô∏è If you expose this API Key, you risk compromising your Space app.

## API Keys

If you want users of your app to be able to access their app instance programmatically you can enable the `api_keys` preset for Micros in your app:

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      api_keys: true
```

If enabled, users of your app will be able to generate API keys in their app instance settings and use them to authenticate requests made to otherwise private routes of a Micro.

Generated keys need to be provided in the HTTP header `X-Space-App-Key` and only work with Micros that have the preset `api_keys` enabled. Public routes have a higher preference than API keys, if there are public routes specified these will always be public.

> Note: If you enable API keys you should show clearly in the app that API keys can be used and ideally have clear documentation on which endpoints of your app work with API key auth.

## Micro Environment Variables

### Pre-set Variables

The following environment variables will be set in all Micros,  accessible on the server side.

- `DETA_PROJECT_KEY` - deta project key
- `DETA_SPACE_APP` - will be set to `‚Äútrue‚Äù`
- `DETA_SPACE_APP_VERSION` - the app version
- `DETA_SPACE_APP_HOSTNAME` - will be set to the **primary** hostname
- `DETA_SPACE_APP_MICRO_NAME` - micro‚Äôs name
- `DETA_SPACE_APP_MICRO_TYPE` - will be set to `"primary"` if primary otherwise `‚Äúnormal‚Äù`

Please let us know if you need additional configuration.

### Custom Variables

Use the `env` preset if you need to set custom environment variables for your Micros. This can also be used to let users of your app specify things like external secrets or [API Keys](/docs/en/basics/extending_apps#api-keys) or [Data Keys](/docs/en/basics/extending_apps#data-keys) of different app instances.

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      env:
        - name: SECRET_MESSAGE
          description: Secret message only available to this Micro
          default: "deta is cool"
```

- `name` : environment variable name or key
- `description` : human friendly description (optional)
- `default` : default value for the variable (optional)

The user of the app will be shown a UI in the App's Settings where they can set the values for the specified environment variables. They will be exposed to the Micro's environment under the specified `name`.

## Custom Domains

If you already have your own domain you can assign it to any Builder or app instance with a few clicks. This ‚ÄúCustom Domain‚Äù works in addition to the default Space domain that gets assigned to an instance. The domain will be connected to the primary Micro of the app instance.

Follow just a few steps to add a custom domain to your app:

- To add a custom domain to a Builder instance, open the Builder project and head over to the "Develop" page and then to the "Configuration" tab. Click ‚ÄúAdd Domain‚Äù and enter your domain name.
- To add a custom domain to an app instance you installed, open the app settings by clicking the 3 dots (‚Ä¶) next to the app‚Äôs icon on the Canvas, click ‚ÄúSettings‚Äù and then switch to the ‚ÄúDomains‚Äù tab. Click ‚ÄúAdd Domain‚Äù and enter your domain name.

Before your domain is live, you need to setup a DNS record to point your domain to our servers. Follow the guide in our [User Manual](/manual/features/custom-domains) to learn how to do this.

## Scheduled Actions

Scheduled actions allow an app to perform certain tasks on a specific interval. These tasks can be anything you build into your app, from a cleanup job to automated data aggregation or revalidation.

### Adding a Scheduled Action

Scheduled actions are defined in the [Spacefile](/docs/en/reference/spacefile) on the Micro level:

```yaml
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

Each action with the trigger `schedule` needs to have a unique `id`, `name`, and `default_interval` at which it runs. You can optionally provide a description to inform the user about what the action is used for. More information on all the supported fields can be found in the [Spacefile Reference](/docs/en/reference/spacefile#actions).

When an action runs, a `POST` request containing the action `id` and the `trigger` in the event body will be sent to the Micro on the path `/__space/v0/actions`.

For example, the example Spacefile above will result in the following request body:

```json
{
  "event": {
    "id": "cleanup",
    "trigger": "schedule"
  }
}
```

It is up to you to handle the request and run whatever logic you need. You could for example call a function or interact with [Base](/docs/en/reference/base/about) and [Drive](/docs/en/reference/drive/about) through the Deta SDK:

<Tabs
  client:visible
  sharedStore="tabLang"
  defaultPanel="js"
  tabs={[
    { label: "JavaScript", value: "js" },
    { label: "Python", value: "py" }
  ]}
>
  <Fragment slot="panel.js">
  ```js
  // using express
  app.post('/__space/v0/actions', (req, res) => {
    const event = req.body.event

    if (event.id === "cleanup") {
      cleanup()
    }

    res.sendStatus(200)
  })
  ```
  </Fragment>
  <Fragment slot="panel.py">
  ```python
  # using flask
  @app.route('/__space/v0/actions', methods=['POST'])
  def actions():
    data = request.get_json()
    event = data['event']
    if event['id'] == 'cleanup':
      cleanup()
	```
  </Fragment>
</Tabs>

### Interval Types for Scheduled Actions

Space currently supports two types of intervals for scheduled actions:

- [Rates](/docs/en/reference/spacefile#rates) e.g. `2 hours`
- [Cron Expressions](/docs/en/reference/spacefile#cron-expressions) e.g. `0 10 * * *`

Check out the [Spacefile Reference](/docs/en/reference/spacefile#actions) on the exact syntax.

Scheduled actions have to be purposely enabled, setup and need to have a default interval which they will be executed on.

After installing an app, its scheduled actions are automatically enabled and set to run on the default interval. The user can at any point change the interval or disable an action completely. Check out the [User Manual](/manual/apps#schedules) on how scheduled actions are presented to app users.
# projects.md

## What's a project?

When building apps for Space, the first thing you will start with is a Space 'project'. A project allows you to start building an app, experiment with different Space features, test if your app works in the Space environment and finally release it to the public so others can start using it.

## Projects in Builder

Projects in Space live inside Builder, an app which can be found on your Canvas. Builder is your toolbox for building an app on Deta Space. It allows you to create new projects and manage them over time.

Each Project in Builder consists of 3 main pages:

- **Overview**: the overview page lets you see important information about your projects like its latest release and recent events

- **Develop**: the develop page allows you to configure and develop your project. Here you have access to your project resources like the development data as well as information about your Builder instance.

- **Publish**: the publish page allows you to create and manage releases of your app

## Creating a Project

You can create new projects using the [Deta Space CLI](/docs/en/basics/cli), which will guide you through the process.

Use the `space new` command to create a new project with the Space CLI:

```sh
space new
```

The CLI allows you to choose from a variety of templates to bootstrap your project or it can automatically set up the right project configuration based on what you have locally.

You will be prompted to enter a name for your project. Next, the CLI will try to detect any existing applications in your local directories. If found, the CLI will show a generated config for those applications.

Once you confirm the generated config, the CLI will create a new project in Builder and generate a [Spacefile](/docs/en/reference/spacefile) file in your local directory. The `Spacefile` contains the configuration of your app, used by Deta Space to understand what your app looks like and how to run it.

Additionally, the CLI created a hidden `.space` directory -- this contains information about the project, linking it to your Builder project. This directory should not be included in your version control and was automatically added to your `.gitignore`.

After you've created a project, you can view it inside the [Builder](/docs/en/basics/projects#projects-in-builder) app, which can be found on your Canvas in Space.

> Builder doesn't keep track of your source code, we recommend you use Git as a version control system.

## Project linking

Your local development environment is connected to Builder via a hidden `.space` directory, which contains a unique identifier: a project ID.

If you first run `space new` in a directory, the Space CLI will automatically connect the local directory via this ID with your newly created project in Builder.

If you ever need to connect an unlinked local directory to a project in Builder, you can use `space link` to link your current directory to the existing project:

```bash
space link
```

The CLI will prompt you to enter your project's ID and will then link your directory with the project on Space. This project ID is accessible in Builder in your project's "Develop" tab.
# cli.mdx

## Installation

<OSTabs>
  <Fragment slot="mac">
    To install the Space CLI on MacOS, open a Terminal session and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="win">
    To install the Space CLI on Windows, open PowerShell and enter:

    ```bash
    iwr https://get.deta.dev/space-cli.ps1 -useb | iex
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="linux">
    To install the Space CLI on Linux, open a Terminal and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

</OSTabs>


## Authentication

Once you have successfully installed the Space CLI, you'll need to log in to Deta Space.

The Space CLI authenticates itself with 'Access Tokens'. You can create an access token under Settings in your Space. Just type 'settings' in Teletype to open them.

After you have generated a new key you can add it to the CLI using `space login`. It will prompt you for the key and then store it safely.

From a terminal type:

```bash
space login
```

This command will ask for an 'access token' to authenticate your CLI.

```bash
? Enter access token >
```

To get an access token, enter your [Space dashboard](https://deta.space/), open the Teletype (command bar) and click 'Settings':

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli1.png" width="400px" />
</div>

This will open the Settings modal, where you can click 'Generate Token' to generate an access token:

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli2.png" width="400px" />
</div>

Copy the resulting token:

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli3.png" width="400px" />
</div>

You can paste this back into your CLI prompt. After you hit enter, you should be greeted by a success message.

```bash
üëç Login Successful!
```

Upon a successful log-in, you are ready to start building Space apps.


## CLI Commands

Run `space help` to get a overview of the available commands or refer to the [Reference section](/docs/en/reference/cli) for a complete list of CLI commands and options.# revisions.md

## What's a revision

A revision is a complete package of your app at a single point in time. New revisions are created with each push. You can view this new revision by opening your project inside [Builder](/docs/en/basics/projects#projects-in-builder). It will be shown on the **Develop** tab.

A revision can now be used in your Space. It can also be used to [create a release](/docs/en/basics/releases), which you can share with others to install a copy of your app into their own Space!

## Testing changes

To test if your app works in Space, each project comes with your own personal *Builder instance*. This instance of your project is automatically kept up-to-date every time you successfully run `space push`.

The Builder instance is automatically added to your Canvas and can be used like any other app instance. You can also view your Builder instance via your Builder project under the **Develop** tab. Clicking the **Open Builder Instance** will open the instance.

If your Builder instance runs into a runtime error when handling a request, the error logs will be returned in the request's response. All runtime logs, including the error logs, are stored for 14 days and can be viewed in the **Develop** tab of your Builder project under **"Runtime Logs"**. The logs are sorted by time and can be filtered by a specific Micro using the dropdown. Runtime logs can help with debugging Space related errors and mis-configurations of your app.

The Builder instance shares its data with your whole Builder project, which you can [develop against](/data#developing-with-base-and-drive). You can also [view and update this data](/docs/en/basics/data#viewing-data) as you use your app. If you are also [developing your app locally](/docs/en/basics/local) using `space dev` the data will be shared between your local environment and the Builder instance.

## Ignoring files and directories

To exclude certain files and directories from being uploaded during `space push`, use the `.spaceignore` file. It acts similar to a `.gitignore` file, where each line in the file specifies a pattern. All files and directories matching the patterns will be excluded from `push`.

For example, a `.spaceignore` file with the following content `space push` will ignore the `test` and `docs` paths.

```
test
docs
```

Certain directories like the `node_modules` directory for node micros and the `__pycache__` directory for python micros are ignored by default and don't need to be specified in the `.spaceignore` file.

You can use an optional prefix `!` to negate the pattern; any matching file excluded by a previous pattern will become included again.

For eg, a `.spaceignore` file with the following content `space push` will not ignore the `node_modules` directory.

```
!node_modules/
```
# data.md

## How to store data

In addition to the compute provided Micros, each Deta Space app has its own database and file storage services. All the data stored with a Space app is 'sandboxed' within an application instance. By default, this storage is not shared across users and it's also not shared between a single user's app instances (interoperability between apps is planned).

As a result, you can just code your app as if it was only for a single user, without thinking about authentication or data separation.

### Deta Base

To store data, Space apps can use [Deta Base](/docs/en/reference/base/about),  a fully-managed, fast, and secure NoSQL database. Each app can create and use as many Bases as it needs. Base can be accessed using the [Deta Base SDK](/docs/en/reference/base/sdk) or the [Base HTTP API](/docs/en/reference/base/HTTP).

Take a look the the [Base Reference](/docs/en/reference/base/about) on how to use it.

### Deta Drive

To store files, Space apps can use [Deta Drive](/docs/en/reference/drive/about), a fully-managed, secure and scalable file storage service for Deta. Each app can create and use as many Drives as it needs. Drive can be accessed using the [Drive SDK](/docs/en/reference/drive/sdk) or the [Drive HTTP API](/docs/en/reference/base/HTTP).

Take a look the the [Drive Reference](/docs/en/reference/drive/about) on how to use it.

## Developing with Base and Drive

During development, you can share data between your local environment and your [project](/docs/en/basics/projects) in Space.

There is two ways to setup the Deta SDK to access the Bases & Drives of your project:

### Automatic setup

The Space CLI can automatically connect your local development environment with your Space Base & Drive using the `space dev` command.

More information on how to use the `space dev` command can be found in the in the [Developing Locally](/docs/en/basics/local) section.


### Manual setup

If the automatic set up does not work for your use-case, you can manually set up your local development environment by generating a data key from the "Data" tab on the "Develop" page, inside your Builder project.

If you are using an official Deta SDK, add this as an environment variable inside your dev environment:

```bash
DETA_PROJECT_KEY=<put_your_project_key_here>
```

The Deta SDKs will detect this key to access your development Bases and Drives.

If you are not using a Deta SDK, pass this Project Key using the `X-API-Key` header with the [Base HTTP API](/docs/en/reference/base/HTTP#auth) or [Drive HTTP API](/docs/en/reference/drive/HTTP#auth).

## Viewing data

Base and Drive both come with a UI where you can easily see, add, update and delete files and data. This UI is available inside Builder in the "Develop" tab under "Project Resources" and also through your Builder instance on your Canvas (click the `...` and then `View Data`).

For detailed guides, see the specific documentation for [Base UI](/docs/en/reference/base/base_ui) and [Drive UI](/docs/en/reference/drive/drive_ui).
# extending_apps.md

### API Keys

`API Keys` provide you with programmatic access to an installed app's HTTP APIs. Provided a developer has enabled API Keys, you can generate them from the "API Keys" tab in your "Settings" of the installed app.

The keys need to be provided under the `X-Space-App-Key` (case insensitive) header when making HTTP requests to the app.

Follow the specific documentation provided by the developer of the app on how to these APIs.


### Data Keys

`Data Keys` provide you direct access to data created by your installed Space apps. They allow you to read and manipulate your Space apps' data, and can be used to build custom integrations without explicit options (such as API Keys) from the app developer.

However, manipulating the data can result in breaking your app so use the keys with caution.

To generate Data Keys, go to the "Data Keys" tab in your "Settings" for your installed apps.

To use a Data Key, you can provide the key when initializing your `Deta` instance if you are using our official Deta SDKs.

An example in python:

```py
from deta import Deta

deta = Deta('your_data_key_here')
```

You need to create two different instances of `Deta` if you are connecting with two different apps.
Do not overwrite your `DETA_PROJECT_KEY` environment variable with this key, especially if you are building an integration from within a Space app.

If you are not using a Deta SDK, pass this key using the `X-API-Key` header with the [Base HTTP API](/docs/en/reference/base/HTTP#auth) or [Drive HTTP API](/docs/en/reference/drive/HTTP#auth). You need two separate HTTP clients if you want to connect to the data of two different apps.
# app_icon.md

## Make your app look good with a few tricks


The app icon is a crucial aspect for any Space App, as it influences its discoverability and overall perception. As the first visual element users encounter when browsing the Discovery Page, it can make or break a user's decision to download the app.

## Best Practices

Creating an effective app icon requires careful consideration of its display format, as it will be presented as a rectangle with a prominent rounded corner in the top-left (7x the size of a typical corner radius). To ensure optimal appearance, the icon should be designed as a full-bleed square image. Space applies a mask that seamlessly adapts the icon's corners to match the overall aesthetic.

An engaging and striking app icon can be achieved by incorporating a background of solid color or gradient with ample space around the centre. The centre should prominently feature the app's logo, which can be in 3D for added visual appeal. It is generally recommended to avoid using text in the icon, as it can make the icon appear cluttered and difficult to read.

The guidelines also include a safe zone where the logo should be placed to ensure it is always visible and not obscured by any elements like the top-left corner radius, app options menu in the bottom-right, or updates/notifications in the top-right.

![Safe Zone](/docs_assets/app_icon/guidelines.png)

This is the preferred and optimal size (512x512px). The centre place is where the logo should be, (196x196px).

![Size](/docs_assets/app_icon/size.png)

It is essential to avoid mimicking UI elements from your app in the design of your icon. Graphical images are usually preferred over photos as they tend to be more visually appealing and distinctive. Additionally, replicating first-party apps such as the Builder Icon is strictly prohibited, as it can cause confusion and may result in the removal of your app from the Discovery Page.

When selecting colors for the icon, it is important to ensure consistency with the overall design of the app to create a cohesive visual experience. Utilizing the same color scheme in both the icon and the app can aid users in easily identifying and remembering the app.

A well-chosen app name is short and memorable. This not only makes it easy for users to recall the app, but also ensures the name is clearly visible. A safe limit for text in the name is 10 characters, as longer names may be truncated depending on the letter width. Therefore, it is essential to keep the name concise.

We created an [Icon Tester](https://www.figma.com/community/file/1206563671424898764) for you to use in Figma. Use it to check if your icon is following the guidelines.

Here's a quick demo of how it works:
![Demo](/docs_assets/app_icon/demo.gif)

In order to enhance the Discovery App page, it is reccomened to extract the dominant color from the app icon and apply it as the theme color. This can be achieved by adding the following code snippet to the HTML document:

```html
<meta name="theme-color" content="#4285f4" />
```

This meta tag sets the browser theme color for the app, which is used by some browsers to customise the appearance of the browser UI elements, such as the address bar and the task switcher.
# local.md

## Starting a Development Server

Once you've created a Space project, you can start developing your app locally using the [Space CLI's](https://deta.space/docs/en/reference/cli) `space dev` command.

```bash
space dev
```

Behind the scenes, the Space CLI is:

- Generating and injecting a [Data Key](https://deta.space/changelog/post-6) so you can use the [Deta SDK](https://deta.space/docs/en/basics/data)
- Running each of your Micros in a separate process
- Exposing all of your Micros through a single entrypoint (following the routing in your Spacefile)

If you want to open the app in your browser automatically after starting your Micros, use the `--open` flag.

> Any data you save to Base or Drive using the Deta SDK will be stored in your Builder project. You can view and edit the data using the UI in the "Data" tab of the "Develop" page in your Builder project.

You can customize the development command for each Micro in your `Spacefile` using the `dev` key.

```yaml
v: 0
micros:
  - name: client
    src: ./client
    engine: svelte
    primary: true
    path: client
  - name: api
    src: ./api
    engine: nodejs16
    dev: nodemon index.js # start the micro in development mode
    path: api
```

The specified `dev` commands need to start a web server that listens on the port specified with the `PORT` environment variable. This way the CLI can properly forward requests to the Micro.

You can find instructions on how to setup the right `dev` command for each engine in the "Quickstart Guides".

## Advanced Usage

If you want to have more control over the development process, you can also split the `dev` command into two parts:

- First, start Micros individually using the `space dev up` command
- Then, start the reverse proxy using the `space dev proxy`

For our example above, this would look like this:

```bash
# Start the Micros individually
space dev up client
space dev up api

# Start the reverse proxy
space dev proxy
```

Some use cases for this approach include:

- Running each Micro in a separate terminal window
- Integrating Micros with other development tools (ex: vscode tasks)

The `space dev` command is just a shortcut for the combination of `space dev up` and `space dev proxy`.

## Running scheduled actions manually

You can trigger [scheduled actions](/docs/en/basics/micros#scheduled-actions) from your local development server by using the `space dev trigger` command.

First make sure you have defined a scheduled action in your Spacefile and set up the right handler in your Micro:

```yaml
v: 0
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

After starting your development server using either `space dev` or `space dev up`, you can trigger the action manually using the `space dev trigger` command:

```bash
space dev trigger cleanup
```

This will call your local action handler with a mock payload and print the returned response to your console.

## Running commands in the context of your project

If you don‚Äôt want to specify a dev command in your Spacefile or you want to run a one-off script while still benefitting from the automatic Base & Drive SDK setup you can wrap your command a `space exec` call:

```bash
# Run a command in the context of your project
space exec --project <project-id> -- npm run init-deta-base.py
```

If you run the command from a directory that is linked to a space app, you can omit the `--project` flag.

Some use cases include:

- testing Base & Drive locally
- pre-filling your projects Bases & Drives with data
- programmatically interacting with Base & Drive
- ‚Ä¶anything you can think of!


# spacefile.md

## What's the Spacefile?

The `Spacefile` file contains the configuration of your app and is used by Deta Space to understand what your app looks like and how to run it.

The Spacefile file must be named `Spacefile` and needs to be in the root directory of your project. It uses a syntax similar to YAML, if you're new to YAML and want to learn more, see "[Learn YAML in Y minutes.](https://learnxinyminutes.com/docs/yaml/)".

You can use the [`space new`](/docs/en/reference/cli#space-new) command to let the [Space CLI](/docs/en/reference/cli) automatically create the `Spacefile` for you.

Here is an example `Spacefile`:

```yaml
v: 0
icon: ./icon.png
app_name: "My App"
micros:
  - name: python-app
    src: ./src/python
    engine: python3.9
    primary: true

  - name: custom-app
    src: ./src/custom
    engine: custom
    commands:
      - go get
      - go build main.go
    run: ./main
    include:
      - main
```

> To customize the appearence of your app on [Discovery](/discovery) you can add a  [`Discovery.md`](/docs/en/reference/discovery) file to your project.

## Options

Here are all the options supported by the `Spacefile`.

### `v` (version)

**Required**

The first key/value pair in your `Spacefile` should be the Spacefile version. The latest version at the moment is `0`.

```yaml
v: 0
```

### `icon`

*Optional*


Use `icon` to specify a path to an image file to use as your app's icon. The icon will be used wherever your app is displayed (e.g. the Canvas).

The path should be relative to your `Spacefile` and needs to point to a file inside your project's directory.

The image needs to be a PNG or WebP file of 512x512 pixels.

```yaml
icon: src/static/icon.png
```

### `app_name`

*Optional*

Use `app_name` to specify a name for your app. This name will be used wherever your app is displayed (e.g. the Canvas).

If it is not provided, `app_name` will fallback to your project's name.

The name can has a maximum of 12 characters. We recommend not exceeding 7 characters for optimal visibility across different screen sizes.

```yaml
app_name: My App
```

### `micros`

**Required**

The `micros` object is arguably the most important section in the `Spacefile`. It lists all the micros your app uses and configures each one individually.

#### `name`

**Required**

Each micro needs to have a unique `name` and **must follow the following rules:**

- can only contain alphanumeric characters and hyphen
- start with alphanumeric characters

```yaml
micros:
  - name: api
```

#### `src`

**Required**

Relative path to the root directory of the micro.

Each micro should be in its own directory which needs to contain all files required for the Micro to run.

```yaml
micros:
  - name: api
    src: ./api/
```

#### `engine`

**Required**

Runtime for the Micro, supported values:

- `static`
- `react`
- `svelte`
- `vue`
- `next`
- `nuxt`
- `svelte-kit`
- `python3.9`
- `python3.8`
- `nodejs16`
- `custom`

Example:

```yaml
micros:
  - name: api
    src: ./api/
    engine: nodejs16
```

Some engines require additional configuration. Refer to the "Quickstart Guides" section for more information about specific engines.

#### `primary`

**Required if your Spacefile contains more than one Micro**

If your app contains more than one Micro, use `primary` to identify which Micro should be used as the entry point of your application. The primary Micro will receive all requests made to your application which are not under another micro's path.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: svelte
    primary: true

  - name: backend
    src: ./backend/
    engine: nodejs16
```

#### `path`

*Optional*

If your app contains more than one Micro, use `path` to specify under which path relative to the hostname a Micro should receive requests. Requests are proxied so you your Micro will receive them at the root, no need to prefix your routes with the given Micro path.

If the `path` is missing, the path will fall back to the Micro `name`.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: svelte
    primary: true

  - name: backend
    src: ./backend/
    engine: nodejs16
    path: api
```

#### `serve`

*Required for static Micros*

Use `serve` to specify which directory should be served for your static Micro. All the files and directories inside the specified directory will be served relative to your Micro's path.

This option can only be used for Micro's with the `static` engine or engines based on it like `vue`, `react` and `svelte`.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: static
    serve: dist/
```

#### `commands`

*Optional*

Use `commands` to specify a set of commands to run before packaging the Micro.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    commands:
      - go get
      - go build main.go
```

#### `include`

*Optional*

Use `include` to specify which files and directories in your Micro's `src` should be part of the final app package. If `include` is used, everything not part of it will be ignored and won't be part of your app. You can specify multiple files and directories.

If your Micro uses a build step, `include` can be used to tell Space to only include the build output in your final app and ignore your source code and other unnecessary files.

```yaml
micros:
  - name: api
    src: ./api/
    engine: nodejs16
    commands:
      - npm run build
    include:
      - build/
      - images/
```

#### `run`

*Optional*

Use `run` to specify a command which starts your Micro. For the Micro to receive requests, it needs to listen on the port specified in the environment variable `PORT`.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    run: ./main
```

#### `dev`

Use `run` to specify a command which starts your Micro in **development** mode. This command will be used to start your micro when you run `deta dev`.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    run: ./main
    dev: go run main.go
```

#### `presets`

*Optional*

Specify different presets to use with your Micro.

##### `env`

*Optional*

Use the `env` preset to specify environment variables that the user can set for a Micro.

- `name` : environment variable name or key
- `description` : human friendly description
- `default` : default value for the variable

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      env:
        - name: SECRET_MESSAGE
          description: Secret message only available to this Micro
          default: "deta is cool"
```

More information on the `env` preset can be found in the [Micro Basics](/docs/en/basics/micros#custom-variables).

##### `api_keys`

*Optional*

Use the `api_keys` preset to enable the use of API keys to access a private routes of a Micro.

The user of your app will be able to generate API keys in the app settings and can use them in requests to a Micro using the `X-Space-App-Key` HTTP header.

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      api_keys: true
```

More information on API Keys can be found in the [Micro Basics](/docs/en/basics/micros#api-keys).

#### `public_routes`

*Optional*

Use `public_routes` to define which paths of your Micro should be available to the public. These routes will not be protected behind auth.

```yaml
micros:
  - name: backend
    src: backend
    engine: python3.9
    public_routes:
      - "/test" # exact match
      - "/public/*" # wildcards
      - "/api/*/docs" # wildcards can be placed anywhere
```

More information on public routes can be found in the [Micro Basics](/docs/en/basics/micros#public-routes).

#### `actions`

*Optional*

Specify actions that perform certain tasks inside your app on a specific trigger like a schedule.

```yaml
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

An action is compromised of the following fields:

- `id` (required): a unique identifier for the action (needs to be unique across the app)
- `name` (required): a human readable name for the action (needs to be unique across the app)
- `description` (optional): a human readable description for the action (max 142 chars)
- `trigger` (required): what triggers the action. Needs to be set to `schedule`.
- `default_interval` (required): interval with which the schedule will run at ([supported intervals](/docs/en/basics/micros#scheduled-actions))

When an action runs, a `POST` request containing the following body will be sent to the path `/__space/v0/actions` on your Micro:

```json
{
  "event": {
    "id": "cleanup",
    "trigger": "schedule"
  }
}
```

It is up to you to handle the request and run whatever logic you need.

Each scheduled action needs to have a default interval at which it runs at. Space currently supports two types of intervals:

##### Rates

You can define the rate at which an action should run. It is comprised of a value and unit.

- `value`: is a non-zero positive integer
- `unit`: unit of time, can be `minute`, `minutes`, `hour`, `hours`, `day`, `days`. If the value is `1` the unit must be `minute`, `hour` or `day`.

**Start Time**

The schedule starts from the time of installation rounded up to:

- `minute` ‚Üí next minute
- `hour` ‚Üí next nearest hour
- `day` ‚Üí next day at `00:00`

**Examples**

- `1 minute`: Run every minute
- `2 hours`: Run every two hours
- `5 days`: Run every five days

##### Cron Expressions

Cron expressions allow you more flexibility and precision when scheduling a task. Cron expressions have five required fields, which are separated by white space and run based on UTC.

| Field        | Values                            | Wildcards |
|--------------|-----------------------------------|-----------|
| Minute       | 0-59                              |  ,-*/     |
| Hour         | 0-23                              |  ,-*/     |
| Day-of-month | 1-31                              |  ,-*/     |
| Month        | 1-12 or jan-dec                   |  ,-*/     |
| Day-of-week  | 0-7 (0 or 7 is Sunday) or sun-sat |  ,-*      |

**Wildcards**

- The , (comma) wildcard includes additional values. In the Month field, jan,feb,mar would include January, February, and March.

- The - (dash) wildcard specifies ranges. In the Day field, 1-15 would include days 1 through 15 of the specified month.

- The * (asterisk) wildcard includes all values in the field. In the Hours field, * would include every hour. You cannot use * in both the Day-of-month and Day-of-week fields. If you use it in one, you must use ? in the other.

- The / (forward slash) wildcard specifies increments. In the Minutes field, you could enter 1/10 to specify every tenth minute, starting from the first minute of the hour (for example, the 11th, 21st, and 31st minute, and so on).

**Limits**

- You can't specify the Day-of-month and Day-of-week fields in the same cron expression. If you specify a value (or a *) in one of the fields, you must use a * (asterisk) in the other.

- Cron expressions that lead to rates faster than 1 minute are not supported.

**Examples**

- `0 10 * * *` : Run at 10:00 am (UTC) every day
- `15 12 * * *` : Run at 12:15 pm (UTC) every day
- `0 18 * * mon-fri` : Run at 6:00 pm (UTC) every Monday through Friday
- `0 8 1 * *` : Run at 8:00 am (UTC) every 1st day of the month
- `0/15 * * * *` : Run every 15 minutes
- `0/5 8-17 * * mon-fri` : Run every 5 minutes Monday through Friday between 8:00 am and 5:55 pm (UTC)


More information on scheduled actions and how to use them in your app can be found in the [Micro Basics](/docs/en/basics/micros#scheduled-actions).
# cli.md

## `space help`

Shows the help page

## `space login`

You can use `space login` to login to Space. The CLI will prompt you for an access token which it will use for future executions. Refer to the [Setting up the CLI](/docs/en/basics/cli#authentication) section for more details.

```bash
space login
```

## `space new`

You can use `space new` to create new projects.

Optional args:

- `-n, --name` string: name of the project
- `-d, --dir` string: where is the project (default ‚Äú./‚Äù)
- `-b, -‚Äîblank` bool: use this flag to create a blank project and ignore all the prompts

```bash
space new
```

## `space dev`

You can use `space dev` to start a local development server for your project. The cli will start one process for each of your micros, then expose a single enpoints for your space app.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-H, --host` string: host to run dev server on (default ‚Äúlocalhost‚Äù)
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev up`

You can use `space dev up` to start a single micro for local development.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev proxy`

You can use `space proxy` to start a reverse proxy for your micros. The micros will be automatically discovered and proxied to.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-H, --host` string: host to run dev server on (default ‚Äúlocalhost‚Äù)
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev trigger`

You can use `space trigger` to manually trigger action. Make sure that the corresponding micro is running before triggering the action.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project

## `space push`

You can use `space push` to push your changes to Space and create a new revision. Space will automatically update your Builder instance with the new revision.

Optional args:

- `-d, --dir`   string: src of project to push (default "./")
- `-i, --id`    string: project id of project to push
- `-t, --tag`   string: tag to identify this push
- `-o, --open`  boolean: open builder instance/project in browser after push
- `--skip-logs` boolean: skip following logs after push

```bash
space push
```

If you don't want to follow the logs of the build and update, pass the `--skip-logs` argument which will exit the process as soon as the build is started instead of waiting for it to finish.

Tip: you can use the [`.spaceignore` file](/docs/en/basics/revisions#ignoring-files-and-directories) to exclude certain files and directories from being uploaded during push.

## `space release`

You can use `space release` to create new releases out of revisions.

Optional args:

- `-d, --dir` string: src of project to release (default "./")
- `-c, --confirm` boolean: confirm all prompts and release latest revision
- `-i, --id` string: project id of an existing project
- `-r, --rid` string: revision id for release
- `-l, --listed` boolean: enable listing on Discovery
- `-n, --notes` provide release notes via interactive prompt
- `--notes="<RELEASE_NOTES>"`: provide release notes directly
- `-v, --version` string: version for the release

```bash
space release
```

## `space link`

You can use `space link` to link a directory with a existing project.

Optional args:

- `-d, --dir` string: src of project to link (default "./")
- `-i, --id` string: project id of project to link

```bash
space link
```

## `space exec`

You can use `space exec` to run a command in the context of your project. The project key will be automatically injected into the environment.

Required args:

- `-p, --project`   string: id of the project

## `space open`

You can use `space open` to open your local project in the Builder UI on [deta.space](https://deta.space).

Optional args:

- `-d, --dir` string: directory of project to open (default "./")
- `-i, --id` string: project id of project to open

```bash
space open
```

## `space validate`

You can use `space validate` to validate your [Spacefile](/docs/en/reference/spacefile/) and check for errors.

Optional args:

- `-d, --dir` string: src of project to validate (default "./")

```bash
space validate
```
# discovery.md

## What's the Discovery.md file?

The `Discovery.md` file allows you to customize the presentation of your Space app on [Discovery](/discovery) - Space's app marketplace.

Write Markdown inside the `Discovery.md` file to explain what your app does, what makes it unique, and its features & functionality. You can think of it as your app's `README` for Deta Space.

In addition to the Markdown description, the `Discovery.md` file supports a Frontmatter section where you can specify metadata like your app's title, its tagline, a theme color and links to a Git repository & an app's website.

Here is an example `Discovery.md` file:

```md
title: "Space: The Personal Cloud"
tagline: "Your own personal computer in the cloud: private, secure & always online."
theme_color: "#f26daa"
git: "https://github.com/deta/deta"
homepage: "https://deta.space"

Your apps, your data. Your *personal cloud computer*.

Space comes with:

- Fully managed servers
- Fully managed security
- Fully managed data
- Fully managed payments
```

You can see that the metadata is separate from the Markdown content by two lines of 3 dashes (`---`). What's between the sets of dashes (`---`) is the Frontmatter section.

> The `Discovery.md` file is different from the [Spacefile](/docs/en/reference/spacefile). The `Discovery.md` file _only_ affects how your app appears on Deta Discovery. It is meant for marketing purposes, whereas the `Spacefile` is used for technical purposes: it tells Space how to run your app and what it looks like once it's installed.

The `Discovery.md` file is uploaded during `space push` and is part of a [revision](/docs/en/basics/revisions#whats-a-revision). When you create a release out of a revision the revision's `Discovery.md` file will be used.

## Options

There are no required options in the `Discovery.md` section, you can pick and choose what to use. We recommend that your app has at least a title and a short Markdown description explaining what it does.

**Note:** To change your app's name or icon you need to modify its [Spacefile](/docs/en/reference/spacefile) since these are used by Space for technical purposes, not just its marketing on Discovery.

Here are all the options supported by `Discovery.md`:

### `title`

Use `title` to give your app a friendly and descriptive name on Discovery.

This is different from the app name used once the app is installed. You can change that using the [`app_name`](/docs/en/reference/spacefile#app_name) option in the [Spacefile](/docs/en/reference/spacefile). The `title` will only be used on Discovery.

Choose a simple and memorable title and try to stand out. Avoid names that use generic terms or are too similar to existing app names.

The `title` needs to start with your app's name and can only have a maximum of `45` characters. We recommend the `title` follows the following format: `App Name: Short Description`.

Here's an example:

```yaml
title: "Space: The Personal Cloud"
```

### `tagline`

Use the `tagline` to provide a short description of your app. This will be shown across Discovery on both the app's page and in featured sections or search.

Your app‚Äôs `tagline` is intended to summarize your app in a concise phrase. Avoid generic descriptions and instead highlight features or typical uses of your app.

The `tagline` can be a maximum of `69` characters.

Here's an example:

```yaml
tagline: "Your own personal computer in the cloud: private, secure & always online."
```

### `theme_color`

Use `theme_color` to style the color of your app's Discovery page to match your app.

`theme_color` only supports hex color values.

```yaml
theme_color: "#f26daa"
```

### `git`

Use `git` to link to your app's Git repository, so users can view its source and can contribute to your app.

You can provide any valid Git URL including a link to a GitHub or GitLab repository.

```yaml
git: "https://github.com/deta/deta"
```

### `homepage`

Use `homepage` to link to an abitrary URL related to your app. This could be your app's marketing page or a documentation website for example.

```yaml
homepage: "https://deta.space"
```

## Markdown content

The main section in the `Discovery.md` file is the Markdown content. It will be displayed on your app's Discovery page similar to a README.

You can use it to describe what your app does in more detail, what makes it unique and/or highlight its features and functionality. The ideal description is a concise, informative paragraph followed by a short list of main features.

The Markdown description has a limit of `4250` characters.

Here's an example:

```md
Your apps, your data. Your *personal cloud computer*.

Space comes with:

- Fully managed servers
- Fully managed security
- Fully managed data
- Fully managed payments
```

### Supported Syntax

The `Discovery.md` file currently does not support the full Markdown spec. You cannot use the following:

- Images (in the future we will add support for app screenshots)
- HTML
- h1 (`#`) headings (they will be converted to h2)
# HTTP.mdx

## General & Auth

> You can get your **Project Key** and your **Project ID** of your Project in [Builder](https://deta.space/builder). You need these to talk with the Deta API.

> ‚ÑπÔ∏è Base currently supports **maximum 16 digit numbers** (integers and floating points), please store larger numbers as a string.

### Root URL
This URL is the base for all your HTTP requests:

**`https://database.deta.sh/v1/{project_id}/{base_name}`**

> The `base_name` is the name given to your database. If you already have a **Base**, then you can go ahead and provide it's name here. Additionally, you could provide any name here when doing any `PUT` or `POST` request and our backend will automatically create a new base for you if it does not exist. There is no limit on how many "Bases" you can create.

### Auth
A **Project Key** _must_ to be provided in the request **headers** as a value for the `X-API-Key` key for authentication. This is how we authorize your requests.

Example `'X-API-Key: a0abcyxz_aSecretValue'`.

### Content Type

We only accept JSON payloads. Make sure you set the headers correctly: `'Content-Type: application/json'`

## Endpoints

### Put Items

**`PUT /items`**

Stores multiple items in a single request. This request overwrites an item if the key already exists.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type    | Description                              |
|--------------|----------|---------|------------------------------------------|
| `items`      | Yes      | `array` | An array of items `object` to be stored. |


    ##### Example

    ```json
    {
       // array of items to put
       "items": [
            {
                "key": {key}, // optional, a random key is generated if not provided
                "field1": "value1",
                // rest of item
            },
            // rest of items
        ]
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `207 Multi Status`

    ```js
    {
        "processed": {
            "items": [
                // items which were stored
            ]
        },
        "failed": {
           "items": [
               // items failed because of internal processing
           ]
        }
    }
    ```

    ##### Client errors

    In case of client errors, **no items** in the request are stored.

    ##### `400 Bad Request`

    ```js
    {
        "errors" : [
           // error messages
        ]
    }
    ```



    Bad requests occur in the following cases:
    - if an item has a non-string key
    - if the number of items in the requests exceeds 25
    - if total request size exceeds 16 MB
    - if any individual item exceeds 400KB
    - if there are two items with identical keys
  </Fragment>

</RequestTabs>




### Get Item

**`GET /items/{key}`**

Get a stored item.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| URL Parameter | Required | Type     | Description                                        |
|---------------|----------|----------|----------------------------------------------------|
| `key`         | Yes      | `string` | The key (aka. ID) of the item you want to retrieve |
  </Fragment>

  <Fragment slot="response">
    ##### `200 OK`

    ```js
    {
      "key": {key},
      // the rest of the item
    }
    ```

    ##### `404 Not Found`
    ```js
    {
      "key": {key}
    }
    ```
  </Fragment>

</RequestTabs>



### Delete Item

**`DELETE /items/{key}`**

Delete a stored item.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| URL Parameter | Required | Type     | Description                                       |
|---------------|----------|----------|---------------------------------------------------|
| `key`         | Yes      | `string` | The key (aka. ID) of the item you want to delete. |
  </Fragment>

  <Fragment slot="response">
    The server will always return `200` regardless if an item with that `key` existed or not.

    ##### `200 OK`

    ```json
    {
      "key": {key}
    }
    ```
  </Fragment>

</RequestTabs>



### Insert Item

**`POST /items`**

Creates a new item only if no item with the same `key` exists.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type     | Description            |
|--------------|----------|----------|------------------------|
| `item`       | Yes      | `object` | The item to be stored. |

    ##### Example

    ```json
    {
        "item": {
            "key": {key}, // optional
            // rest of item
        }
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `201 Created`

    ```json
    {
      "key": {key}, // auto generated key if key was not provided in the request
      "field1": "value1",
      // the rest of the item
    }
    ```

    ##### Client errors

    ##### `409 Conflict` (if key already exists)

    ```json
    {
      "errors": ["Key already exists"]
    }
    ```

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
         // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if the item has a non-string key
    - if size of the item exceeds 400KB
  </Fragment>

</RequestTabs>



### Update Item

**`PATCH /items/{key}`**

Updates an item only if an item with `key` exists.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type              | Description                                                          |
|--------------|----------|-------------------|----------------------------------------------------------------------|
| `set`        | no       | `object`          | The attributes to be updated or created.                             |
| `increment`  | no       | `object`          | The attributes to be incremented. Increment value can be negative.   |
| `append`     | no       | `object`          | The attributes to append a value to. Appended value must be a list.  |
| `prepend`    | no       | `object`          | The attributes to prepend a value to. Prepended value must be a list.|
| `delete`     | no       | `string array`    | The attributes to be deleted.                                        |

    ##### Example

    If the following item exists in the database

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the request

    ```json
    {
       "set" : {
         // change ages to 33
         "profile.age": 33,
         // change active to true
         "profile.active": true,
         // add a new attribute `profile.email`
         "profile.email": "jimmy@deta.sh"
       },

       "increment" :{
         // increment purchases by 2
         "purchases": 2
       },

       "append": {
         // append to 'likes'
         "likes": ["ramen"]
       },

       // remove attributes 'profile.hometown' and 'on_mobile'
       "delete": ["profile.hometown", "on_mobile"]
    }
    ```

    results in the following item in the database:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes": ["anime", "ramen"],
      "purchases": 3
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `200 OK`

    ```json
    {
       "key": {key},
       "set": {
         // identical to the request
       },
       "delete": ["field1", ..] // identical to the request
    }
    ```

    ##### Client errors

    ##### `404 Not Found` (if key does not exist)

    ```json
    {
      "errors": ["Key not found"]
    }
    ```

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
         // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if you're updating or deleting the `key`
    - if `set` and `delete` have conflicting attributes
    - if you're setting a hierarchical attribute but an upper level attribute does not exist, for eg. `{"set": {"user.age": 22}}` but `user` is not an attribute of the item.
  </Fragment>

</RequestTabs>



### Query Items

**`POST /query`**

List items that match a [query](/docs/en/reference/base/queries).

<RequestTabs>

  <Fragment slot="request">
| JSON Payload    | Required | Type     | Description                                    |
|-----------------|----------|----------|------------------------------------------------|
| `query`         | No       | `list`   | list of a [query](/docs/en/reference/base/queries)|
| `limit`         | No       | `int`    | no of items to return. min value 1 if used     |
| `last`          | No       | `string` | last key seen in a previous paginated response |


    ##### Example

    ```json
    {
       "query": [
            // separate objects in the list are ORed
            // query evaluates to list all users whose hometown is Berlin and is active OR all users who age less than 40
            {"user.hometown": "Berlin", "user.active": true},
            {"user.age?lt": 40}
       ],
       "limit": 5,
       "last": "afsefasd" // last key if applicable
    }
    ```
  </Fragment>

  <Fragment slot="response">
    The response is paginated if data process size exceeds 1 MB (before the query is applied) or the total number of items matching the `query` exceeds the `limit` provided in the request.

    For paginated responses, `last` will return the last key seen in the response. You must use this `key` in the following request to continue retreival of items. If the response does not have the `last` key, then no further items are to be retreived.

    > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
    >
    > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

    ##### `200 OK`

    ```json
    {
        "paging": {
            "size": 5, // size of items returned
            "last": "adfjie" // last key seen if paginated, provide this key in the following request
        },
        "items": [
           {
             "key": {key},
             // rest of the item
           },
           // rest of the items
       ]
    }
    ```

    ##### Client Errors

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
        // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if a query is made on the `key`
    - if a query is not of the right format
    - if `limit` is provided in the request and is less than 1
  </Fragment>

</RequestTabs>



## Issues

If you run into any issues, consider reporting them in our [Github Discussions](https://github.com/orgs/deta/discussions).# async_sdk.md

## Installing

```
pip install deta[async]==1.1.0a2
```

## Instantiating

```py
from deta import Deta

# initialize with a project key
# you can also init without specfying the project key explicitly
# the sdk looks for the DETA_PROJECT_KEY env var in that case
deta = Deta("project_key")

# create an async base client
async_db = deta.AsyncBase("base_name")
```

## Methods

The **`AsyncBase`** class offers the same API to interact with your Base as the **`Base`** class:

### Put

```py
put(
	data: typing.Union[dict, list, str, int, float, bool],
	key: str = None,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime]
)
```

- **data** (required): The data to be stored.
- **key** (optional): The key to store the data under. It will be auto-generated if not provided.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](#./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def put_item():
	item = {"msg": "hello"}
	await async_db.put(item, "test")
	print("put item:", item)

	# put expiring items
	# expire item in 300 seconds
	await async_db.put(item, expire_in=300)

	# with expire at
	expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
	await async_db.put({"name": "max", "age": 28}, "max28", expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(put_item())
```

### Get

```py
get(key: str)
```

- **key** (required): The key of the item to be retrieved.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def get_item():
	item = await async_db.get("my_key")
	print("got item:", item)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(get_item())
```

### Delete

```py
delete(key: str)
```

- **key** (required): The key of the item to delete.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def del_item():
	await async_db.delete("my-key")
	print("Deleted item")

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(del_item())
```

### Insert

`insert` is unique from `put` in that it will raise an error if the `key` already exists in the database, whereas `put` overwrites the item.

```py
insert(
	data: typing.Union[dict, list, str, int, float, bool],
	key: str = None,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **data** (required): The data to be stored.
- **key** (optional): The key to store the data under, will be auto generated if not provided.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def insert_item():
	item = {"msg": "hello"}
	await async_db.insert(item, "test")
	print("inserted item:", item)

	# put expiring items
    # expire item in 300 seconds
    await async_db.insert(item, expire_in=300)

    # with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    await async_db.insert({"name": "max", "age": 28}, "max28", expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(insert_item())
```

### Put Many

```py
put_many(
	items: typing.List[typing.Union[dict, list, str, int, bool]],
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **items** (required): list of items to be stored.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def put_items():
	items = [{"key": "one", "value": 1}, {"key": "two", "value": 2}]
	await async_db.put_many(items)
	print("put items:", items)

	# put with expiring items
	# expire in 300 seconds
	await async_db.put_many(items, expire_in=300)

	# with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    await async_db.put_many(items, expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(put_items())
```

### Update

```py
update(
	updates:dict,
	key:str,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **updates** (required): A dict describing the updates on the item, refer to [updates](/docs/en/reference/base/sdk#update) for more details.
- **key** (required): The key of the item to update.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def update_item():
	updates = {"profile.age": 20, "likes": async_db.util.append("ramen")}
	await async_db.update(updates, "jimmy")
	print("updated user jimmy")

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(update_item())
```

### Fetch

**`fetch(query=None, limit=1000, last=None)`**

- **query** : a [query or a list of queries](/docs/en/reference/base/queries)
- **limit** : the limit of the number of items you want to recieve, min value `1` if used.
- **last**: the last key seen in a previous paginated response.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def fetch_items():
	query = {"profile.age?gt": 20}
	res = await async_db.fetch(query)
	print("fetched items": res.items)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(fetch_items())
```


# sdk.mdx

## Installing

<br />
<LangTabs>
  <Fragment slot="js">
  Using NPM:

    ```shell
    npm install deta
    ```

    Using Yarn:
    ```shell
    yarn add deta
    ```

  </Fragment>
  <Fragment slot="py">
  ```shell
	pip install deta
	```
  </Fragment>
  <Fragment slot="go">
  ```shell
	go get github.com/deta/deta-go
	```
  </Fragment>
</LangTabs>

> If you are using the Deta SDK within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your dependencies file (`package.json` or `requirements.txt`) to install the latest sdk version.



## Instantiating

To start working with your Base, you need to import the `Deta` class and initialize it with a **Project Key**. Then instantiate a subclass called `Base` with a database name of your choosing.

Deta Bases are created for you automatically when you start using them.

<br />
<LangTabs>

  <Fragment slot="js">
    ```js
    const { Deta } = require('deta'); // import Deta

    // Initialize with a Project Key
    const deta = Deta('project key');

    // This how to connect to or create a database.
    const db = deta.Base('simple_db');

    // You can create as many as you want without additional charges.
    const books = deta.Base('books');
    ```

    > If you are using Deta Base within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), the **Deta SDK** comes pre-installed and a valid project key is pre-set in the Micro's environment. There is no need to install the SDK or pass a key in the initialization step.
    > ```js
    > const { Deta } = require('deta');
    >
    > const deta = Deta();
    > ```

    > If you are using the `deta` npm package of `0.0.6` or below, `Deta` is the single default export and should be imported as such.
    > ```js
    > const Deta = require('deta');
    > ```
  </Fragment>

  <Fragment slot="py">
    ```py
    from deta import Deta  # Import Deta

    # Initialize with a Project Key
    deta = Deta("project key")

    # This how to connect to or create a database.
    db = deta.Base("simple_db")

    # You can create as many as you want without additional charges.
    books = deta.Base("books")

    ```

    > If you are using Deta Base within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), the **Deta SDK** comes pre-installed and a valid project key is pre-set in the Micro's environment. There is no need to install the SDK or pass a key in the the initialization step.
    > ```py
    > from deta import Deta
    >
    > deta = Deta()
    > ```
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        func main() {

          // initialize with project key
          // returns ErrBadProjectKey if project key is invalid
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          // initialize with base name
          // returns ErrBadBaseName if base name is invalid
          db, err := base.New(d, "base_name")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
            return
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        ```go
        import (
          "fmt"
          "github.com/deta/deta-go"
        )

        func main(){
          // initialize with project key
          // returns ErrBadProjectKey if project key is invalid
          d, err := deta.New("project_key")
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          // initialize with base name
          // returns ErrBadBaseName if base name is invalid
          db, err := d.NewBase("base_name")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
            return
          }
        }
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

</LangTabs>

> ‚ö†Ô∏è Your project key is confidential and meant to be used by you. Anyone who has your project key can access your database. Please, do not share it or commit it in your code.



## Using

Deta's **`Base`** class offers the following methods to interact with your Deta Base:

[**`put`**](#put) ‚Äì Stores an item in the database. It will update an item if the key already exists.

[**`insert`**](#insert) ‚Äì Stores an item in the database but raises an error if the key already exists. (2x slower than `put`).

[**`get`**](#get) ‚Äì Retrieves an item from the database by its key.

[**`fetch`**](#fetch) ‚Äì Retrieves multiple items from the database based on the provided (optional) filters.

[**`delete`**](#delete) ‚Äì Deletes an item from the database.

[**`update`**](#update) ‚Äì Updates an item in the database.



##### Storing Numbers

> ‚ö†Ô∏è Base currently supports **maximum 16 digit numbers** (integers and floating points), please store larger numbers as a string.



### Put

`put` is the fastest way to store an item in the database.

If an item already exists under a given key, put will replace this item.

In the case you do not provide us with a key, we will auto generate a 12 char long string as a key.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async put(data, key = null, options = null)`**

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` and `array`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `string`, `null` or `undefined`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull put operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    ##### Code Example

    ```js
    const Deta = require('deta');

    const deta = Deta("project key");
    const db = deta.Base("simple_db");

    // store objects
    // a key will be automatically generated
    await db.put({name: "alex", age: 77})
    // we will use "one" as a key
    await db.put({name: "alex", age: 77}, "one")
    // the key could also be included in the object itself
    await db.put({name: "alex", age: 77, key:"one"})

    // store simple types
    await db.put("hello, worlds")
    await db.put(7)
    // "success" is the value and "smart_work" is the key.
    await db.put("success", "smart_work")
    await db.put(["a", "b", "c"], "my_abc")

    // put expiring items
    // expire item in 300 seconds
    await db.put({"name": "alex", age: 21}, "alex21", {expireIn: 300})
    // expire item at expire date
    await db.put({"name": "max", age:28}, "max28", {expireAt: new Date('2023-01-01T00:00:00')})
    ```

    ##### Returns

    `put` returns a promise which resolves to the item on a successful put, otherwise it throws an Error.
  </Fragment>

  <Fragment slot="py">
    ```py
    put(
      data: typing.Union[dict, list, str, int, float, bool],
      key: str = None,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `dict`, `str`, [`int`](#storing-numbers), [`float`](#storing-numbers), `bool` and `list`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `str` and `None`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


    ##### Code Example
    ```py
    from deta import Deta
    deta = Deta("project key")
    db = deta.Base("simple_db")

    # store objects
    # a key will be automatically generated
    db.put({"name": "alex", "age": 77})
    # we will use "one" as a key
    db.put({"name": "alex", "age": 77}, "one")
    # the key could also be included in the object itself
    db.put({"name": "alex", "age": 77, "key": "one"})

    # simple types
    db.put("hello, worlds")
    db.put(7)
    # "success" is the value and "smart_work" is the key.
    db.put("success", "smart_work")
    db.put(["a", "b", "c"], "my_abc")

    # expiring items
    # expire item in 300 seconds
    db.put({"name": "alex", "age": 23}, "alex23", expire_in=300)
    # expire item at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put({"name": "max", "age": 28}, "max28", expire_at=expire_at)
    ```

    ##### Returns

    `put` returns the item on a successful put, otherwise it raises an error.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Put(item interface{}) (string, error)`**

        ##### Parameters

        - **item** : The item to be stored, should be a `struct` or a `map`. If the item is a `struct` provide the field keys for the data with json struct tags. The key of the item must have a json struct tag of `key`. For storing expiring items, the field name `__expires` should be used with a [Unix Time](https://pkg.go.dev/time#Time.Unix) value, see also [expiring items](./expiring_items).

        [Note for storing numbers](#storing-numbers)

        ##### Code Example
        ```go

        import (
          "log"
          "time"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          // json struct tag 'key' used to denote the key
          Key      string   `json:"key"`
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
          // json struct tag '__expires' for expiration timestamp
          // 'omitempty' for omission of default 0 value
          Expires  int64 `json:"__expires,omitempty"`
        }

        func main() {
          // errors ignored for brevity
          d, _ := deta.New(deta.WithProjectKey("project_key"))
          db, _ := base.New(d, "users")

          u := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }
          key, err := db.Put(u)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("successfully put item with key", key)

          // can also use a map
          um := map[string]interface{}{
            "key":      "kasdlj1",
            "username": "jimmy",
            "active":   true,
            "age":      20,
            "likes":    []string{"ramen"},
          }
          key, err = db.Put(um)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("Successfully put item with key:", key)

          // put with expires
          u := &User{
            Key: "will_be_deleted",
            Username: "test_user",
            Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, 0, time.UTC).Unix(),
          }
          key, err = db.Put(u)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("put item with key:", key)

          // put map with expires
          um = map[string]interface{}{
            "key": "will_be_deleted",
            "test": true,
            "__expires": time.Data(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
          }
          key, err = db.Put(um)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("put item with key:", key)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Put(item interface{}) (string, error)`**

        ##### Parameters

        - **item** : The item to be stored, should be a `struct` or a `map`. If the item is a `struct` provide the field keys for the data with json struct tags. The key of the item must have a json struct tag of `key`. For storing expiring items, the field name `__expires` should be used with a [Unix Time](https://pkg.go.dev/time#Time.Unix) value, see also [expiring items](./expiring_items).

        [Note for storing numbers](#storing-numbers)

        ##### Code Example
        ```go
        import (
            "log"
            "time"
            "github.com/deta/deta-go"
        )

        // User represents a user
        type User struct{
            // json struct tag 'key' used to denote the key
            Key      string `json:"key"`
            Username string `json:"username"`
            Active   bool `json:"active"`
            Age      int `json:"age"`
            Likes    []string `json:"likes"`
            // json struct tag '__expires' for expiration timestamp,
            // tag has 'omitempty' for ommission of default 0 values
            Expires  int64 `json:"__expires,omitempty"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a user
            u := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }

            // put item in the database
            key, err := db.Put(u)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // can also use a map
            um := map[string]interface{}{
              "key": "kasdlj1",
              "username": "jimmy",
              "active": true,
              "age": 20,
              "likes": []string{"ramen"},
            }

            key, err = db.Put(um)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // expiring items
            u = &User {
              Key: "will_be_deleted",
              Username: "test_user",
              Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
            }
            key, err = db.Put(u)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // maps with expiration timestamp
            um = map[string]interface{}{
              "key": "will_be_deleted",
              "test": true,
              "__expires": time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
            }

            key, err = db.Put(um)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns the `key` of the item stored and an `error`. Possible error values:

    - `ErrBadItem` : bad item, item is of unexpected type
    - `ErrBadRequest`: item caused a bad request response from the server
    - `ErrUnauthorized`: unuathorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Get
`get` retrieves an item from the database by it's `key`.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async get(key)`**

    ##### Parameters

    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of which item is to be retrieved.

    ##### Code Example

    ```js
    const item = await db.get('one'); // retrieving item with key "one"
    ```


    ##### Returns

    If the record is found, the promise resolves to:
    ```js
    {
      name: 'alex', age: 77, key: 'one'
    }
    ```
    If not found, the promise will resolve to `null`.
  </Fragment>

  <Fragment slot="py">
    ```py
    get(key: str)
    ```

    ##### Parameter Types

    - **key** (required) ‚Äì Accepts: `str`
        - Description: the key of which item is to be retrieved.

    ##### Code Example
    ```py
    item = db.get("one") # retrieving item with key "one"
    ```

    ##### Returns

    If the record is found:
    ```py
    {
      "name": "alex", "age": 77, "key": "one"
    }
    ```

    If not found, the function will return `None`.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Get(key string, dest interface{}) error`**

        ##### Parameters
        - **key**: the key of the item to be retrieved
        - **dest**: the result will be stored into the value pointed by `dest`

        ##### Code Example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // a variable to store the result
          var u User

          // get item
          // returns ErrNotFound if no item was found
          err = db.Get("kasdlj1", &u)
          if err != nil {
            fmt.Println("failed to get item:", err)
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Get(key string, dest interface{}) error`**

        ##### Parameters
        - **key**: the key of the item to be retrieved
        - **dest**: the result will be stored into the value pointed by `dest`

        ##### Code Example

        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a variable to store the result
            var u User

            // get item
            // returns ErrNotFound if no item was found
            err := db.Get("kasdlj1", &u)
            if err != nil{
                fmt.Println("failed to get item:", err)
            }
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns an `error`. Possible error values:

    - `ErrNotFound`: no item with such key was found
    - `ErrBadDestination`: bad destination, result could not be stored onto `dest`
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Delete
`delete` deletes an item from the database that matches the key provided.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async delete(key)`**

    ##### Parameters
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of which item is to be deleted.

    ##### Code Example

    ```js
    const res = await db.delete("one")
    ```



    ##### Returns

    Always returns a promise which resolves to `null`, even if the key does not exist.
  </Fragment>

  <Fragment slot="py">
    ```py
    delete(key: str)
    ```

    ##### Parameters
    - **key** (required) ‚Äì Accepts: `str`
        - Description: the key of the item that is to be deleted.

    ##### Code Example

    ```py
    res = db.delete("one")
    ```

    ##### Returns

    Always returns `None`, even if the key does not exist.
  </Fragment>

  <Fragment slot="go">
    **`Delete(key string) error`**

    ##### Parameters
    - **key**: the key of the item to be deleted
    ##### Code Example
    ```go
    // delete item
    // returns a nil error if item was not found
    err := db.Delete("dakjkfa")
    if err != nil {
      fmt.Println("failed to delete item:", err)
    }
    ```
    ##### Returns

    Returns an `error`. A `nil` error is returned if no item was found with provided `key`. Possible error values:

    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Insert
The `insert` method inserts a single item into a **Base**, but is unique from [`put`](#put) in that it will raise an error of the `key` already exists in the database.

> ‚ÑπÔ∏è `insert` is roughly 2x slower than [`put`](#put).

<br />
<LangTabs>

  <Fragment slot="js">
    **`async insert(data, key = null, options = null)`**

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` and `array`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `string` and `null`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull insert operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).


    ##### Code Example
    ```js
    // will succeed, a key will be auto-generated
    const res1 = await db.insert('hello, world');

    // will succeed.
    const res2 = await db.insert({message: 'hello, world'}, 'greeting1');

    // will raise an error as key "greeting1" already existed.
    const res3 = await db.insert({message: 'hello, there'}, 'greeting1');

    // expire item in 300 seconds
    await db.insert({message: 'will be deleted'}, 'temp_key', {expireIn: 300})

    // expire at date
    await db.insert({message: 'will be deleted'}, 'temp_key_2', {expireAt: new Date('2023-01-01T00:00:00')})
    ```

    ##### Returns

    Returns a promise which resolves to the item on a successful insert, and throws an error if the key already exists.
  </Fragment>

  <Fragment slot="py">
    ```py
    insert(
      data: typing.Union[dict, list, str, int, float, bool],
      key: str = None,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `dict`, `str`, [`int`](#storing-numbers), [`float`](#storing-numbers), `bool` and `list`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `str` and `None`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

    ##### Code Example
    ```py
    # will succeed, a key will be auto-generated
    db.insert("hello, world")

    # will succeed.
    db.insert({"message": "hello, world"}, "greeting1")

    # will raise an error as key "greeting1" already existed.
    db.insert({"message": "hello, there"}, "greeting1")

    # expiring items
    # expire in 300 seconds
    db.insert({"message": "will be deleted"}, "temp_greeting", expire_in=300)

    # expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.insert({"message": "will_be_deleted"}, "temp_greeting2", expire_at=expire_at)
    ```

    ##### Returns

    Returns the item on a successful insert, and throws an error if the key already exists.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Insert(item interface{}) (string, error)`**

        ##### Parameters
        - **item** : similar to `item` parameter to [`Put`](#put)

        ##### Code Example

        ```go

        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          u := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }

          // insert item in the database
          key, err := db.Insert(u)
          if err != nil {
            fmt.Println("failed to insert item:", err)
            return
          }
          fmt.Println("Successfully inserted item with key:", key)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Insert(item interface{}) (string, error)`**

        ##### Parameters
        - **item** : similar to `item` parameter to [`Put`](#put)


        ##### Code Example

        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a user
            u := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }

            // insert item in the database
            key, err := db.Insert(u)
            if err != nil {
                fmt.Println("failed to insert item:", err)
                return
            }
            fmt.Println("Successfully inserted item with key:", key)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns
    Returns the `key` of the item inserted and an `error`. Possible error values:

    - `ErrConflict` : if item with provided `key` already exists
    - `ErrBadItem`: bad item, if item is of unexpected type
    - `ErrBadRequest`: item caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Put Many
The Put Many method puts up to 25 items into a Base at once on a single call.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async putMany(items, options)`**

    ##### Parameters

    - **items** (required) ‚Äì Accepts: `Array` of items, where each "item" can be an `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` or `array`.
        - Description: The list of items to be stored.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
      - Description: Optional parameters.
        - **expireIn** : item will expire in `expireIn` seconds after a successfull put operation, see also [expiring items](./expiring_items).
        - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    ##### Code Example
    ```js

    await db.putMany([
      {"name": "Beverly", "hometown": "Copernicus City", "key": "one"}, // key provided
      "dude", // key auto-generated
      ["NamaskƒÅra", "marhabaan", "hello", "yeoboseyo"] // key auto-generated
    ]);

    // putMany with expire in 300 seconds
    await db.putMany(
      [
        {"key": "temp-1", "name": "test-1"},
        {"key": "temp-2", "name": "test-2"},
      ],
      {expireIn: 300}
    );

    // putMany with expire at
    await db.putMany(
      [
        {"key": "temp-1", "name": "test-1"},
        {"key": "temp-2", "name": "test-2"},
      ],
      {expireAt: new Date('2023-01-01T00:00:00')}
    );

    ```

    ##### Returns

    Returns a promise which resolves to the put items on a successful insert, and throws an error if you attempt to put more than 25 items.

    ```json
    {
        "processed": {
            "items": [
                {
                    "hometown": "Copernicus City",
                    "key": "one",
                    "name": "Beverly"
                },
                {
                    "key": "jyesxxlrezo0",
                    "value": "dude"
                },
                {
                    "key": "5feqybn7lb05",
                    "value": [
                        "NamaskƒÅra",
                        "hello",
                        "marhabaan",
                        "yeoboseyo"
                    ]
                }
            ]
        }
    }
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    put_many(
      items: list,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None,
    )
    ```

    ##### Parameters

    - **items** (required) ‚Äì Accepts: `list` of items, where each "item" can be an `dict` (JSON serializable), `str`, [`int`](#storing-numbers), `bool`, [`float`](#storing-numbers) or `list`.
        - Description: The list of items to be stored.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)



    ##### Code Example
    ```py
    db.put_many([
      {"name": "Beverly", "hometown": "Copernicus City", "key": "one"}, // key provided
      "dude", // key auto-generated
      ["NamaskƒÅra", "marhabaan", "hello", "yeoboseyo"] // key auto-generated
    ])

    # put many to expire in 300 seconds
    db.put_many(
      [{"key": "tmp-1", "value": "test-1"}, {"key": "tmp-2", "value": "test-2"}],
      expire_in=300,
    )

    # put many with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put_many(
      [{"key": "tmp-1", "value": "test-1"}, {"key": "tmp-2", "value": "test-2"}],
      expire_at=expire_at,
    )
    ```

    ##### Returns

    Returns a dict with `processed` and `failed`(if any) items .

    ```json
    {
        "processed": {
            "items": [
                {
                    "hometown": "Copernicus City",
                    "key": "one",
                    "name": "Beverly"
                },
                {
                    "key": "jyesxxlrezo0",
                    "value": "dude"
                },
                {
                    "key": "5feqybn7lb05",
                    "value": [
                        "NamaskƒÅra",
                        "hello",
                        "marhabaan",
                        "yeoboseyo"
                    ]
                }
            ]
        }
    }
    ```
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`PutMany(items interface{}) ([]string, error)`**

        ##### Parameters:
        - **items**: a slice of items, each item in the slice similar to the `item` parameter in [`Put`](#put)

        ##### Code Example:
        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // users
          u1 := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }
          u2 := &User{
            Key:      "askdjf",
            Username: "joel",
            Active:   true,
            Age:      23,
            Likes:    []string{"coffee"},
          }
          users := []*User{u1, u2}

          // put items in the database
          keys, err := db.PutMany(users)
          if err != nil {
            fmt.Println("failed to put items:", err)
            return
          }
          fmt.Println("Successfully put item with keys:", keys)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`PutMany(items interface{}) ([]string, error)`**

        ##### Parameters:
        - **items**: a slice of items, each item in the slice similar to the `item` parameter in [`Put`](#put)


        ##### Code Example:
        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // users
            u1 := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }
            u2 := &User{
              Key: "askdjf",
              Username: "joel",
              Active: true,
              Age: 23,
              Likes: []string{"coffee"},
            }
            users := []*User{u1, u2}

            // put items in the database
            keys, err := db.PutMany(users)
            if err != nil {
                fmt.Println("failed to put items:", err)
                return
            }
            fmt.Println("Successfully put item with keys:", keys)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns
    Returns the list of keys of the items stored and an `error`. In case of an error, none of the items are stored. Possible error values:

    - `ErrTooManyItems`: if there are more than 25 items
    - `ErrBadItem`: bad item/items, one or more item of unexpected type
    - `ErrBadRequest`: one or more item caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Update
`update` updates an existing item from the database.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async update(updates, key, options)`**

    ##### Parameters

    - **updates** (required) - Accepts: `object` (JSON serializable)
        - Description: a json object describing the updates on the item
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of the item to be updated.
    - **options** (optional) - Accepts: `object`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull update operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    [Note for storing numbers](#storing-numbers)

    ###### Update operations
    - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided in the `set` object if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

    - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `base.util.increment(value)` should be used to increment the value. The *default value is 1* if not provided and it can also be negative.

    - **Append**: `Append` appends to a list. The util `base.util.append(value)` should be used to append the value. The value can be a `primitive type` or an `array`.

    - **Prepend**: `Prepend` prepends to a list. The util `base.util.prepend(value)` should be used to prepend the value. The value can be a `primitive type` or an `array`.

    - **Trim**: `Trim` removes an attribute from the item, the util `base.util.trim()` should be used as the value of an attribute.

    ##### Code Example

    Consider we have the following item in a base `const users = deta.Base('users')`:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the following update operation :

    ```js
    const updates = {
      "profile.age": 33, // set profile.age to 33
      "profile.active": true, // set profile.active to true
      "profile.email": "jimmy@deta.sh", // create a new attribute 'profile.email'
      "profile.hometown": users.util.trim(), // remove 'profile.hometown'
      "on_mobile": users.util.trim(), // remove 'on_mobile'
      "purchases": users.util.increment(2), // increment 'purchases' by 2, default value is 1
      "likes": users.util.append("ramen") // append 'ramen' to 'likes', also accepts an array
    }

    const res = await db.update(updates, "user-a");
    ```

    Results in the following item in the base:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes": ["anime", "ramen"],
      "purchases": 3
    }
    ```

    ##### Returns

    If the item is updated, the promise resolves to `null`. Otherwise, an error is raised.
  </Fragment>

  <Fragment slot="py">
    ```py
    update(
      updates: dict,
      key: str,
      *,
      expire_in: int = None,
      expire_at: typing.Union [int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **updates** (required) - Accepts: `dict` (JSON serializable)
        - Description: a dict describing the updates on the item
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of the item to be updated.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

    [Note for storing numbers](#storing-numbers)

    ###### Update operations
    - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided in the `set` dict if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

    - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `base.util.increment(value)` should be used to increment the value. The *default value is 1* if not provided and it can also be negative.

    - **Append**: `Append` appends to a list. The util `base.util.append(value)` should be used to append the value. The value can be a `primitive type` or a `list`.

    - **Prepend**: `Prepend` prepends to a list. The util `base.util.prepend(value)` should be used to prepend the value. The value can be a `primitive type` or a `list`.

    - **Trim**: `Trim` removes an attribute from the item, the util `base.util.trim()` should be used as the value of an attribute.

    ##### Code Example

    Consider we have the following item in a base `users = deta.Base('users')`:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the following update operation:

    ```py
    updates = {
      "profile.age": 33,  # set profile.age to 33
      "profile.active": True, # set profile.active to true
      "profile.email": "jimmy@deta.sh", # create a new attribute 'profile.email'
      "profile.hometown": users.util.trim(), # remove 'profile.hometown'
      "on_mobile": users.util.trim(), # remove 'on_mobile'
      "purchases": users.util.increment(2), # increment by 2, default value is 1
      "likes": users.util.append("ramen") # append 'ramen' to 'likes', also accepts a list
    }

    db.update(updates, "user-a")
    ```

    Results in the following item in the base:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes":["anime", "ramen"],
      "purchases": 3
    }
    ```

    ##### Returns

    If the item is updated, returns `None`. Otherwise, an exception is raised.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Update(key string, updates Updates) error`**

        ##### Parameters

        - **key**: the key of the item to update
        - **updates** : updates applied to the item, is of type `base.Updates` which is a `map[string]interface{}`

        [Note for storing numbers](#storing-numbers)

        ###### Update operations
        - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

        - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `Base.Util.Increment(value interface{})` should be used to increment the value. The value can also be negative.

        - **Append**: `Append` appends to a list. The util `Base.Util.Append(value interface{})` should be used to append the value. The value can be a slice.

        - **Prepend**: `Prepend` prepends to a list. The util `Base.Util.Prepend(value interface{})` should be used to prepend the value. The value can be a slice.

        - **Trim**: `Trim` removes an attribute from the item, the util `Base.Util.Trim()` should be used as the value of an attribute.

        ##### Code Example

        Consider we have the following item in a base `users`:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 32,
            "active": false,
            "hometown": "pittsburgh"
          },
          "likes": ["anime"],
          "purchases": 1
        }
        ```

        Then the following update operation :

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type Profile struct {
          Active   bool   `json:"active"`
          Age      int    `json:"age"`
          Hometown string `json:"hometown"`
        }

        type User struct {
          Key       string   `json:"key"` // json struct tag 'key' used to denote the key
          Username  string   `json:"username"`
          Profile   *Profile `json:"profile"`
          Purchases int      `json:"purchases"`
          Likes     []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // define the updates
          updates := base.Updates{
            "profile.age": 33, // set profile.age to 33
            "profile.active": true, // set profile.active to true
            "profile.hometown": db.Util.Trim(), // remove 'profile.hometown'
            "purchases": db.Util.Increment(2), // increment 'purchases' by 2
            "likes": db.Util.Append("ramen"), // append 'ramen' to 'likes', also accepts a slice
          }
          // update
          err = db.Update("user-a", updates)
          if err != nil {
            fmt.Println("failed to update", err)
            return
          }
        }
        ```

        Results in the following item in the base:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 33,
            "active": true,
          },
          "likes": ["anime", "ramen"],
          "purchases": 3
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Update(key string, updates Updates) error`**

        ##### Parameters

        - **key**: the key of the item to update
        - **updates** : updates applied to the item, is of type `deta.Updates` which is a `map[string]interface{}`

        [Note for storing numbers](#storing-numbers)

        ###### Update operations
        - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

        - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `Base.Util.Increment(value interface{})` should be used to increment the value. The value can also be negative.

        - **Append**: `Append` appends to a list. The util `Base.Util.Append(value interface{})` should be used to append the value. The value can be a slice.

        - **Prepend**: `Prepend` prepends to a list. The util `Base.Util.Prepend(value interface{})` should be used to prepend the value. The value can be a slice.

        - **Trim**: `Trim` removes an attribute from the item, the util `Base.Util.Trim()` should be used as the value of an attribute.

        ##### Code Example

        Consider we have the following item in a base `users`:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 32,
            "active": false,
            "hometown": "pittsburgh"
          },
          "on_mobile": true,
          "likes": ["anime"],
          "purchases": 1
        }
        ```

        Then the following update operation :

        ```go
        // define the updates
        updates := deta.Updates{
          "profile.age": 33, // set profile.age to 33
          "profile.active": true, // set profile.active to true
          "profile.email": "jimmy@deta.sh", // create a new attribute 'profile.email'
          "profile.hometown": users.Util.Trim(), // remove 'profile.hometown'
          "on_mobile": users.Util.Trim(), // remove 'on_mobile'
          "purchases": users.Util.Increment(2), // increment 'purchases' by 2
          "likes": users.Util.Append("ramen") // append 'ramen' to 'likes', also accepts a slice
        }

        // update
        err := users.Util.Update("user-a", updates);
        ```

        Results in the following item in the base:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 33,
            "active": true,
            "email": "jimmy@deta.sh"
          },
          "likes": ["anime", "ramen"],
          "purchases": 3
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns an `error`. Possible error values:

    - `ErrBadRequest`: the update operation caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Fetch
Fetch retrieves a list of items matching a query. It will retrieve everything if no query is provided.

A query is composed of a single [query](/docs/en/reference/base/queries) object or a list of [queries](/docs/en/reference/base/queries).
In the case of a list, the indvidual queries are OR'ed.

<br />
<LangTabs>

  <Fragment slot="js">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`async fetch(query, options)`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb).
        - **options**: optional params:
          - `limit`: the limit of the number of items you want to retreive, min value `1` if used.
          - `last`: the last key seen in a previous paginated response, provide this in a subsequent call to fetch further items.

        > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
        >
        > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

        ##### Returns

        A promise which resolves to an object with the following attributes:

        - `count` : The number of items in the response.

        - `last`: The last key seen in the fetch response. If `last` is not `undefined` further items are to be retreived.

        - `items`: The list of items retreived.


        ##### Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```js
        const { items: myFirstSet } = await db.fetch({"age?lt": 30});
        const { items: mySecondSet } = await db.fetch([
          { "age?gt": 50 },
          { "hometown": "Greenville" }
        ])
        ```

        ... will come back with following data:

        ###### `myFirstSet`:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `mySecondSet`:

        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Fetch All Items

        ```js
        let res = await db.fetch();
        let allItems = res.items;

        // continue fetching until last is not seen
        while (res.last){
          res = await db.fetch({}, {last: res.last});
          allItems = allItems.concat(res.items);
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`async fetch(query, pages=10, buffer=null)`**

        ##### Parameters

        - **query**: is a single [query object](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1 MB).
        - **pages**: how many pages of items should be returned.
        - **buffer**: the number of items which will be returned for each iteration (aka "page") on the return iterable. This is useful when your query is returning more than 1mb of data, so you could buffer the results in smaller chunks.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```js
        const {value: myFirstSet} = await db.fetch({"age?lt": 30}).next();
        const {value: mySecondSet} = await db.fetch([
          { "age?gt": 50 },
          { "hometown": "Greenville" }
        ]).next();
        ```

        ... will come back with following data:

        ###### `myFirstSet`:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `mySecondSet`:

        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```
        ##### Returns

        A promise which resolves to a generator of objects that meet the `query` criteria.

        The total number of items will not exceed the defined using `buffer` and `pages. Max. number of items

        Iterating through the generator yields arrays containing objects, each array of max length `buffer`.


        ##### Example using buffer, pages

        ```js
        const foo = async (myQuery, bar) => {

          items = db.fetch(myQuery, 10, 20) // items is up to the limit length (10*20)

          for await (const subArray of items) // each subArray is up to the buffer length, 20
            bar(subArray)
        }
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

  <Fragment slot="py">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`fetch(query=None, limit=1000, last=None):`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb or max 1000 items).
        - **limit**: the limit of the number of items you want to retreive, min value `1` if used
        - **last**: the last key seen in a previous paginated response

        > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
        >
        > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

        ##### Returns

        Returns an instance of a `FetchResponse` class which has the following properties.

        - `count` : The number of items in the response.

        - `last`: The last key seen in the fetch response. If `last` is not `None` further items are to be retreived

        - `items`: The list of items retreived.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```py
        first_fetch_res = db.fetch({"age?lt": 30})
        second_fetch_res = db.fetch([{"age?gt": 50}, {"hometown": "Greenville"}])
        ```

        ... will come back with following data:

        ###### `first_fetch_res.items`:
        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `second_fetch_res.items`:
        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```


        ##### Fetch All Items

        ```py
        res = db.fetch()
        all_items = res.items

        # fetch until last is 'None'
        while res.last:
          res = db.fetch(last=res.last)
          all_items += res.items
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`fetch(query=None, buffer=None, pages=10):`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb).
        - **pages**: how many pages of items should be returned.
        - **buffer**: the number of items which will be returned for each iteration (aka "page") on the return iterable. This is useful when your query is returning more 1mb of data, so you could buffer the results in smaller chunks.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```py
        my_first_set = next(db.fetch({"age?lt": 30}))
        my_second_set = next(db.fetch([{"age?gt": 50}, {"hometown": "Greenville"}]))
        ```

        ... will come back with following data:

        ###### `my_first_set`:
        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `my_second_set`:
        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Returns

        A generator of objects that meet the `query` criteria.

        The total number of items will not exceed the defined using `buffer` and `pages. Max. number of items

        Iterating through the generator yields lists containing objects, each list of max length `buffer`.


        ##### Example using buffer, pages

        ```py
        def foo(my_query, bar):
          items = db.fetch(my_query, pages=10, buffer=20) # items is up to the limit length (10*20)

          for sub_list in items: # each sub_list is up to the buffer length, 10
            bar(sub_list)
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Fetch(i *FetchInput) error`**

        ##### Parameters

        - **i**: is a pointer to a `FetchInput`

          ```go
          // FetchInput input to Fetch operation
          type FetchInput struct {
            // filters to apply to items
            // A nil value applies no queries and fetches all items
            Q Query
            // the destination to store the results
            Dest interface{}
            // the maximum number of items to fetch
            // value of 0 or less applies no limit
            Limit int
            // the last key evaluated in a paginated response
            // leave empty if not a subsequent fetch request
            LastKey string
          }
          ```
          - `Q`: fetch query, is of type `deta.Query` which is a `[]map[string]interface{}`
          - `Dest`: the results will be stored into the value pointed by `Dest`
          - `Limit`: the maximum number of items to fetch, value of `0` or less applies no limit
          - `LastKey`: the last key evaluated in a paginated response, leave empty if not a subsequent fetch request

        ##### Code Example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key string `json:"key"`
          Name string `json:"name"`
          Age int `json:"age"`
          Hometown string `json:"hometown"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // query to get users with age less than 30
          query := base.Query{
            {"age?lt": 50},
          }

          // variabe to store the results
          var results []*User

          // fetch items
          _, err = db.Fetch(&base.FetchInput{
            Q:    query,
            Dest: &results,
          })
          if err != nil {
            fmt.Println("failed to fetch items:", err)
          }
        }
        ```

        ... `results` will have the following data:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Paginated example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // query to get users with age less than 30
          query := base.Query{
            {"age?lt": 50},
          }

          // variabe to store the results
          var results []*User

          // variable to store the page
          var page []*User

          // fetch input
          i := &base.FetchInput{
            Q:     query,
            Dest:  &page,
            Limit: 1, // limit provided so each page will only have one item
          }

          // fetch items
          lastKey, err := db.Fetch(i)
          if err != nil {
            fmt.Println("failed to fetch items:", err)
            return
          }

          // append page items to results
          results = append(results, page...)

          // get all pages
          for lastKey != "" {
            // provide the last key in the fetch input
            i.LastKey = lastKey

            // fetch
            lastKey, err = db.Fetch(i)
            if err != nil {
              fmt.Println("failed to fetch items:", err)
              return
            }

            // append page items to all results
            results = append(results, page...)
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Fetch(i *FetchInput) error`**

        ##### Parameters

        - **i**: is a pointer to a `FetchInput`

          ```go
          // FetchInput input to Fetch operation
          type FetchInput struct {
            // filters to apply to items
            // A nil value applies no queries and fetches all items
            Q Query
            // the destination to store the results
            Dest interface{}
            // the maximum number of items to fetch
            // value of 0 or less applies no limit
            Limit int
            // the last key evaluated in a paginated response
            // leave empty if not a subsequent fetch request
            LastKey string
          }
          ```
          - `Q`: fetch query, is of type `deta.Query` which is a `[]map[string]interface{}`
          - `Dest`: the results will be stored into the value pointed by `Dest`
          - `Limit`: the maximum number of items to fetch, value of `0` or less applies no limit
          - `LastKey`: the last key evaluated in a paginated response, leave empty if not a subsequent fetch request

        ##### Code Example

        ```go
        import (
            "github.com/deta/deta-go"
        )

        type User struct {
            Key string `json:"key"`
            Name string `json:"name"`
            Age int `json:"age"`
            Hometown string `json:"hometown"`
        }

        func main(){
            // errors ignored for brevity
            d, _ := deta.New("project key")
            db, _ := deta.NewBase("users")

            // query to get users with age less than 30
            query := deta.Query{
              {"age?lt": 50},
            }

            // variabe to store the results
            var results []*User

            // fetch items
            _, err := db.Fetch(&deta.FetchInput{
              Q: query,
              Dest: &results,
            })
            if err != nil {
                fmt.Println("failed to fetch items:", err)
            }
        }
        ```

        ... `results` will have the following data:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Paginated example

        ```go
        import (
            "github.com/deta/deta-go"
        )

        type User struct {
            Key string `json:"key"`
            Name string `json:"name"`
            Age int `json:"age"`
            Hometown string `json:"hometown"`
        }

        func main(){
            // errors ignored for brevity
            d, _ := deta.New("project key")
            db, _ := deta.NewBase("users")

            // query to get users with age less than 30
            query := deta.Query{
              {"age?lt": 50},
            }

            // variabe to store the results
            var results []*User

            // variable to store the page
            var page []*User

            // fetch input
            i := &deta.FetchInput{
              Q: query,
              Dest: &page,
              Limit: 1, // limit provided so each page will only have one item
            }

            // fetch items
            lastKey, err := db.Fetch(i)
            if err != nil {
                fmt.Println("failed to fetch items:", err)
                return
            }

            // append page items to results
            results = append(allResults, page...)

            // get all pages
            for lastKey != ""{
              // provide the last key in the fetch input
              i.LastKey = lastKey

              // fetch
              lastKey, err := db.Fetch(i)
              if err != nil {
                  fmt.Println("failed to fetch items:", err)
                  return
              }

              // append page items to all results
              results = append(allResults, page...)
            }
        }
        ```
      </Fragment>

      ##### Returns

      Returns an `error`. Possible error values:

      - `ErrBadDestination`: bad destination, results could not be stored onto `dest`
      - `ErrBadRequest`: the fetch request caused a bad request response from the server
      - `ErrUnauthorized`: unauthorized
      - `ErrInternalServerError`: internal server error

    </LangVariantsTabs>
  </Fragment>

</LangTabs>

# queries.md

## Operators

Queries support the following operators:

### Equal

```json
{"age": 22, "name": "Beverly"}

// hierarchical
{"user.profile.age": 22, "user.profile.name": "Beverly"}
```

```json
{"fav_numbers": [2, 4, 8]}
```

```json
{"time": {"day": "Tuesday", "hour": "08:00"}}
```

### Not Equal

```json
{"user.profile.age?ne": 22}
```

### Less Than

```json
{"user.profile.age?lt": 22}
```

### Greater Than

```json
{"user.profile.age?gt": 22}
```

### Less Than or Equal

```json
{"user.profile.age?lte": 22}
```

### Greater Than or Equal

```json
{"user.profile.age?gte": 22}
```

### Prefix

```json
{"user.id?pfx": "afdk"}
```

### Range

```json
{"user.age?r": [22, 30]}
```

### Contains

```json
{
  // if user email contains the substring @deta.sh
  "user.email?contains": "@deta.sh"
}
```

```json
{
  // if berlin is in a list of places lived
  "user.places_lived_list?contains": "berlin"
}
```

### Not Contains

```json
{
  // if user email does not contain @deta.sh
  "user.email?not_contains": "@deta.sh" // 'user.email?!contains' also valid
}
```

```json
{
  // if berlin is not in a list of places lived
  "user.places_lived_list?not_contains": "berlin" // 'user.places_lived_list?!contains' also valid
}
```

> `?contains` and `?not_contains` only works for a list of strings if checking for membership in a list; it does not apply to list of other data types. You can store your lists always as a list of strings if you want to check for membership.

## Logical Operators

### AND

The entries in a single query object are `AND` ed together. For e.g. the query:

```json
{
    "active": true,
    "age?gte": 22
}
```

will retrieve items where `active` is `true` **and** `age` is greater than or equal to `22`.

The query above would translate to `SQL` as:

```sql
SELECT * FROM base WHERE active=1 AND age>=22;
```


### OR

Multiple query objects in a list are `OR` ed together. For eg. the queries:

```json
[{"age?lte": 30}, {"age?gte": 40}]
```

will retrieve items where `age` is less than equal to `30` **or** `age` is greater than equal to `40`.

The query above would translate to `SQL` as:

```sql
SELECT * FROM base WHERE age<=30 OR age>=40;
```


## Hierarchy

You can use the period character `.` to query for hierarchical fields within the data. For instance if you have the following item in the base:

```json
{
    "key": "user-key",
    "profile": {
        "age": 22,
        "active": true
    }
}
```

Then you can query for the `active` and `age` within `profile` directly:

```json
{
    "profile.age": 22,
    "profile.active": true
}
```

## Querying Keys

You need to consider the following when querying on keys:

- The keys must be strings hence the operation values **must** also be strings.
- The [contains](#contains) and [not-contains](#not-contains) operators **are not supported**.
- The [`AND`](#and) and [`OR`](#or) operations for different query values **are not supported**.
    For e.g. **the following queries are invalid**:
    ```json
    {
        // different AND key queries (invalid query)
        "key": "a",
        "key?pfx": "b"
    }
    ```

    ```json
    {
        // different OR key queries (invalid query)
        [{"key?pfx":"a"}, {"key?pfx": "b"}]
    }
    ```
# expiring_items.mdx

## Storing

Items specify the expiration timestamp value in a field name `__expires` in the item itself. The value is a [Unix time](https://en.wikipedia.org/wiki/Unix_time), a number.

For e.g.
```json
{
  "key": "item_key",
  "msg": "this will be deleted",
  "__expires": 1672531200
}
```

The item above will be deleted automatically on `2023-01-01 00:00:00 GMT` (the equivalent date of the timestamp above).

You can use the [Base SDK](./sdk.md) to [`put`](./sdk#put), [`put_many`](./sdk#put_many) or [`insert`](./sdk#insert) items with an expiration timestamp (or the [HTTP API](./HTTP.md) directly).

> ‚ö†Ô∏è Storing an item with an already expired timestamp will not fail but the item will be immediately deleted.

> ‚ÑπÔ∏è Base SDKs might offer higher level methods with easier APIs to specify the expiration timestamp. If they do so, they still store the timestamp in the item itself as mentioned above.

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    const Deta = require('deta');
    const db = Deta("project_key").Base('examples');

    const item = {'value': 'temp'};

    // expire in 300 seconds
    await db.put(item, 'temp_key', {expireIn:300})

    // expire at date
    await db.put(item, 'temp_key', {expireAt: new Date('2023-01-01T00:00:00')})
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    import datetime
    from deta import Deta

    db = Deta("project_key").Base("examples")

    item = {"key": "temp_key", "value": "temp"}

    # expire in 300 seconds
    db.put(item, expire_in=300)

    # expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put(item, expire_at=expire_at)
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    import (
      "log"
      "time"

      "github.com/deta/deta-go/deta"
      "github.com/deta/deta-go/service/base"
    )

    type TmpData struct {
      Key string `json: "key"`
      Value string `json:"value"`
      // json struct tag `__expires` for expiration timestamp
      // 'omitempty' to prevent default 0 value
      Expires int64 `json:"__expires,omitempty"`
    }

    func main() {
      // errors ignored for brevity
      d, _ := deta.New(deta.WithProjectKey("project_key"))
      db, _ := base.New(d, "examples")

      tmp := &TmpData{
        Key: "temp_key",
        Value: "temp",
        Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
      }
      _, err := db.Put(tmp)
      if err != nil {
        log.Fatal("failed to put item:", err)
      }
    }
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl -X PUT "https://database.deta.sh/v1/test_project_id/examples/items" \
        -H "Content-Type: application/json" \
        -H "X-Api-Key: test_project_key" \
        -d {"items":[{"key": "temp_key", "value": "temp", "__expires": 1672531200}]}
    ```
  </Fragment>

</LangTabsExtended>

## Retrieving

When you retrieve items with an expiration timestamp, the timestamp value will be present in the `__expires` field. The value is a [Unix time](https://en.wikipedia.org/wiki/Unix_time).

`Get` and `Query` operations will not retrieve already expired items.

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    const { __expires } = await db.get("temp_key");
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    expires = db.get("temp_key").get("__expires")
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    dest := struct{
      Key     string `json:"key"`
      Expires int64  `json:"__expires,omitempty"`
    }{}

    if err := db.Get("temp_key", &dest); err != nil {
      log.Fatal("failed to get item:", err)
    }

    expires := dest.Expires
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl "https://database.deta.sh/v1/test_project_id/examples/items/temp_key" \
        -H "X-Api-Key: test_project_key"

    {"key": "temp_key", "value": "temp", "__expires": 1672531200}
    ```
  </Fragment>

</LangTabsExtended>




## Updating

You can update the expiration timestamp with a new timestamp by updating the value of the `__expires` as long as the item has not already expired.

Updating other fields of the item **does not** update (or renew) the expiration timestamp. You **must** update the value of `__expires` field.

You can use the [Base SDK](./sdk.md) to [`update`](./sdk#update) the expiration timestamp (or the [HTTP API](./HTTP.md) directly).

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    // update item to expire in 300 seconds from now
    await db.update(null, "temp_key", {expireIn: 300})

    // update item to expire at date
    await db.update(null, "temp_key", {expireAt: new Date('2023-01-01T00:00:00')})
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    # update item to expire in 300 seconds from now
    db.update(None, "temp_key", expire_in=300)

    # update item to expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.update(None, "temp_key", expire_at=expire_at)
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    updates := base.Updates{
      "__expires": 1672531200,
    }
    if err := db.Update("temp_key", updates); err != nil {
      log.Fatal("failed to update item:", err)
    }
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl -X PATCH "https://database.data.sh/v1/test_project_id/examples/items/temp_key" \
        -H "Content-Type: application/json" \
        -H "X-Api-Key: test_project_key" \
        -d {"set": {"__expires": 1672531200}}
    ```
  </Fragment>

</LangTabsExtended>


# py_tutorial.md

## Building a Simple CRUD with Deta Base


### Setup

Two dependencies are needed for this project, `deta` and `flask`:

```shell
pip install deta flask
```


To configure the app, import the dependencies and instantiate your database.

```py
from flask import Flask, request, jsonify
from deta import Deta


deta = Deta('myProjectKey') # configure your Deta project
db = deta.Base('simpleDB')  # access your DB
app = Flask(__name__)
```


### Creating Records

For our database we are going to store records of users under a unique `key`. Users can have three properties:

```py
{
    "name": str,
    "age": int,
    "hometown": str
}

```


We'll expose a function that creates user records to HTTP `POST` requests on the route `/users`.


```py
@app.route('/users', methods=["POST"])
def create_user():
    name = request.json.get("name")
    age = request.json.get("age")
    hometown = request.json.get("hometown")

    user = db.put({
        "name": name,
        "age": age,
        "hometown": hometown
    })

    return jsonify(user, 201)
```

##### Request

`POST` a payload to the endpoint:

```json
{
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

##### Response

Our server should respond with a status of `201` and a body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Reading Records

To read records, we can simply use `db.get(key)`.

If we tie a `GET` request to the `/users` path with a param giving a user id (i.e. `/users/dl9e6w6859a9`), we can return a record of the user over HTTP.


```py
@app.route("/users/<key>")
def get_user(key):
    user = db.get(key)
    return user if user else jsonify({"error": "Not found"}, 404)
```

##### Request

Let's try reading the record we just created.

Make a `GET` to the path (for example) `/users/dl9e6w6859a9`.

##### Response

The server should return the same record:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Updating Records

To update records under a given `key`, we can use `db.put()`, which will replace the record under a given key.

We can tie a `PUT` request to the path `/users/{id}` to update a given user record over HTTP.


```py
@app.route("/users/<key>", methods=["PUT"])
def update_user(key):
    user = db.put(request.json, key)
    return user
```

##### Request

We can update the record by passing a `PUT` to the path `/users/dl9e6w6859a9` with the following payload:

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with the new body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```


### Deleting Records

To delete records under a given `key`, we can use `Base.delete(key)`, which will remove the record under a given key.

We can tie a `DELETE` request to the path `/users/{id}` to delete a given user record over HTTP.

```js
@app.route("/users/<key>", methods=["DELETE"])
def delete_user(key):
    db.delete(key)
    return jsonify({"status": "ok"}, 200)
```

##### Request

We can delete the record by passing a `DELETE` to the path `/users/dl9e6w6859a9`.

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with:

```json
None
```
# about.md

## What can Deta Base be used for?

Deta Base is great for projects where configuring and maintaining a database is overkill or when you want to store data as part of [building a Space app](/docs/en/basics/data).

Examples:

- Serverless Applications
- Internal Tools
- Stateful Integrations
- Hackathons and Side Projects
- Prototyping

## Getting started

- [Dealing with data in a Space App](/docs/en/basics/data)
- [Base UI](/docs/en/reference/base/base_ui)
- [Base SDK](/docs/en/reference/base/sdk)
- [Base HTTP API](/docs/en/reference/base/HTTP)
# base_ui.md

### Opening Base UI

You can open the Base UI of an app instance by opening an app's context menu and clicking "View Data"

<img src="/docs_assets/instance/context_menu.png" alt="drive_ui_1" width="200"/>

In the now open dialog navigate to the "Base" tab and all the data from your Base should load into the table view.

You can edit individual cells directly, if they do not contain an array or an object. Modified cells will turn yellow.

<img src="/docs_assets/base_ui/base_ui_2.png" alt="base_ui_2" width="500"/>


### Advanced Editing

You can expand any cell if you want to do advanced editing (like the editing of objects and arrays or type changes).

<img src="/docs_assets/base_ui/base_ui_3.png" alt="base_ui_3" width="500"/>

### Queries

If you don't want to deal with all of your data at once, you can use Deta Base's queries to get a filtered view. Click the **Query** button, enter your query, and hit enter or click **Fetch**.

<img src="/docs_assets/base_ui/base_ui_4.png" alt="base_ui_4" width="600"/>


### Adding Items

You can add new items by clicking **+ Add**.

<img src="/docs_assets/base_ui/base_ui_6.png" alt="base_ui_6" width="600"/>

New rows and edited rows will appear in yellow.

You can permanently save these modifications by clicking **Save edits**.

### Deleting Items

To delete items, click on the checkbox(es) for any item(s) and then click the **Delete** button.

<img src="/docs_assets/base_ui/base_ui_7.png" alt="base_ui_7" width="600"/>

### Undoing Changes

You can revert your local changes, restoring the BaseUI state to the last fetch by clicking the **Undo** button.

<img src="/docs_assets/base_ui/base_ui_8.png" alt="base_ui_8" width="300"/>

### Final Notes

We hope you enjoy Base UI!

Base UI is still in Beta; it has been internally tested but may have some uncaught bugs or issues.
# node_tutorial.mdx

## Building a Simple CRUD with Deta Base

### Setup

Two dependencies are needed for this project, `deta` and `express`:
```shell
npm install deta express
```

To configure the app, import the dependencies and instantiate your database.

```js
const express = require('express');
const { Deta } = require('deta');

const deta = Deta('myProjectKey'); // configure your Deta project
const db = deta.Base('simpleDB');  // access your DB


const app = express(); // instantiate express

app.use(express.json()) // for parsing application/json bodies
```



### Creating Records

For our database we are going to store records of users under a unique `key`. Users can have three properties:
```js
{
    "name": "string",
    "age": number,
    "hometown": "string"
}

```

We'll expose a function that creates user records to HTTP `POST` requests on the route `/users`.
```js
app.post('/users', async (req, res) => {
    const { name, age, hometown } = req.body;
    const toCreate = { name, age, hometown};
    const insertedUser = await db.put(toCreate); // put() will autogenerate a key for us
    res.status(201).json(insertedUser);
});
```



##### Request

`POST` a payload to the endpoint:
```json
{
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```



##### Response

Our server should respond with a status of `201` and a body of:
```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Reading Records

To read records, we can simply use `Base.get(key)`.

If we tie a `GET` request to the `/users` path with a path param giving a user id (i.e. `/users/dl9e6w6859a9`), we can return a record of the user over HTTP.

```js
app.get('/users/:id', async (req, res) => {
    const { id } = req.params;
    const user = await db.get(id);
    if (user) {
        res.json(user);
    } else {
        res.status(404).json({"message": "user not found"});
    }
});
```

Another option would to use `Base.fetch(query)` to search for records to return, like so:

<LangVariantsTabs>

  <Fragment slot="current">
    ```js
    app.get('/search-by-age/:age, async (req, res) => {
        const { age } = req.params;
        const { items } = await db.fetch({'age': age});
        return items;
    });
    ```
  </Fragment>

  <Fragment slot="legacy">
    ```js
    app.get('/search-by-age/:age, async (req, res) => {
        const { age } = req.params;
        return (await db.fetch({'age': age}).next()).value;
    });
    ```
  </Fragment>

</LangVariantsTabs>

##### Request

Let's try reading the record we just created.

Make a `GET` to the path `/users/dl9e6w6859a9`.

##### Response

The server should return the same record:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Updating Records

To update records under a given `key`, we can use `Base.put()`, which will replace the record under a given key.

We can tie a `PUT` request to the path `/users/{id}` to update a given user record over HTTP.

```js
app.put('/users/:id', async (req, res) => {
    const { id } = req.params;
    const { name, age, hometown } = req.body;
    const toPut = { key: id, name, age, hometown };
    const newItem = await db.put(toPut);
    return res.json(newItem)
});
```

##### Request

We can update the record by passing a `PUT` to the path `/users/dl9e6w6859a9` with the following payload:

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with the new body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```


### Deleting Records

To delete records under a given `key`, we can use `Base.delete(key)`, which will remove the record under a given key.

We can tie a `DELETE` request to the path `/users/{id}` to delete a given user record over HTTP.

```js
app.delete('/users/:id', async (req, res) => {
    const { id } = req.params;
    await db.delete(id);
    res.json({"message": "deleted"})
});
```

##### Request

We can delete the record by passing a `DELETE` to the path `/users/dl9e6w6859a9`.

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with:

```json
{
    "message": "deleted"
}
```
# HTTP.mdx

## General

> üí° You can get your **Project Key** and your **Project ID** of your project in [Builder](https://deta.space/builder). You need these to talk with the Deta Drive API.

### Root URL
This URL is the base for all your HTTP requests:

**`https://drive.deta.sh/v1/{project_id}/{drive_name}`**

> The `drive_name` is the name given to your drive. If you already have a **Drive**, then you can go ahead and provide it's name here. Additionally, you could provide any name here when doing any `PUT` or `POST` request and our backend will automatically create a new drive for you if it does not exist. There is no limit on how many "Drives" you can create.

### Auth
A **Project Key** _must_ be provided in the request **headers** as a value for the `X-Api-Key` key for authentication and authorization.

Example `X-Api-Key: a0kjsdfjda_thisIsYourSecretKey`

### File Names And Directories
Each file needs a unique `name` which identifies the file. Directorial hierarchies are represented logically by the `name` of the file itself with the use of backslash `/`.

For example, if you want to store a file `world.txt` under the directory `hello` , the `name` of the file should be `hello/world.txt`.

The file name **must not** end with a `/`. This also means that you can not create an empty directory.

A directory ceases to exist if there are no more files in it.
## Endpoints
### Put File
`POST /files?name={name}`

Stores a smaller file in a single request. Use this endpoint if the file size is small enough to be sent in a single request. The file is overwritten if the file with given `name` already exists.

> We do not accept payloads larger than 10 Mb on this endpoint. For larger uploads, use chunked uploads.

<RequestTabs>

<Fragment slot="request">

| Headers | Required | Description |
| --------|----------|-------------|
|`Content-Type` | No | The content type of the file. If the content type is not specified, the file `name` is used to figure out the content type. Defaults to `application/octet-stream` if the content type can not be figured out.|

|Query Params | Required | Description |
|-----|---|----|
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories).

</Fragment>
<Fragment slot="response">

##### `201 Created`

```js
Content-Type: application/json

{
    "name": "file name",
    "project_id": "deta project id",
    "drive_name": "deta drive_name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: "application/json"
{
    "errors": [
        // error messages
    ]
}
```

`413 Payload Too Large`

```html
Content-Type: text/html
<h1> 413 - Request Entity Too Large </h1>
```

</Fragment>
</RequestTabs>

### Initialize Chunked Upload

Initializes a chunked file upload. If the file is larger than 10 MB, use this endpoint to initialize a chunked file upload.

`POST /uploads?name={name}`

<RequestTabs>

<Fragment slot="request">

|Params | Required | Description |
|-----|---|----|
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories).

</Fragment>
<Fragment slot="response">

##### `202 Accepted`

```js
Content-Type: application/json

{
    "name": "file name",
    "upload_id": "a unique upload id"
    "project_id": "deta project id",
    "drive_name": "deta drive name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```
</Fragment>
</RequestTabs>

### Upload Chunked Part

Uploads a chunked part.

`POST /uploads/{upload_id}/parts?name={name}&part={part}`

> Each chunk must be at least 5 Mb and at most 10 Mb. The final chunk can be less than 5 Mb.

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
|----|---|---|
|`upload_id`| Yes | The `upload_id` received after [initiating a chunked upload](#initialize-chunked-upload) |
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories). |
|`part`| Yes | The chunk part number, start with `1` |



</Fragment>
<Fragment slot="response">

##### `200 Ok`

```js
Content-Type: application/json

{
    "name": "file name",
    "upload_id": "a unique upload id"
    "part": 1, // upload part number
    "project_id": "deta project id",
    "drive_name": "deta drive name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`413 Payload Too Large`

```html
Content-Type: text/html
<h1> 413 Request Entity Too Large </h1>
```
</Fragment>
</RequestTabs>

### End Chunked Upload

End a chunked upload.

`PATCH /uploads/{upload_id}?name={name}`

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
|----|---|---|
|`upload_id`| Yes | The `upload_id` received after [initiating a chunked upload](#initialize-chunked-upload) |
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories). |


</Fragment>
<Fragment slot="response">

##### `200 Ok`

```js
Content-Type: application/json

{
    "name": "file name",
    "upload_id": "a unique upload id"
    "project_id": "deta project id",
    "drive_name": "deta drive name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```
</Fragment>
</RequestTabs>

### Abort Chunked Upload

Aboart a chunked upload.

`DELETE /uploads/{upload_id}?name={name}`

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
|----|---|---|
|`upload_id`| Yes | The `upload_id` received after [initiating a chunked upload](#initialize-chunked-upload) |
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories). |


</Fragment>
<Fragment slot="response">

##### `200 Ok`

```js
Content-Type: application/json

{
    "name": "file name",
    "upload_id": "a unique upload id"
    "project_id": "deta project id",
    "drive_name": "deta drive name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```
</Fragment>
</RequestTabs>

### Download File

Download a file from drive.

` GET /files/download?name={name}`

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
|----|---|---|
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories). |


</Fragment>
<Fragment slot="response">

##### `200 Ok`

```
Accept-Ranges: bytes
Content-Type: {content_type}
Content-Length: {content_length}
{Body}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```
</Fragment>
</RequestTabs>

### List Files

List file names from drive.

`GET /files?limit={limit}&prefix={prefix}&last={last}`

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
|----|---|---|
|`limit`| No | The `limit` of number of file names to get, defaults to `1000`|
|`prefix`| No | The `prefix` that each file name must have. |
|`last` | No | The `last` file name seen in a paginated response. |


</Fragment>
<Fragment slot="response">

##### `200 Ok`

The response is paginated based on the `limit` provided in the request. By default, maximum `1000` file names are sent.

If the response is paginated, the response contains a `paging` object with `size` and `last` keys; `size` is the number of file
names in the response, and `last` is the last file name seen in the response. The value of `last` should be used in subsequent
requests to continue recieving further pages.

```js
Content-Type: application/json

{
    "paging": {
        "size": 1000, // the number of file names in the response
        "last": "last file name in response"
    },
    "names": ["file1", "file2", ...]
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

</Fragment>
</RequestTabs>

### Delete Files

Delete files from drive.

`DELETE /files`

<RequestTabs>

<Fragment slot="request">

```js
Content-Type: "application/json"
{
    "names": ["file_1", "file_2"]
}
```

| Params | Required | Description |
|----|---|---|
|`names`| Yes | The `names` of the files to delete, maximum `1000` file names|

</Fragment>
<Fragment slot="response">

##### `200 Ok`


```js
Content-Type: application/json

{
    "deleted": ["file_1", "file_2", ...] // deleted file names
    "failed": {
        "file_3": "reason why file could not be deleted",
        "file_4": "reason why file could not be deleted",
        //...
    }
}
```

> File names that did not exist will also be under `deleted`, `failed` will only contain names of files that existed but were not deleted for some reason

</Fragment>
</RequestTabs>
# sdk.mdx

## Installing

<br />
<LangTabs>
  <Fragment slot="js">
  Using NPM:

    ```shell
    npm install deta
    ```

    Using Yarn:
    ```shell
    yarn add deta
    ```

  </Fragment>
  <Fragment slot="py">
  ```shell
	pip install deta
	```
  </Fragment>
  <Fragment slot="go">
  ```shell
	go get github.com/deta/deta-go
	```
  </Fragment>
</LangTabs>

## Instantiating

To start working with your Drive, you need to import the `Deta` class and initialize it with a **Project Key**. Then instantiate a subclass called `Drive` with a database name of your choosing.

<br />

<LangTabs>
  <Fragment slot="js">
	```js
	const { Deta } = require('deta'); // import Deta

    // this also works
    import { Deta } from 'deta';

    // Initialize with a Project Key
    const deta = Deta('project key');

    // You can create as many as you want
    const photos = deta.Drive('photos');
    const docs = deta.Drive('docs');
    ```

    If you are using Deta Drive within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your `package.json` file to install the latest sdk version.

    A valid project key is pre-set in the Micro's environment. There is no need to pass a key in the initialization step.

    ```js
    const { Drive } = require('deta');
    const drive = Drive('simple_drive');
    ```

    If you are using the `deta` npm package of `0.0.6` or below, `Deta` is the single default export and should be imported as such.

    ```js
    const Deta = require('deta');
    ```

  </Fragment>
  <Fragment slot="py">
  	```py
	from deta import Deta  # Import Deta

    # Initialize with a Project Key
    deta = Deta("project key")

    # This how to connect to or create a database.
    drive = deta.Drive("simple_drive")

    # You can create as many as you want
    photos = deta.Drive("photos")
    docs = deta.Drive("docs")

    ```

    If you are using Deta Drive within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your `requirements.txt` file to install the latest sdk version.

    A valid project key is pre-set in the Micro's environment. There is no need to pass a key in the the initialization step.

    ```py
    from deta import Drive

    drive = Drive("simple_drive")
    ```

  </Fragment>
  <Fragment slot="go">
  	```go
	import (
		"fmt"

    	"github.com/deta/deta-go/deta"
    	"github.com/deta/deta-go/service/drive"
    )

    func main() {

    	// initialize with project key
    	// returns ErrBadProjectKey if project key is invalid
    	d, err := deta.New(deta.WithProjectKey("project_key"))
    	if err != nil {
    		fmt.Println("failed to init new Deta instance:", err)
    		return
    	}

    	// initialize with drive name
    	// returns ErrBadDriveName if base name is invalid
    	drive, err := drive.New(d, "drive_name")
    	if err != nil {
    		fmt.Println("failed to init new Drive instance:", err)
    		return
    	}
    }
    ```

  </Fragment>
</LangTabs>

> ‚ö†Ô∏è Your project key is confidential and meant to be used by you. Anyone who has your project key can access your database. Please, do not share it or commit it in your code.

## Using

Deta's **`Drive`** offers the following methods to interact with your Deta Drive:

[**`put`**](#put) - Stores a file to drive. It will overwrite the file if the file already exists.

[**`get`**](#get) - Retrieves a file from drive by the file name.

[**`delete`**](#delete) - Deletes a file from drive.

[**`list`**](#list) - Lists the file names in a drive.

### Put

`Put` uploads and stores a file in a drive with a given `name`. It will overwrite the file if the file name already exists.

<LangTabs>
  <Fragment slot="js">

**`async put(name, options)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file.
- **options** (required) - `{data : string | Uint8Array | Buffer, path: string, contentType: string}`

  - Description: An object with three optional parameters.
    - **data** - `string` or `Buffer`
      - Description: Either the data string or a buffer.
    - **path** - `string`
      - Description: The path of the file to be uploaded to drive.
    - **contentType** - `string`
      - Description: The content type of the file to be uploaded to drive. If the content type is not provided, `drive` tries to figure out the content type from the `name` provided. It defaults to `application/octet-stream` if the content type can not be figured out from the file name.

  `options` must have at least and at most one of two properties `data` or `path` defined.

##### Returns

Returns a promise which resolves to the name of the item on a successful `put`, otherwise, it throws an `Error` on error.

##### Example

```js
drive.put('hello.txt', {data: "Hello world"});
drive.put('hello.txt', {data: "Hello world", contentType: 'text/plain'});

drive.put('hello.txt', {data: Buffer.from('Hello World'), contentType: 'text/plain'});
drive.put('hello.txt', {path: './my/file/path/file.txt'});
drive.put('hello.txt', {path: './my/file/path/file.txt', contentType: 'text/plain'}});
```

  </Fragment>
  <Fragment slot="py">
  **`put(name, data, *, path, content_type)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file.
- **data** - `string | bytes | io.TextIOBase | io.BufferedIOBase | io.RawIOBase`
  - Description: The data content of the file.
- **path** - `string`
  - Description: The local path of the file to be uploaded to drive.
- **content_type** - `string`

  - Description: The content type of the file to be uploaded to drive. If the content type is not provided, `drive` tries to figure out the content type from the `name` provided. It defaults to `application/octet-stream` if the content type can not be figured out from the file name.

  At least and at most one of two args `data` or `path` must be provided. `path` and `content_type` must be provided with the key words.

##### Returns

Returns the name of the file on a successful `put`, otherwise, raises an `Exception` on error.

##### Example

```py
drive.put('hello.txt', 'Hello world')
drive.put(b'hello.txt', 'Hello world')
drive.put('hello.txt', content_type='text/plain')

import io
drive.put('hello.txt', io.StringIO('hello world'))
drive.put('hello.txt', io.BytesIO(b'hello world'))

f = open('./hello.txt', 'r')
drive.put('hello.txt', f)
f.close()

drive.put('hello.txt', path='./hello.txt')
```

  </Fragment>
  <Fragment slot="go">
  **`Put(i *PutInput) (string, error)`**

##### Parameters

- **i** (required) - pointer to a `PutInput`
  - ```go
    // PutInput input to Put operation
    type PutInput struct {
      // Name of the file
      Name string
      // io.Reader with contents of the file
      Body io.Reader
      // ContentType of the file to be uploaded to drive.
      ContentType string
    }
    ```
  - `Name` (required) - `string`
    - Description: Name of the file to be uploaded.
  - `Body` (required) - `io.Reader`
    - Description: File content to be uploaded.
  - `ContentType` - `string`
    - Description: If the content type is not provided, drive tries to figure out the content type from Name provided. It defaults to application/octet-stream if the content type can not be figured out from the file name.

##### Returns

Returns the `name` of the file on a successful put (otherwise empty name), and an `error`.

##### Example

```go
import (
	"bufio"
	"fmt"
	"os"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}
	// PUT
	// reading from a local file
	file, err := os.Open("./art.svg")
	defer file.Close()

	name, err := drawings.Put(&drive.PutInput{
		Name:        "art.svg",
		Body:        bufio.NewReader(file),
		ContentType: "image/svg+xml",
	})
	if err != nil {
		fmt.Println("failed to put file:", err)
		return
	}
	fmt.Println("Successfully put file with name:", name)
}
```

  </Fragment>
</LangTabs>

### Get

`Get` retrieves a file from a drive by its name.

<LangTabs>
  <Fragment slot="js">

**`async get(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a promise that resolves to a `blob` of data if found, else `null`.
Throws an `Error` on errors.

##### Example

```js
const buf = await drive.get("hello.txt");
```

</Fragment>

<Fragment slot="py">

**`get(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a instance of a `DriveStreamingBody` class which has the following methods/properties.

- `read(size=None)` : Reads all or up to the next `size` bytes. Calling `read` after all the content has been read will return empty bytes.

- `iter_chunks(chunk_size:int=1024)` : Returns an iterator that yields chunks of bytes of `chunk_size` at a time.

- `iter_lines(chunk_size:int=1024)` : Returns an iterator that yields lines from the stream. Bytes of `chunk_size` at a time is read from the raw stream and lines are yielded from there. The line delimiter is always `b'\n'`.

- `close()` : Closes the stream.

- `closed` : Returns `True` if the stream has been closed.

##### Example

```py
hello = drive.get('hello.txt')
content = hello.read()
hello.close()

# larger files
# iterate chunks of size 4096 and save to disk
large_file = drive.get('large_file.txt')
with open("large_file.txt", "wb+") as f:
  for chunk in large_file.iter_chunks(4096):
      f.write(chunk)
  large_file.close()
```

</Fragment>

<Fragment slot="go">

**`Get(name string) (io.ReadCloser, error)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a `io.ReadCloser` for the file.

##### Example

```go
import (
	"fmt"
	"io/ioutil"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	// GET
	name := "art.svg"
	f, err := drawings.Get(name)
	if err != nil {
		fmt.Println("failed to get file with name:", name)
		return
	}
	defer f.Close()

	c, err := ioutil.ReadAll(f)
	if err != nil {
		fmt.Println("failed read file content with err:", err)
		return
	}
	fmt.Println("file content:", string(c))
}
```

</Fragment>

</LangTabs>

### Delete

`Delete` deletes a file from drive.

<LangTabs>
<Fragment slot="js">

**`async delete(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns a promise that resolves to the `name` of the deleted file on successful deletions, otherwise raises an `Error`

> If the file did not exist, the file is still returned as deleted.

##### Example

```js
const deletedFile = await drive.delete("hello.txt");
```

</Fragment>

<Fragment slot="py">

**`delete(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns the `name` of the deleted file on successful deletions, otherwise raises an `Exception`

> If the file did not exist, the file is still returned as deleted.

##### Example

```py
deleted_file = drive.delete("hello.txt")
```

</Fragment>
<Fragment slot="go">

**`Delete(name string) (string, error)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns the `name` of the deleted file on successful deletions, and an `error`.

> If the file did not exist, the name is still returned.

##### Example

```go
import (
	"fmt"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	// DELETE
	name, err := drawings.Delete("art.svg")
	if err != nil {
		fmt.Println("failed to delete file with name:", name)
		return
	}
	fmt.Println("Successfully deleted file with name:", name)
}
```

</Fragment>
</LangTabs>

### Delete Many

Deletes multiple files (up to 1000) from a drive.

<LangTabs>

<Fragment slot="js">

**`async deleteMany(names)`**

##### Parameters

- **names** (required) - `Array of string`
  - description: The names of the files to be deleted.

##### Returns

Returns a promise which resolves to an object with `deleted` and `failed` keys indicating deleted and failed file names.

```js
{
  deleted : ["file1.txt", "file2.txt", ...],
  failed: {
    "file_3.txt": "reason for failure",
  }
}
```

> If a file did not exist, the file is still returned as deleted.

##### Example

```js
const result = await drive.DeleteMany(["file1.txt", "file2.txt"]);
console.log("deleted:", result.deleted);
console.log("failed:", result.failed);
```

</Fragment>

<Fragment slot="py">

**`delete_many(names)`**

##### Parameters

- **names** (required): `string`
  - Description: The names of the files to be deleted.

##### Returns

Returns a `dict` with `deleted` and `failed` keys indicating deleted and failed file names.

```py
{
  "deleted" : ["file1.txt", "file2.txt", ...],
  "failed": {
    "file_3.txt": "reason for failure"
  }
}
```

> If a file did not exist, the file is still returned as deleted.

##### Example

```py
result = drive.delete_many(["file1.txt", "file2.txt"]);
print("deleted:", result.get("deleted"))
print("failed:", result.get("failed"))
```

</Fragment>
	<Fragment slot="go">

	**`DeleteMany(names []string) (*DeleteManyOutput, error)`**

	##### Parameters

	- **names** (required): `[]string`
	- Description: The names of the files to be deleted.

	##### Returns

	Returns a pointer to a `DeleteManyOutput` and an `error`.

	```go
	// DeleteManyOutput output to DeleteMany operation
	type DeleteManyOutput struct {
		Deleted []string          `json:"deleted"`
		Failed  map[string]string `json:"failed"`
	}
	```

	- `Deleted` - string slice indicating deleted file names.
	- `Failled` - map indicating the names of failed file names along with an error message.

	##### Example

	```go
	import (
		"fmt"

		"github.com/deta/deta-go/deta"
		"github.com/deta/deta-go/service/drive"
	)

	func main() {
		// initialize with project key
		// returns ErrBadProjectKey if project key is invalid
		d, err := deta.New(deta.WithProjectKey("project_key"))
		if err != nil {
			fmt.Println("failed to init new Deta instance:", err)
			return
		}

		// initialize with drive name
		// returns ErrBadDriveName if drive name is invalid
		drawings, err := drive.New(d, "drawings")
		if err != nil {
			fmt.Println("failed to init new Drive instance:", err)
			return
		}

		names := []string{"a", "b", "c"}
		dr, err := drawings.DeleteMany(names)

		if err != nil {
			fmt.Println("failed to delete files")
			return
		}
		fmt.Println("deleted:", dr.Deleted)
		fmt.Println("failed:", dr.Failed)
	}
	```

	</Fragment>
</LangTabs>

### List

`List` files in your drive.

<LangTabs>

<Fragment slot="js">

**`async list(options)`**

##### Parameters

- **options** (required) : `{prefix: string, limit: number, last: string}`
  - Description: An object with three optional parameters.
    - **prefix**: `string`
      - Description: The prefix that file names must have.
    - **limit**: `number`
      - Description: The maximum number of files names to be returned, defaults to `1000`
    - **last**: `string`
      - Description: The `last` name seen in a previous paginated result. Provide `last` to fetch further pages.

##### Returns

Returns a promise which resolves to an `object` with `paging` and `names` keys.

```js
{
  names: ["file1.txt", "file2.txt", ...],
  paging: {
    size: 2,
    last: "file_2.txt"
  }
}
```

- `names`: The names of the files
- `paging`: Contains paging information.
  - `size` : The number of files returned.
  - `last` : The last name seen in the paginated response. Provide this value in subsequent api calls to fetch further pages. For the last page, `last` is not present in the response.

##### Example

```js
// get all files
let result = await drive.list();
let allFiles = result.names;
let last = result.paging.last;

while (last) {
  // provide last from previous call
  result = await drive.list({ last: result.paging.last });

  allFiles = allFiles.concat(result.names);

  // update last
  last = result.paging.last;
}
console.log("all files:", allFiles);

const resultWithPrefix = await drive.list({ prefix: "blog/" });
const resultWithLimit = await drive.list({ limit: 100 });
const resultWIthLimitAndPrefix = await drive.list({
  limit: 100,
  prefix: "blog/",
});
```

</Fragment>

<Fragment slot="py">

**`list(limit, prefix, last)`**

##### Parameters

- **limit**: `int`
  - Description: The maximum number of files names to be returned, defaults to `1000`
- **prefix**: `string`
  - Description: The prefix that file names must have.
- **last**: `string`
  - Description: The `last` name seen in a previous paginated result. Provide `last` from previous response to fetch further pages.

##### Returns

Returns a `dict` with `paging` and `names` keys.

```py
{
  "names": ["file1.txt", "file2.txt", ...],
  "paging": {
    "size": 2,
    "last": "file_2.txt"
  }
}
```

- `names`: The names of the files
- `paging`: Contains paging information.
  - `size` : The number of files returned.
  - `last` : The last name seen in the paginated response. Provide this value in subsequent api calls to fetch further pages. For the last page, `last` is not present in the response.

##### Example

```py
# get all files
result = drive.list()

all_files = result.get("names")
paging = result.get("paging")
last = paging.get("last") if paging else None

while (last):
  # provide last from previous call
  result = drive.list(last=last)

  all_files += result.get("names")
  # update last
  paging = result.get("paging")
  last = paging.get("last") if paging else None

print("all files:", all_files)

res_with_prefix = drive.list(prefix="/blog")
res_with_limit = drive.list(limit=100)
res_with_prefix_limit = drive.list(prefix="/blog", limit=100)
```

</Fragment>

<Fragment slot="go">

**`List(limit int, prefix, last string) (*ListOutput, error)`**

##### Parameters

- **limit** (required) - `int`
  - Description: Maximum number of file names to be returned.
- **prefix** (required) - `string`
  - Description: The prefix that file names must have.
- **last** (required) - `string`
  - Description: The `last` name seen in a previous paginated result. Provide `last` from previous response to fetch further pages.

##### Returns

Returns a pointer to a `ListOutput`

```go
type ListOutput struct {
	Paging *paging  `json:"paging"`
	Names  []string `json:"names"`
}

type paging struct {
	Size int     `json:"size"`
	Last *string `json:"last"`
}
```

- `Paging` - indicates the size and last name of the current page. `nil` if there are no further pages.
- `Names` - names of the files.

##### Example

```go
import (
	"fmt"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	lr, err := drawings.List(1000, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// ["a", "b", "c/d"]
	fmt.Println("names:", lr.Names)

	lr, err = drawings.List(1, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// ["a"]
	fmt.Println("names:", lr.Names)


	lr, err = drawings.List(2, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// "b"
	fmt.Println("last:", *lr.Paging.Last)
}
```

</Fragment>
</LangTabs>
# drive_ui.md

### Opening Drive UI

You can open the Drive UI of an app instance by opening an app's context menu and clicking "View Data".

<img src="/docs_assets/instance/context_menu.png" alt="drive_ui_1" width="200"/>

In the now open dialog navigate to the "Drive" tab and all the files and folders from within the path `/` should load into the table view.


### Preview and Navigation

Files that are previewable (and folders) are marked in blue.

<img src="/docs_assets/drive_ui/drive_ui_2.png" alt="drive_ui_2" width="600"/>


Clicking a folder will navigate to that folder, while clicking a file will open up a preview.

<img src="/docs_assets/drive_ui/drive_ui_3.png" alt="drive_ui_3" width="600"/>

<p />

Your current location is highlighted in black in the navigation bar at the top of Drive UI.

<img src="/docs_assets/drive_ui/drive_ui_4.png" alt="drive_ui_4" width="600"/>

You can click a parent folder, or the Drive name, to jump to that location.

### Uploading & Downloading Files

You can upload a file by dragging it into the list of files & folders. This will upload the file in the current directory.

<img src="/docs_assets/drive_ui/drive_ui_5.png" alt="drive_ui_5" width="600"/>

To download a file, click the download icon, which is on the right side of the the table.

### Deleting Files

To delete files, click on the checkbox(es) for any files(s) and then click the trash icon in the top right corner of the Drive UI panel.

<img src="/docs_assets/drive_ui/drive_ui_6.png" alt="drive_ui_6" width="600"/>

You will be asked to confirm you want to delete the file(s).


### Final Notes

We hope you enjoy Drive UI!

Drive UI is still in Beta; it has been internally tested but may have some uncaught bugs or issues.
# py_tutorial.md

## Building a Simple Image Server with Deta Drive

### Setup
To get started, create a directory `image-server` and change the current directory into it.
```shell
$ mkdir image-server && cd image-server
```
Before we begin, let's install all the necessary dependencies for this project. Create a `requirements.txt` with the following lines:
```json
fastapi
uvicorn
deta
python-multipart
```

> If you are using Deta Drive within a Deta Micro, you should ignore `uvicorn`, but you must include `deta` in your `requirements.txt` file to install the lastest sdk version, other than that it won't work.

We are using `FastAPI` to build our simple image server, and `python-multipart` allows us access the uploaded files.

Run the following command to install the dependencies.
```shell
$ pip install -r requirements.txt
```

To configure the app, import the dependencies and instantiate drive in `main.py`

```python
from fastapi import FastAPI, File, UploadFile
from fastapi.responses import HTMLResponse, StreamingResponse
from deta import Deta

app = FastAPI()
deta = Deta("Project_Key")  # configure your Deta project
drive = deta.Drive("images") # access to your drive
```

We have everything we need to üöÄ

### Uploading Images
First, we need to render a HTML snippet to display the file upload interface.

We'll expose a function that renders the HTML snippet on the base route `/`
```python
@app.get("/", response_class=HTMLResponse)
def render():
    return """
    <form action="/upload" enctype="multipart/form-data" method="post">
        <input name="file" type="file">
        <input type="submit">
    </form>
    """
```

We are simply rendering a form that sends a HTTP `POST` request to the route `/upload` with file data.

Let's complete file upload by creating a function to handle `/upload`

```python
@app.post("/upload")
def upload_img(file: UploadFile = File(...)):
    name = file.filename
    f = file.file
    res = drive.put(name, f)
    return res
```

Thanks to the amazing tools from FastAPI, we can simply wrap the input around `UploadFile` and `File` to access the image data. We can retrieve the name as well as bytes from `file` and store it in Drive.

### Downloading images
To download images, we can simply use `drive.get(name)`

If we tie a `GET` request to the `/download` path with a param giving a name (i.e `/download/space.png`), we can return the image over HTTP.
```python
@app.get("/download/{name}")
def download_img(name: str):
    res = drive.get(name)
    return StreamingResponse(res.iter_chunks(1024), media_type="image/png")
```

You can learn more about `StreamingResponse` [here](https://fastapi.tiangolo.com/advanced/custom-response/#streamingresponse).

### Running the server
To run the server locally, navigate to the terminal in the project directory (`image-server`) and run the following command:
```shell
$ uvicorn main:app
```

Your image server is now ready! You can interact with it at `/` and check it out!

<img src="/docs_assets/img/drive/drive-py-tut.png" alt="/"/>
<img src="/docs_assets/img/drive/drive-py-tut-1.png" alt="/download/tut.jpg"/>


```shell

curl -X 'POST' \
  'http://127.0.0.1:8000/upload' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'file=@space.png;type=image/png'

Response
"space.png"


curl -X 'GET' \
  'http://127.0.0.1:8000/download/space.png' \
  -H 'accept: application/json'

Response
The server should respond with the image.
```
# node_tutorial.md

## Building a Simple Image Server with Deta Drive

### Setup

To get started, create a directory `image-server` and change the current directory into it.
```shell
$ mkdir image-server && cd image-server
```
Before we begin, let's install all the necessary dependencies for this project.

```shell
$ npm install deta express express-fileupload
```
In this tutorial, we are using `express` to build our server, and `express-fileupload` allows us to access the uploaded file data.

To configure the app, import the dependencies and instantiate drive in `index.js`

```js
const { Deta } = require("deta");
const express = require("express");
const upload = require("express-fileupload");

const app = express();

app.use(upload());

const deta = Deta("Project_Key");
const drive = deta.Drive("images");
```


We have everything we need to üöÄ

### Uploading Images
First, we need to render a HTML snippet to display the file upload interface.

We'll expose a function that renders the HTML snippet on the base route `/`
```javascript
app.get('/', (req, res) => {
    res.send(`
    <form action="/upload" enctype="multipart/form-data" method="post">
      <input type="file" name="file">
      <input type="submit" value="Upload">
    </form>`);
});
```

We are simply rendering a HTML form that sends a HTTP `POST` request to the route `/upload` with file data.

Let's complete file upload by creating a function to handle `/upload`

```javascript
app.post("/upload", async (req, res) => {
    const name = req.files.file.name;
    const contents = req.files.file.data;
    const img = await drive.put(name, {data: contents});
    res.send(img);
});
```
We can access the image details from `req` and store it in Drive.

### Downloading Images
To download images, we can simply use `drive.get(name)`

If we tie a `GET` request to the `/download` path with a param giving a name (i.e `/download/space.png`), we can return the image over HTTP.

```javascript
app.get("/download/:name", async (req, res) => {
    const name = req.params.name;
    const img = await drive.get(name);
    const buffer = await img.arrayBuffer();
    res.send(Buffer.from(buffer));
});

app.listen(3000);
```

### Running the server
To run the server locally, navigate to the terminal in the project directory (`image-server`) and run the following command:
```shell
$ node index.js
```

<img src="/docs_assets/img/drive/drive-py-tut.png" alt="/"/>
<img src="/docs_assets/img/drive/drive-py-tut-1.png" alt="/download/tut.jpg"/>


```shell
curl -X 'POST' \
  'http://127.0.0.1:3000/upload' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'file=@space.png;type=image/png'

Response
"space.png"

curl -X 'GET' \
  'http://127.0.0.1:3000/download/space.png' \
  -H 'accept: application/json'

Response
The server should respond with the image.
```
# about.md

## What can Deta Drive be used for?

Deta Drive is great for projects where you need to store files or when you want to store files as part of [building a Space app](/docs/en/basics/data).

## Getting started

- [Dealing with data in a Space App](/docs/en/basics/data)
- [Drive UI](/docs/en/reference/drive/base_ui)
- [Drive SDK](/docs/en/reference/drive/sdk)
- [Drive HTTP API](/docs/en/reference/drive/HTTP)
# personal-cloud.md

## What is the personal cloud?

The ‚Äòpersonal cloud‚Äô is pretty simple conceptually. It is just a departure from the common model of web application development on 'public cloud'.

### The public cloud

In a public cloud application, end users of an app by-and-large share infrastructure resources: servers, databases, file stores, etc. These resources are controlled by (and operated by) the providers of the web application, and accessed by end users when they login to the app.

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/public_cloud.png" width="500px" />
<div style="max-width: 100%; white-space: pre-wrap; word-break: break-word; caret-color: rgb(55, 53, 47); font-size: 14px; line-height: 1.4; color: rgba(55, 53, 47, 0.65); padding-top: 6px; padding-bottom: 6px; padding-left: 2px;" data-content-editable-leaf="true" contenteditable="false">Public cloud application architecture</div>
</div>

In this model, if the provider of the app shuts down this infrastructure, the user loses access. Meanwhile, the user can't directly delete their trace data, as it is in the provider's hands.

### The personal cloud

The personal cloud is a return to the personal computer model of applications, but in the cloud. Instead of one giant shared pool of resources for all users, *each user gets their own complete and sandboxed cloud application instance, consisting of the resources needed to power their app.*

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/personal_cloud.png" width="500px" />
<div style="max-width: 100%; white-space: pre-wrap; word-break: break-word; caret-color: rgb(55, 53, 47); font-size: 14px; line-height: 1.4; color: rgba(55, 53, 47, 0.65); padding-top: 6px; padding-bottom: 6px; padding-left: 2px;" data-content-editable-leaf="true" contenteditable="false">Personal cloud application architecture</div>
</div>

In this case, the users control the infrastructure which runs the app.  We think this shift solves a number of hairy problems for developers and users.

## 0 Infrastructure, ‚àû Scale

Due to the personal cloud architecture, each user owns their own infra. What this means for you as a developer, *is that you have effectively 0 infrastructure burden, no matter how many users your app scales to.* No servers or DBs to manage, secure, or maintain. All you need to do is build your application logic.

## Distribution

We've discovered two routes in which we think the personal cloud model improves application distribution today:


1. When a developer has built an application, but wants nothing to do with building auth layer or managing any infrastructure. These applications are really cool demo apps, or even use something like local storage for data persistence, but they aren't reaching their full potential for end users. We think these apps find a happy channel to end users on a personal cloud.
2. Where users really need to their own copy of an app for whatever reason. As it stands now, self hosting applications fill this niche, but it‚Äôs a niche: it requires a lot of time consuming expertise on the part of end users. With the personal cloud, we think many of the benefits of self-hosting are made accessible, which loops back to benefit app developers‚Äô distribution possibilities.

## Turn-key payments (planned for Space)

Developers have told us two things about taking their app to the next level:

1. They'd like to add some type of paywall & earn money once they start bringing external users onboard
2. Payments work ‚Äî in and of itself ‚Äî is fuss-y, infra like work. App devs would rather not do it.

So we thought about it, and wondered:
- Why should multiple app developers all have to implement a similar payment system into their app?
- Why should application users have to give billing information to every app they want to buy?

We think we can solve these problems with Deta Space, removing the payments work, just like we do for the other infra work. As a developer, we'd like you to have 'turn key' payments. Ideally you turn on a pricing knob, select a pricing model, provide your payment information and Deta will send you money every month.

## Control & interoperability (planned for Space)

On the personal cloud, we think control of the app and data is the biggest draw for end-users. This helps ensure that apps keep working if an app's developer decides to call it quits, while also providing privacy advantages.

For *users who are also developers*, we think control is a huge win, for an additional reason. This is because developers are fundamentally hackers and tinkerers who turn ideas into software, and personal computing fundamentally empowers them to do this. With personal control over apps and data, developers can hack and tinker their apps and data into more apps and data. We think this will allow developers to discover new frontiers in their own computational lives, paving the way for everyone else.

Build your first app on the personal cloud with Deta Space [here](/docs/en/introduction/first-app).
# first-app.mdx

## Prerequisites

The first thing to do is to create a Deta account if you haven‚Äôt already. You can [signup](https://deta.space/signup) in seconds, it‚Äôs completely free!

In this tutorial, we will launch a Space app built with Svelte. Deta Space supports any frontend framework alongside backend APIs built with Node, Python, Go, Rust or other custom binaries. We will only use Svelte for illustration purposes, but you can use any framework of your choice for this guide.

We will start by creating our Svelte app using the official instructions found on [Svelte.dev](https://svelte.dev/):

```bash
npm create vite@latest my-space-app -- --template svelte
```

Afterwards, let's make sure to go into the directory of our new Svelte app:

```bash
cd my-space-app
```

Now we are ready to continue with the Space specific steps.

## Installing the CLI

In this tutorial, we will use the Space [CLI](/docs/en/reference/cli) to create a new project on Space and then release it as a Space app.


<OSTabs>
  <Fragment slot="mac">
    To install the Space CLI on MacOS, open a Terminal session and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="win">
    To install the Space CLI on Windows, open PowerShell and enter:

    ```bash
    iwr https://get.deta.dev/space-cli.ps1 -useb | iex
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="linux">
    To install the Space CLI on Linux, open a Terminal and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

</OSTabs>

Once you have successfully installed the Space CLI, you'll need to log in to Space.

The Space CLI authenticates itself with 'Access Tokens'. You can create an access token under Settings in your Space. Just type 'settings' in Teletype to open them.

After you have generated a new key you can add it to the CLI using `space login`. It will prompt you for the key and then store it safely.

From a terminal type:

```bash
space login
```

After you've entered the key the Space CLI is ready to be used!

## Creating a project

A "[project](/docs/en/basics/projects)" allows you to start building an app, experiment with different Space features, test if your app works in a Space environment and finally release it to the public so others can get their own copies in their own personal clouds.

Let's create a new project inside our local directory with the following command:

```bash
space new
```

The CLI will ask you to name your project, we will call ours "awesome-app". Then it will try to detect which framework or language you are using and show you what's found. In our case it should correctly identify our Svelte app with the following message, prompting you to confirm:

```bash
‚öôÔ∏è No Spacefile found, trying to auto-detect configuration ...
üëá Deta detected the following configuration:

Micros:
name: frontend
 L src: .
 L engine: svelte

? Do you want to bootstrap "awesome-app" with this configuration? (y/n)
```

After confirming it will create a new project in [Builder](/docs/en/basics/projects#projects-in-builder) (a Space App for building and releasing Space Apps) and generate a [Spacefile](/docs/en/reference/spacefile) in your local directory:

```yaml
v: 0
micros:
  - name: frontend
    src: .
    engine: svelte
```

For now, it's enough to say that your `Spacefile` contains the configuration of your app which is used by Space to understand what your app looks like and how to run it.

The CLI also created a hidden `.space` directory locally which contains information necessary to work with your project in Builder. This file should not be included in your version control and was automatically added to your `.gitignore`, if you have initialized a Git repository.

After you've created a project you can view and manage it in [Builder](/docs/en/basics/projects#projects-in-builder). Builder is available on your Space Canvas.

## Pushing to Space

Now that we have created our project, we can push our local changes to a live Space environment.

Let's use another CLI command to do this:

```yaml
space push
```

`space push` will package and upload all the necessary files to create a new "[revision](/docs/en/basics/revisions#whats-a-revision)". A revision is a complete package of your app at a single point in time. New Revisions are created with each push. You can view this new revision by opening your project inside Builder. It will be shown on the "Develop" tab.

## Creating a release

The last step is to create a "[release](/docs/en/basics/releases)" out of our revision. A release makes your app installable to others.

Let's use one final CLI command:

```bash
space release
```

That's it, you can now share the release link with *anyone* you want and they will be able to install their own copy of your app in their Space.

Welcome to the Detaverse! üöÄ# why-deta.md

## Computers, ideas, and their authors

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/developer.gif" width="400px" />
</div>

We believe computers are incredible: one single tool can activate a tremendous diversity of human ideas. For this to happen, software developers play a *magical* role. They encode these ideas into a format usable to the computer, which puts them to work at a wonderous efficiency. This combination, of computers & apps, helps us throughout much of our everyday lives, automating much of the boring and routine. But it also lets us explore & author our own ideas, and create our own worlds. This is all made possible because a software developer sat down and turned an idea into an app. With computing, many of the limits of the doable are defined by the limits placed on the people sitting down and turning dreams into software.

## The modern cloud: destroying dreams

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/broken.gif" width="400px" />
<a target=‚Äù_blank‚Äù rel="noopener noreferrer" style="max-width: 100%; white-space: pre-wrap; word-break: break-word font-size: 9px; line-height: 1.15; padding-top: 4px; padding-bottom: 6px; padding-left: 2px; color: rgba(55, 53, 47, 0.65); font-style: italic;" href="https://64.media.tumblr.com/437f41a5c3525e3f5252b03f1c55b38c/tumblr_myhf2vr7Hy1r34zhyo6_400.gifv">source
</a>
</div>

In theory, combining computers and the internet is a huge win for activating these ideas. With ‚Äòcloud computing‚Äô, software becomes accessible to any human or computer with an internet connection. An idea is not tied to a single device and it can serve others, regardless of where they are. This magnifies the limits of the doable: we can instantly interact with & use the ideas of others, collaborate on authorship of new ideas, share our own worlds, and explore the worlds of others.

In practice, there are two big problems with cloud computing on today‚Äôs large ‚Äòpublic clouds‚Äô, *particularly for the  special group we mentioned earlier: software developers.*

First, the public cloud asks way too much from developers who want to move from an idea to working app. To deliver web applications that others can use, developers have to fight a steep tooth and nail battle creating, operating, and paying for a complex web of cloud infrastructure. We think this is holding back millions of developers around the world from delivering billions of incredible dreams that do.

Second, software developers are not just authors, they are critical *users* of computers. Many of their most important ideas for the rest of us come from dreaming and tinkering for themselves. Personal computing empowers them to do this, but the public cloud & its apps do not. Instead, developers have little control of their own personal 'cloud stuff', which is crucial raw material to build on top of, explore, and extend.

Without these issues, we think developers can unlock these frontiers in their own computing lives, paving the way for everyone else.

## Deta's next act: *the personal cloud*

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/drive.gif" width="400px" />
<a target=‚Äù_blank‚Äù rel="noopener noreferrer" style="max-width: 100%; white-space: pre-wrap; word-break: break-word font-size: 9px; line-height: 1.15; padding-top: 4px; padding-bottom: 6px; padding-left: 2px; color: rgba(55, 53, 47, 0.65); font-style: italic;" data-content-editable-leaf="true" contenteditable="false" href="https://64.media.tumblr.com/4951e22fd1e5d2fb91fa04057ec1b149/tumblr_mji8cbwQ921r34zhyo8_500.gifv">source
</a>
</div>

In short, at Deta we believe:
1. individual software developers around the world are the key to getting cloud computing right
2. the ‚Äòpublic cloud‚Äô is crippling their creativity with unnecessary complexity, costs, and limits

We've run into these issues ourselves and got pretty frustrated. So we decided to build a cloud that's a lot more personal and friendly for the individual developer. We see it as two things, to start:

- a personal launchpad for devs to bring their ideas into the world with ***0-ops***
- a personal computer in the cloud for devs to host and use their own apps and data

[Read on](/docs/en/introduction/personal-cloud) to learn about how the personal cloud works and some of the benefits we see for developers.
# start.md

## ‚ú® Key features

Deta Space is standing behind you, fully.

- **Fully managed servers**: App developers have an ops burden of zero, as they scale their users to space.

- **Fully managed data**: App developers don't have to worry about user data/compliance.

- **Fully managed security**: App developers don't think about security and auth - each user gets their own sandboxed app with managed auth.

- **Fully managed payments**: App developers can earn money with their apps, activated easy-peasy (planned).

## üíª Build your first Space app

Follow our [guide](/docs/en/introduction/first-app) on how to build your first app for Space. We also have tutorials on how to launch your favorite frameworks on Space in the **Quickstarts** section.

## üìö Learn Space

Learn about the key concepts of Space:

- [Apps](/docs/en/introduction/app-anatomy)
- [Micros](/docs/en/basics/micros)
- [Data storage](/docs/en/basics/data)
- [Development](/docs/en/basics/revisions)
- [Publishing](/docs/en/basics/releases)

*‚Ä¶ find our full API documentation under the **Reference** section.*

## üí¨ Join our community

We have a growing community of like minded developers who are happy to help or provide feedback on your Space projects. Join us on [Discord](https://go.deta.dev/discord)!

You can also follow us on [Twitter](https://twitter.com/detahq) to stay up to date on all the shenanigans.
# app-anatomy.md

## Computing with Micros

The 'brains' of an app are made up of what are called [Micros](/docs/en/basics/micros#whats-a-micro). A Micro is essentially a lightweight runtime capable of running different frameworks and languages. Micros are exposed via an HTTP endpoint. Micros within the same app can talk to one another.

## Storing and retrieving data

In addition to the compute provided by Micros, each app instance also has its own database called [Base](/docs/en/basics/data#base) and file store called [Drive](/docs/en/basics/drive#base). This data is sandboxed at the level of a single copy of the app; the data is separate from both other apps belonging to the same user and other users' copies of the same app. Nonetheless, the data is shared between all Micros inside a single copy of an app.

As a Space app developer, you'll code your app slightly differently than you would on the '[public cloud](/docs/en/introduction/personal-cloud#the-public-cloud)'. The good news is you do not have to worry about data separation or user authentication & authorization. You will end up writing a lot less code; you can code your app as if there is only one user, where auth 'just works'.

## Resource limits

A single app can consist of up to five Micros and an unlimited number of Bases and Drives. All these resources do not have to be created. Micros can be defined in your [Spacefile](/docs/en/reference/spacefile), while Bases and Drives can be created by your app during runtime.

On the public cloud, as a developer, you would pay and take responsibility for the resources 3rd party users consume through an app you wrote. On the personal cloud, this is completely different: the resources live with the users, so you do not need to worry about either.

## Developing and releasing your app

During development, you have access to a [Builder instance](/docs/en/basics/revisions#testing-changes) of your app. This instance gets continuously updated with your latest changes as soon as you push them to Deta. You can use this instance in Deta Space before "releasing" it.

On the personal cloud, Space apps are not "deployed" once, but they are "[released](/docs/en/basics/releases)". People can install releases of a Space app in their own Space.


# accessing-client-ip-address.md

You might want to collect some information about the clients accessing your app, like their IP address, which can be useful for analytics or security purposes. However, you might have noticed that when you directly try to access the IP address in your app, you receive `127.0.0.1` or an undefined response due to technical limitations.

Fortunately, there is a workaround that you can use to access the client's IP address. This is by using the [`CF-Connecting-IP` header](https://developers.cloudflare.com/fundamentals/get-started/reference/http-request-headers/#cf-connecting-ip), which is available when using [Cloudflare](https://www.cloudflare.com/) as the DNS provider for your [custom domain](/docs/en/basics/micros#custom-domains) with Cloudflare Proxy enabled. Cloudflare is a content delivery network (CDN) that acts as an intermediary between your website and your visitors, improving the speed and security of your site.

Once you've added your domain to Cloudflare, follow these steps:

1. Open [Canvas](https://deta.space/), click on the three dots (...) at the bottom right of your app's icon and select **Configuration** (or **Settings** if your app has been released) to open your app's settings

2. Click **Add Custom Domain** (in the Domains tab for released apps) and enter your domain name (e.g. `app-name.example.com`)

3. Go to the DNS settings in your [Cloudflare Dashboard](https://dash.cloudflare.com/) and add the required records. Make sure that **Cloudflare Proxy** is enabled when adding the A record.

![Cloudflare Proxy](/docs_assets/guides/accessing-client-ip-address/cloudflare-proxy.png)

> Make sure to change your SSL/TLS encryption mode to **Full** in the [Cloudflare Dashboard](https://dash.cloudflare.com/) before doing this to avoid any unexpected issues

4. Verify that your domain has been added. Now, you can use the `CF-Connecting-IP` header to determine your client's IP address when your app is accessed via the custom domain.

Here's an example of how to access the header in ExpressJS:

```js
app.get("/endpoint", (req, res) => {
  const ipAddress = req.get("CF-Connecting-IP");
  res.send(`Your IP address is ${ipAddress}`);
})
```

It's important to be note that the `CF-Connecting-IP` header can be spoofed, so you should always use additional security measures in conjunction with it.# sveltekit.md

## Configure your SvelteKit app
To run a SvelteKit app on Space, you'll need to use the SvelteKit node adapter: [`@sveltejs/adapter-node`](https://kit.svelte.dev/docs/adapter-node). If you already use the Node adapter, skip to the [next section](#run-it-on-space).


First, install the `@sveltejs/adapter-node` dependency:

```sh
npm install @sveltejs/adapter-node
```

Then, in your `svelte.config.js` file, replace the current adapter with the node adapter:

```js
import adapter from '@sveltejs/adapter-node';
// rest of the file
```


Your project is now configured to run on Space. Let's run it!

## Run it on Space
After making sure you've installed the [Space CLI](/docs/en/basics/cli), run the following command in your project's directory:

```sh
space new
```
Follow the prompts to give your app a name. Once that's done, let's push your app to Space:

```sh
space push
```

Great job! You've just deployed your first SvelteKit app on Space. You can now access your app at the URL provided by the CLI.


# go.md

Space supports Go Micros, but it requires a bit more configuration.

- `engine` needs to be set to `custom`
- `commands` needs to include commands that build a binary
- `include` should be set to the binary file that is built as a result of running `commands`
- `dev` should be the command to start the program in development mode
- `run` should be the command to run the binary

Here is an example:

```yaml
v: 0
micros:
  - name: go-app
    src: ./src/go-app
    engine: custom
    dev: go run main.go
    commands:
      - go get
      - go build main.go
    run: ./main
    include:
      - main
```

- The first command `go get` installs any external packages/modules.
- The second command `go build main.go` builds the program into an executable file.
- `include` specifies which file(s) to include in the final package of the micro. In this case only our build binary file.
- Finally, `run` specifies the command that should be run to start the program. In this case, it is running the executable that was generated from the previous step.


# next.md

> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

If you don't have an existing Next app already you can create a new one by following the offical [Next instructions](https://nextjs.org/docs#automatic-setup).

For Space to be able to run Next it needs to be configured to ouput a standalone app. This ensures that the app is built to be served by a NodeJS server, refer to the [Next Docs](https://nextjs.org/docs/advanced-features/output-file-tracing#automatically-copying-traced-files) for more information.

Please modify `next.config.js` to set the output to `standalone`:

```jsx
/** @type {import('next').NextConfig} */
const nextConfig = {
    output: "standalone",
}

module.exports = nextConfig
```

Once you've edited your `next.config.js` file, just modify your [Spacefile](/docs/en/reference/spacefile/) file before [pushing changes](/docs/en/basics/revisions/) to Space.

Spacefile Configuration:

```yaml
v: 0
micros:
  - name: next-app
    src: ./src/fullstack/next-app
    engine: next
```

# custom.md

Deta Space supports most runtimes and frameworks out of the box without much configuration. The only requirements you have to keep in mind are:

- All web servers need to run on the port specified in the environment variable `PORT`
- 250 MB is the max size of the package


# nuxt.md

> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

If you don't have an existing Nuxt app already you can create a new one by following the offical [Nuxt instructions](https://v3.nuxtjs.org/getting-started/installation#new-project). Only Nuxt 3 is supported out of the box.

By default Nuxt will automatically output a standalone server which Space can run without additional configuration.

Once you've got a Nuxt 3 app locally paired with a [Space Project](/docs/en/basics/projects/), just modify your [Space Spacefile](/docs/en/reference/spacefile/) file before [pushing changes](/docs/en/basics/revisions/) to Space.

Space Spacefile configuration for Nuxt 3:

```yaml
v: 0
micros:
  - name: nuxt
    src: ./src/fullstack/nuxt
    engine: nuxt
```

# node.md

To run a Node.js app on a Space Micro, **it is recommended to use Node.js v16** since it works with Space out of the box.

> ‚ö†Ô∏è Make sure that your Micro is configured to listen on the port number specified in the environment variable `PORT`.

Here's the Spacefile needed to get a basic Node.js app running on Space:

```yaml
v: 0
micros:
  - name: node-micro
    src: src/node
    engine: nodejs16
    dev: nodemon index.js
    run: "node index.js"
```

index.js

```js
const express = require('express')
const app = express()

const port = process.env.PORT

app.get('/', (req, res) => {
  res.send('Hello from Space!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
```

> ‚ÑπÔ∏è We use [`nodemon`](https://www.npmjs.com/package/nodemon) to watch for changes in our code and restart the server automatically. You can use any other tool you like.

If your Node Micro has a build step (e.g. because you are using TypeScript) use a config similar to the following:

```yaml
v: 0
micros:
  - name: node-micro
    src: src/node
    engine: nodejs16
    dev: "npm run dev"
    commands:
      - npm run build
    include:
      - build
    run: "node build/index.js"
```

- `commands` specifies which commands to run during build, in our case our NPM script `build`
- `include` specifies which directory to include in the final app package, everything else will be ignored. In our case we set it to the directory of our build output
- `dev` specifies the command to start your Micro in development mode. In our case running the `dev` script in our `package.json`
- `run` specifies the command to start your Micro. In our case running the `index.js` file in our `build` directory using `node`

> ‚ÑπÔ∏è Support for Node.js v18 is coming soon.


# static.md

> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

Static micros work out of the box with most frontend frameworks like React, Vue, and Svelte. Just set the right `engine` value in your [Space Spacefile](/docs/en/reference/spacefile/) and you are good to go:

```yaml
v: 0
micros:
  - name: frontend
    src: src/frontend-app
    engine: svelte # or react/vue
```

The following frameworks are supported configuration-free using `engine`:

- `react`
- `svelte`
- `vue`

For other frameworks the configuration is minimal.

Set the engine to `static` and specify the directory to serve with `serve`. If your framework has a build step, include your build command with the `commands` field:

```yaml
v: 0
micros:
  - name: frontend
    src: src/frontend-app
    engine: static
    dev: npm run dev
    commands:
      - npm run build
    serve: dist
```
# rust.md

## Step 1: Create a Space project
Make sure you have the [Space CLI installed and set up](/docs/en/basics/cli). Then, in the root directory of your Rust project, run the following to create a Space project and an empty [`Spacefile`](/docs/en/reference/spacefile):

```sh
space new
```

## Step 2: Configure your Spacefile

Configuring your project for Rust requires two steps. First, replace the contents of the `Spacefile` with the following:

```yaml
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: main
    src: .
    engine: custom
    dev: cargo run
    commands:
      - cargo build --release
    run: ./nameofyourbinary
    include:
      - target/release/nameofyourbinary
```

Make sure to replace `nameofyourbinary` with the name of your binary. Feel free to adjust the `commands` and `run` to your needs.

> __Explanation of the Spacefile:__
> - We are using the `custom` engine, which allows us to run any command we want
> - We are building the Rust app using `cargo build --release`
> - We are running the binary that was created in the previous step
> - We are including the binary in the final image (using `include`)
> - We are setting `src: .` as the current directory is the root of the Rust project
> - We are specifying a command to run during development using `dev`

Second,  create a `.spaceignore` file in the root of your project and add the following:

```
.git
target
```

## Step 3: Run it on Space

Now you can run your Rust app on Space:

```sh
space push
```

This will build your Rust app and push it to Space. You can now access your app at the URL provided by the CLI.
The build process will take a few minutes, as it has to build the Rust app from scratch.

`space push` is the same command you would also use to update your app.

Done! ‚ú®
# python.md

## Step 1: Code configuration

For Space to run your Python app, you need to have a file called `main.py` that contains the the main instance of your app, which __must__ be called `app`. You can structure your app however you want, but the `main.py` file must be in the root of your project. Make sure you also have a `requirements.txt` file that contains the dependencies of your app.

### Starlette
Here is an example of a simple Starlette app:

```yaml
v: 0
micros:
  - name: python-app
    src: ./src/python
    engine: python3.9
```

`main.py`
```python
from starlette.responses import PlainTextResponse


async def app(scope, receive, send):
    assert scope['type'] == 'http'
    response = PlainTextResponse('Hello, Space!')
    await response(scope, receive, send)
```

### FastAPI
Here is an example of a simple FastAPI app:

`main.py`
```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def read_root():
    return {"Hello": "Space!"}
```

### Flask
Here is an example of a simple Flask app:

`main.py`
```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello_world():
    return "Hello, Space!"
```


## Step 2: Run it on Space
Make sure you have the Space CLI installed & authenticated, then run the following command:

```bash
space new
```
This will create a new Space project in the current directory. You can then run the following command to push your code to Space:
> __Important__: before `space push`, we recommend creating a [`.spaceignore`](/docs/en/basics/revisions#ignoring-files-and-directories) file to ignore files that you don't want to be deployed to Space. For example, you should ignore `.git` and `.venv` folders.


```bash
space push
```

Great job! You've just deployed your Python app on Space. You can now access your app at the URL provided by the CLI.

## Limitations
- Space only supports Python 3.8 and 3.9
- Space only supports ASGI and WSGI apps (HTTP servers). So raw scripts won't work.
- Only `/tmp` is writable
- SQLite, MySQL, and PostgreSQL are not supported (we recommend using [Deta Base](/docs/en/reference/base/sdk), which is built into every Space app by default)
- Total size of deployed app is limited to 250MB (including dependencies, source code, etc). So many large dependencies like `numpy` or `streamlit` might not work, as well as larger models.

## Setting up local development

We recommend using virtual environment for local development. If you have listed your app dependencies in a `requirements.txt` file, you can install them to your virtual environment with the following commands:

```bash
# Create a virtual environment in the current directory
python -m venv .venv
# Activate the virtual environment
source .venv/bin/activate
# Install dependencies
pip install -r requirements.txt

# If you are using FastAPI, you will also need to install uvicorn
pip install uvicorn[standard]
```

Then you will need to setup the dev command inside your Spacefile. Just reference the executable file from your virtual environment:

```yaml
  - name: python-app
    src: ./src/python
    engine: python3.9
    dev: .venv/bin/uvicorn main:app --reload
```# guide.md

## The application

For this guide we will use a simple "Hello World" Next app.

TODO: show how to create a sample next app and how to run it locally

## Install the Deta CLI and login

Now we are ready to launch our app to Space which means we will need the Deta CLI. If you've already installed it, just carry on. If not, checkout our [installation guide](/docs/en/basics/cli).

## Create a Builder Project

We can create a new project inside our local directory with the `deta new` command:

```bash
deta new
```

The CLI will ask you for your project‚Äôs name and will try to detect which framework or language you are using based on your source code. It will show you the configuration it detected for your app and prompt you to confirm it. In our case it correctly indentified our Next app.

After confirming it will create a new project with Builder and generate a `space.yml` file in your local directory:

```yaml
v: 0
micros:
  - name: app
    src: ./src
    engine: next
```

This file contains the configuration of your app which is used by Space to understand what your app looks like and how to run it.

As you can see above it added a single [Micro](/docs/en/basics/micros#whats-a-micro) to our project.

## Configuring our Micro

You can find more information about the properties of `space.yml` file in the [Spacefile Reference](/docs/en/reference/spacefile).

TODO: show how to configure this micro

## Pushing to Space

Now that we have created our project we can push our local changes to Space.

We will once again use the CLI to do this:

```yaml
deta push
```

This will package and upload all the necessary files and create a new [revision](/docs/en/basics/revisions#whats-a-revision). A revision is a complete package of your app at a single point in time. New revisions are created with each push. You can view this new revision by opening your project inside Builder. It will be shown on the "Develop" tab.

## Creating a release

The last step is to create a [release](/docs/en/basics/releases) out of our revision. A release makes your app installable to others.

TODO: use the CLI instead of builder

To do this head to the ‚ÄúPublish‚Äù tab in Builder and click ‚ÄúCreate new release‚Äù.

There you can select a revision (choose the latest one in our case) and enter a version/tag. Since this is our first release we will call it `v1.0`. On the next page you can add a short description and listing text to this release. This will be shown on the [Discovery]() page before users will install your app. Once you are happy with everything hit ‚ÄúRelease‚Äù and watch your app take off!

You can share the release link with anyone you want and they will be able to install your app inside their Space.

Welcome to the Detaverse! üöÄ# cloud.md



If you are migrating from Deta Cloud to Deta Space, take a look at our dedicated [Migration Hub](/migration).# help.md

## Getting Help

We have answered some General [FAQs](/docs/en/other/faq) in these docs, but we are here to help and would love to hear what you think!

If you have any questions or feedback, you can reach us:
- Chat: [Discord](https://go.deta.dev/discord), (#space-mission channel, ask for access if we forgot to add you).

## Reporting Abuse

If you detect any kind of fraudulent, abusive and/or malicious content hosted on Deta, please report the site(s) by sending an email to us at [abuse@deta.sh](mailto:abuse@deta.sh).

We review each report.
# links.md



- [Discord](https://go.deta.dev/discord)
- [Twitter](https://twitter.com/detahq)
- [GitHub](https://github.com/deta)# issues.md

# faq.md

# releases.md

## Creating releases

After you have [pushed changes](/docs/en/basics/revisions) to Space, you can turn a revision into an installable release.


### Releasing from the GUI

You can create a release for your project using [Builder](/docs/en/basics/projects#projects-in-builder).

Simply go to the "Develop" tab and click the "Create Release" button. The next page will let you select the [revision](/docs/en/basics/revisions) you would like to release and offer a version tag (this will be auto-generated if you leave it blank). After clicking next, you will be able to choose if your release should be `listed` on [Discovery](/discovery) or not and can optionally provide some [notes](#release-notes) for the release.

Once you are ready, click "Launch to Space". Then watch your app take off! Your app is now installable on Deta Space to anyone with the release url, which is provided on the following page.

### Releasing from the CLI

You can create a release using the [Space CLI](/docs/en/basics/cli). Simply use the following command:

```bash
space release
```

Pass the `--listed` argument to enable listing on [Discovery](/docs/en/basics/releases#discovery--app-pages).

Pass the `--notes` argument to add notes about the release (changes, features, etc). [More info below](#release-notes).

Then watch your app take off! Your app is now installable on Deta Space to anyone with the release url.

> You can provide specific options to your release (which revision to use, version tags, listed/unlisted) using specific options. See the cli reference for [`space release`](/docs/en/reference/cli#deta-release).

## Discovery & App Pages

Each release of your app is available for installation using [Discovery](/discovery) - Space's app marketplace.

![Screenshot of Discovery](/docs_assets/discovery.png)

There are two ways your app will be available on Discovery:

- **Unlisted**: If your app is *unlisted*, only people who have the link to your release will be able to view its page and install the app. This is the default behaviour when creating a release via the CLI or the UI.

- **Listed**: If your app is *listed*, it will be shown publicly on Discovery where other users can easily find and install it. To enable listing use the `--listed` argument in the CLI (`space release --listed`) or select "List on Discovery" when creating a release using Builder.

In both cases, your app will be available on its own page on Discovery.

Not only does your app's Discovery page allow users to install your app, it also gives you the opportunity to explain what your app does, how it is unique, and its features.

You can customize an app's Discovery page using a `Discovery.md` file, which gives you  a full Markdown description and options to specify things like an app title & tagline and links to a Git repository & homepage. More info on how to use the `Discovery.md` file to customize your app's Discovery page can be found in the [Discovery.md Reference](/docs/en/reference/discovery).

## App Updates

When you publish your app by creating a release, Deta creates an installable version of your app. If you update your app afterwards, you need to publish a new release. Anyone who has installed older versions of your app can update their instance to the latest release (they could also install a new instance). When updating an app, the data will be kept across the update.

> ‚ö†Ô∏è Important note: updates only work when the data your app stores are compatible with the new app version. In the future we will have data migrations to help with this. If a new release is not compatible with old versions, you need to create a separate app for it to prevent breaking installed apps.

Users of your app will be shown an update notification if you publish a **listed** release newer than the one they have installed. **Unlisted** releases will not be made available as updates.

## Release Notes

To notify your users of changes made with a new release you can add "Release Notes" to a release. These notes support the Markdown syntax with the [same limitations as the Discovery.md file](/docs/en/reference/discovery#supported-syntax).

Release notes will be shown to users of your app, before they install the release as an update and can be viewed on the app's Discovery page under "What's new?".

### Adding notes from the CLI

To add notes to a release you can use the `--notes` argument with the Space CLI:

```bash
space release --notes
```

It will prompt you to enter your release notes before creating the release. You can also provide a string to `--notes` directly to skip the prompt:

```bash
space release --notes="Fixed bug xyz"
```

### Adding notes from the GUI

During the publishing flow in Builder, you will be shown the option to add release notes as the second step.
# micros.mdx

## What's a Micro?

Deta Space can run almost any type of app. For example, Space supports:
- frontend sites built with frameworks like React, Vue and Svelte
- full-stack frameworks like Next, Nuxt or SvelteKit
- backend apps built with Node.js, Python and even Go, Rust or something more custom.

A Space app can also be built by combining these different technologies, for example, a SvelteKit app with a Go API, really any combination of up to 5 different languages/frameworks.

We call these individual parts of an app **Micros**. A Micro is a lightweight compute service running inside your app which can be exposed to the outside using HTTP.

Micros are defined in your project's [Spacefile](/docs/en/reference/spacefile), telling Deta Space what Micros your app contains and how to run them.

## Adding your first Micro

When you create a new project using the Space CLI, it will try to detect the type of app you want to deploy. This works for most frameworks like Next, Nuxt, SvelteKit, and backend runtimes like Node.js and Python.

If this detection works, it will show you what type of Micro is detected and its generated config. After you've confirmed the config is correct, the CLI will create the `Spacefile` in your local directory for you.

Even if this detection fails, Space supports almost any type of app via the `Spacefile`.

## Adding Micros via the Spacefile

If you want to run something more custom or need to add more Micros to an existing project, you can edit the project's `Spacefile` to add the required configuration.

Take a look at the [Spacefile reference](/docs/en/reference/spacefile) for a complete list of options.

Here's the `Spacefile` for an app consisting of a single Node.js Micro:

```yaml
v: 0
micros:
  - name: api
    src: ./node-api
    engine: nodejs16
    run: npm run start
```

The `name` field identifies your Micro inside your app and the `src` should point to the location of the Micro's source code relative to your project's root.

If your project contains more than one Micro, the `primary` field can be used to identify the entry point of your application (which Micro will be executed when the root path of your project is visited via HTTP).

## Directory structure

A Micro can be thought of as its own independent service. As a result, they need to be self-contained in their own directory in your project and your project root should not contain any Micro specific files.

Here's an example of the file & folder structure of an app with a Python backend and a Vue frontend:

```
Spacefile
backend/
    requirements.txt
    main.py
frontend/
    package.json
    src/
        index.vue
```

All files needed for the Vue frontend (including `package.json`) are inside the `frontend` directory, while all files needed for the Python backend are inside `backend`.

Here is the matching `Spacefile`:

```yaml
v: 0
micros:
  - name: frontend
    src: ./frontend
    engine: vue
    primary: true
  - name: backend
    src: ./backend
    engine: python3.9
```

> üîë It's recommended to put your first Micro in its own sub-directory of your project. A single Micro will work running in the root directory of your project, but this approach doesn't scale. You'll have to migrate this Micro as soon as you want to add a second Micro to your project.

## Micro Routing

Since your app can contain multiple Micros, the Space runtime needs to know what requests to route to which Micro.

On Space, this is handled by having a single primary Micro which receives all requests made to your app's root path `/`. Each other Micro defined in your [Spacefile](/docs/en/reference/spacefile) will be served under a specific path relative to your app's primary hostname. This is defined in the `path` field for each Micro in your `Spacefile`:

```yaml
v: 0
micros:
  - name: client
    src: ./client
    engine: svelte
    primary: true
    path: client
  - name: api
    src: ./api
    engine: nodejs16
    path: api
```
In this example, the `api` Micro will be available at `/api` while all other paths including the root `/` will be received by the primary Micro, in this case, the static Micro `client`.

If the path is missing, the path will fall back to the `name` field.

## Public Routes

If you want parts of your app to be available to the public (instead of being protected behind auth), you need to specify the routes with the `public_routes` keyword in your app's [Spacefile](/docs/en/reference/spacefile):

```yaml
micros:
  - name: backend
    src: backend
    engine: python3.9
    public_routes:
      - "/test" # exact match
      - "/public/*" # wildcards
      - "/api/*/docs" # wildcards can be placed anywhere
```

You can either match a route exactly, or use a wildcard (`*`) to match anything after it.

The paths specified with `public_routes` are _relative_ to a given Micro's root. This means you do not need to specify a Micro's own path as part of its own `public_routes`. For example, if `/api` is served by a secondary (backend) Micro, and you want to make the route `/api/public` public, then you only need to specify `/public` as a public route for this Micro:

```yaml
micros:
  - name: frontend
    src: frontend
    engine: static
    primary: true

  - name: backend
    src: backend
    path: api
    engine: python3.9
    public_routes:
    - "/public" # This Micro is served under `/api` so if we want to make `/api/public` available to the outside we only need to specify `/public`
```

Requests made to your Micro matching any of the routes defined in `public_routes` will bypass Space's authentication entirely.

## Cross Micro Communication

Micros within a project are independent services, but can call one another to get what they need.

How you can successfully call one Micro from another one depends on if the calling Micro is sending the request from the browser or server side (from).

### From the browser

If you are trying to call a backend Micro from another Micro in the browser, you can make requests to the relative path under which the Micro is served from:

```js
// In the browser
fetch('/api')
```

That's it. If Micros live in the same 'project', auth just works.

### Server side

If you are trying to call another Micro from the backend you need to get your app's assigned hostname to use as the origin, and use an api key to authenticate your request.

Both of these items are provided in the environment of the Micro:
- The primary hostname is under the `DETA_SPACE_APP_HOSTNAME` environment variable.
- The api key is under the `DETA_API_KEY` environment variable. This should be added as a header to your http request under `X-API-Key`.

Here's how you'd make a request to a second Micro (on the path `/second-micro`) within an app, using Python:

```python
import os

origin = f"https://{os.getenv('DETA_SPACE_APP_HOSTNAME')}"
api_key = os.getenv("DETA_API_KEY")
headers = {"x-api-key": api_key}

res = requests.get("/second-micro", headers=headers)
```

> ‚ö†Ô∏è If you expose this API Key, you risk compromising your Space app.

## API Keys

If you want users of your app to be able to access their app instance programmatically you can enable the `api_keys` preset for Micros in your app:

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      api_keys: true
```

If enabled, users of your app will be able to generate API keys in their app instance settings and use them to authenticate requests made to otherwise private routes of a Micro.

Generated keys need to be provided in the HTTP header `X-Space-App-Key` and only work with Micros that have the preset `api_keys` enabled. Public routes have a higher preference than API keys, if there are public routes specified these will always be public.

> Note: If you enable API keys you should show clearly in the app that API keys can be used and ideally have clear documentation on which endpoints of your app work with API key auth.

## Micro Environment Variables

### Pre-set Variables

The following environment variables will be set in all Micros,  accessible on the server side.

- `DETA_PROJECT_KEY` - deta project key
- `DETA_SPACE_APP` - will be set to `‚Äútrue‚Äù`
- `DETA_SPACE_APP_VERSION` - the app version
- `DETA_SPACE_APP_HOSTNAME` - will be set to the **primary** hostname
- `DETA_SPACE_APP_MICRO_NAME` - micro‚Äôs name
- `DETA_SPACE_APP_MICRO_TYPE` - will be set to `"primary"` if primary otherwise `‚Äúnormal‚Äù`

Please let us know if you need additional configuration.

### Custom Variables

Use the `env` preset if you need to set custom environment variables for your Micros. This can also be used to let users of your app specify things like external secrets or [API Keys](/docs/en/basics/extending_apps#api-keys) or [Data Keys](/docs/en/basics/extending_apps#data-keys) of different app instances.

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      env:
        - name: SECRET_MESSAGE
          description: Secret message only available to this Micro
          default: "deta is cool"
```

- `name` : environment variable name or key
- `description` : human friendly description (optional)
- `default` : default value for the variable (optional)

The user of the app will be shown a UI in the App's Settings where they can set the values for the specified environment variables. They will be exposed to the Micro's environment under the specified `name`.

## Custom Domains

If you already have your own domain you can assign it to any Builder or app instance with a few clicks. This ‚ÄúCustom Domain‚Äù works in addition to the default Space domain that gets assigned to an instance. The domain will be connected to the primary Micro of the app instance.

Follow just a few steps to add a custom domain to your app:

- To add a custom domain to a Builder instance, open the Builder project and head over to the "Develop" page and then to the "Configuration" tab. Click ‚ÄúAdd Domain‚Äù and enter your domain name.
- To add a custom domain to an app instance you installed, open the app settings by clicking the 3 dots (‚Ä¶) next to the app‚Äôs icon on the Canvas, click ‚ÄúSettings‚Äù and then switch to the ‚ÄúDomains‚Äù tab. Click ‚ÄúAdd Domain‚Äù and enter your domain name.

Before your domain is live, you need to setup a DNS record to point your domain to our servers. Follow the guide in our [User Manual](/manual/features/custom-domains) to learn how to do this.

## Scheduled Actions

Scheduled actions allow an app to perform certain tasks on a specific interval. These tasks can be anything you build into your app, from a cleanup job to automated data aggregation or revalidation.

### Adding a Scheduled Action

Scheduled actions are defined in the [Spacefile](/docs/en/reference/spacefile) on the Micro level:

```yaml
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

Each action with the trigger `schedule` needs to have a unique `id`, `name`, and `default_interval` at which it runs. You can optionally provide a description to inform the user about what the action is used for. More information on all the supported fields can be found in the [Spacefile Reference](/docs/en/reference/spacefile#actions).

When an action runs, a `POST` request containing the action `id` and the `trigger` in the event body will be sent to the Micro on the path `/__space/v0/actions`.

For example, the example Spacefile above will result in the following request body:

```json
{
  "event": {
    "id": "cleanup",
    "trigger": "schedule"
  }
}
```

It is up to you to handle the request and run whatever logic you need. You could for example call a function or interact with [Base](/docs/en/reference/base/about) and [Drive](/docs/en/reference/drive/about) through the Deta SDK:

<Tabs
  client:visible
  sharedStore="tabLang"
  defaultPanel="js"
  tabs={[
    { label: "JavaScript", value: "js" },
    { label: "Python", value: "py" }
  ]}
>
  <Fragment slot="panel.js">
  ```js
  // using express
  app.post('/__space/v0/actions', (req, res) => {
    const event = req.body.event

    if (event.id === "cleanup") {
      cleanup()
    }

    res.sendStatus(200)
  })
  ```
  </Fragment>
  <Fragment slot="panel.py">
  ```python
  # using flask
  @app.route('/__space/v0/actions', methods=['POST'])
  def actions():
    data = request.get_json()
    event = data['event']
    if event['id'] == 'cleanup':
      cleanup()
	```
  </Fragment>
</Tabs>

### Interval Types for Scheduled Actions

Space currently supports two types of intervals for scheduled actions:

- [Rates](/docs/en/reference/spacefile#rates) e.g. `2 hours`
- [Cron Expressions](/docs/en/reference/spacefile#cron-expressions) e.g. `0 10 * * *`

Check out the [Spacefile Reference](/docs/en/reference/spacefile#actions) on the exact syntax.

Scheduled actions have to be purposely enabled, setup and need to have a default interval which they will be executed on.

After installing an app, its scheduled actions are automatically enabled and set to run on the default interval. The user can at any point change the interval or disable an action completely. Check out the [User Manual](/manual/apps#schedules) on how scheduled actions are presented to app users.
# projects.md

## What's a project?

When building apps for Space, the first thing you will start with is a Space 'project'. A project allows you to start building an app, experiment with different Space features, test if your app works in the Space environment and finally release it to the public so others can start using it.

## Projects in Builder

Projects in Space live inside Builder, an app which can be found on your Canvas. Builder is your toolbox for building an app on Deta Space. It allows you to create new projects and manage them over time.

Each Project in Builder consists of 3 main pages:

- **Overview**: the overview page lets you see important information about your projects like its latest release and recent events

- **Develop**: the develop page allows you to configure and develop your project. Here you have access to your project resources like the development data as well as information about your Builder instance.

- **Publish**: the publish page allows you to create and manage releases of your app

## Creating a Project

You can create new projects using the [Deta Space CLI](/docs/en/basics/cli), which will guide you through the process.

Use the `space new` command to create a new project with the Space CLI:

```sh
space new
```

The CLI allows you to choose from a variety of templates to bootstrap your project or it can automatically set up the right project configuration based on what you have locally.

You will be prompted to enter a name for your project. Next, the CLI will try to detect any existing applications in your local directories. If found, the CLI will show a generated config for those applications.

Once you confirm the generated config, the CLI will create a new project in Builder and generate a [Spacefile](/docs/en/reference/spacefile) file in your local directory. The `Spacefile` contains the configuration of your app, used by Deta Space to understand what your app looks like and how to run it.

Additionally, the CLI created a hidden `.space` directory -- this contains information about the project, linking it to your Builder project. This directory should not be included in your version control and was automatically added to your `.gitignore`.

After you've created a project, you can view it inside the [Builder](/docs/en/basics/projects#projects-in-builder) app, which can be found on your Canvas in Space.

> Builder doesn't keep track of your source code, we recommend you use Git as a version control system.

## Project linking

Your local development environment is connected to Builder via a hidden `.space` directory, which contains a unique identifier: a project ID.

If you first run `space new` in a directory, the Space CLI will automatically connect the local directory via this ID with your newly created project in Builder.

If you ever need to connect an unlinked local directory to a project in Builder, you can use `space link` to link your current directory to the existing project:

```bash
space link
```

The CLI will prompt you to enter your project's ID and will then link your directory with the project on Space. This project ID is accessible in Builder in your project's "Develop" tab.
# cli.mdx

## Installation

<OSTabs>
  <Fragment slot="mac">
    To install the Space CLI on MacOS, open a Terminal session and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="win">
    To install the Space CLI on Windows, open PowerShell and enter:

    ```bash
    iwr https://get.deta.dev/space-cli.ps1 -useb | iex
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="linux">
    To install the Space CLI on Linux, open a Terminal and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

</OSTabs>


## Authentication

Once you have successfully installed the Space CLI, you'll need to log in to Deta Space.

The Space CLI authenticates itself with 'Access Tokens'. You can create an access token under Settings in your Space. Just type 'settings' in Teletype to open them.

After you have generated a new key you can add it to the CLI using `space login`. It will prompt you for the key and then store it safely.

From a terminal type:

```bash
space login
```

This command will ask for an 'access token' to authenticate your CLI.

```bash
? Enter access token >
```

To get an access token, enter your [Space dashboard](https://deta.space/), open the Teletype (command bar) and click 'Settings':

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli1.png" width="400px" />
</div>

This will open the Settings modal, where you can click 'Generate Token' to generate an access token:

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli2.png" width="400px" />
</div>

Copy the resulting token:

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli3.png" width="400px" />
</div>

You can paste this back into your CLI prompt. After you hit enter, you should be greeted by a success message.

```bash
üëç Login Successful!
```

Upon a successful log-in, you are ready to start building Space apps.


## CLI Commands

Run `space help` to get a overview of the available commands or refer to the [Reference section](/docs/en/reference/cli) for a complete list of CLI commands and options.# revisions.md

## What's a revision

A revision is a complete package of your app at a single point in time. New revisions are created with each push. You can view this new revision by opening your project inside [Builder](/docs/en/basics/projects#projects-in-builder). It will be shown on the **Develop** tab.

A revision can now be used in your Space. It can also be used to [create a release](/docs/en/basics/releases), which you can share with others to install a copy of your app into their own Space!

## Testing changes

To test if your app works in Space, each project comes with your own personal *Builder instance*. This instance of your project is automatically kept up-to-date every time you successfully run `space push`.

The Builder instance is automatically added to your Canvas and can be used like any other app instance. You can also view your Builder instance via your Builder project under the **Develop** tab. Clicking the **Open Builder Instance** will open the instance.

If your Builder instance runs into a runtime error when handling a request, the error logs will be returned in the request's response. All runtime logs, including the error logs, are stored for 14 days and can be viewed in the **Develop** tab of your Builder project under **"Runtime Logs"**. The logs are sorted by time and can be filtered by a specific Micro using the dropdown. Runtime logs can help with debugging Space related errors and mis-configurations of your app.

The Builder instance shares its data with your whole Builder project, which you can [develop against](/data#developing-with-base-and-drive). You can also [view and update this data](/docs/en/basics/data#viewing-data) as you use your app. If you are also [developing your app locally](/docs/en/basics/local) using `space dev` the data will be shared between your local environment and the Builder instance.

## Ignoring files and directories

To exclude certain files and directories from being uploaded during `space push`, use the `.spaceignore` file. It acts similar to a `.gitignore` file, where each line in the file specifies a pattern. All files and directories matching the patterns will be excluded from `push`.

For example, a `.spaceignore` file with the following content `space push` will ignore the `test` and `docs` paths.

```
test
docs
```

Certain directories like the `node_modules` directory for node micros and the `__pycache__` directory for python micros are ignored by default and don't need to be specified in the `.spaceignore` file.

You can use an optional prefix `!` to negate the pattern; any matching file excluded by a previous pattern will become included again.

For eg, a `.spaceignore` file with the following content `space push` will not ignore the `node_modules` directory.

```
!node_modules/
```
# data.md

## How to store data

In addition to the compute provided Micros, each Deta Space app has its own database and file storage services. All the data stored with a Space app is 'sandboxed' within an application instance. By default, this storage is not shared across users and it's also not shared between a single user's app instances (interoperability between apps is planned).

As a result, you can just code your app as if it was only for a single user, without thinking about authentication or data separation.

### Deta Base

To store data, Space apps can use [Deta Base](/docs/en/reference/base/about),  a fully-managed, fast, and secure NoSQL database. Each app can create and use as many Bases as it needs. Base can be accessed using the [Deta Base SDK](/docs/en/reference/base/sdk) or the [Base HTTP API](/docs/en/reference/base/HTTP).

Take a look the the [Base Reference](/docs/en/reference/base/about) on how to use it.

### Deta Drive

To store files, Space apps can use [Deta Drive](/docs/en/reference/drive/about), a fully-managed, secure and scalable file storage service for Deta. Each app can create and use as many Drives as it needs. Drive can be accessed using the [Drive SDK](/docs/en/reference/drive/sdk) or the [Drive HTTP API](/docs/en/reference/base/HTTP).

Take a look the the [Drive Reference](/docs/en/reference/drive/about) on how to use it.

## Developing with Base and Drive

During development, you can share data between your local environment and your [project](/docs/en/basics/projects) in Space.

There is two ways to setup the Deta SDK to access the Bases & Drives of your project:

### Automatic setup

The Space CLI can automatically connect your local development environment with your Space Base & Drive using the `space dev` command.

More information on how to use the `space dev` command can be found in the in the [Developing Locally](/docs/en/basics/local) section.


### Manual setup

If the automatic set up does not work for your use-case, you can manually set up your local development environment by generating a data key from the "Data" tab on the "Develop" page, inside your Builder project.

If you are using an official Deta SDK, add this as an environment variable inside your dev environment:

```bash
DETA_PROJECT_KEY=<put_your_project_key_here>
```

The Deta SDKs will detect this key to access your development Bases and Drives.

If you are not using a Deta SDK, pass this Project Key using the `X-API-Key` header with the [Base HTTP API](/docs/en/reference/base/HTTP#auth) or [Drive HTTP API](/docs/en/reference/drive/HTTP#auth).

## Viewing data

Base and Drive both come with a UI where you can easily see, add, update and delete files and data. This UI is available inside Builder in the "Develop" tab under "Project Resources" and also through your Builder instance on your Canvas (click the `...` and then `View Data`).

For detailed guides, see the specific documentation for [Base UI](/docs/en/reference/base/base_ui) and [Drive UI](/docs/en/reference/drive/drive_ui).
# extending_apps.md

### API Keys

`API Keys` provide you with programmatic access to an installed app's HTTP APIs. Provided a developer has enabled API Keys, you can generate them from the "API Keys" tab in your "Settings" of the installed app.

The keys need to be provided under the `X-Space-App-Key` (case insensitive) header when making HTTP requests to the app.

Follow the specific documentation provided by the developer of the app on how to these APIs.


### Data Keys

`Data Keys` provide you direct access to data created by your installed Space apps. They allow you to read and manipulate your Space apps' data, and can be used to build custom integrations without explicit options (such as API Keys) from the app developer.

However, manipulating the data can result in breaking your app so use the keys with caution.

To generate Data Keys, go to the "Data Keys" tab in your "Settings" for your installed apps.

To use a Data Key, you can provide the key when initializing your `Deta` instance if you are using our official Deta SDKs.

An example in python:

```py
from deta import Deta

deta = Deta('your_data_key_here')
```

You need to create two different instances of `Deta` if you are connecting with two different apps.
Do not overwrite your `DETA_PROJECT_KEY` environment variable with this key, especially if you are building an integration from within a Space app.

If you are not using a Deta SDK, pass this key using the `X-API-Key` header with the [Base HTTP API](/docs/en/reference/base/HTTP#auth) or [Drive HTTP API](/docs/en/reference/drive/HTTP#auth). You need two separate HTTP clients if you want to connect to the data of two different apps.
# app_icon.md

## Make your app look good with a few tricks


The app icon is a crucial aspect for any Space App, as it influences its discoverability and overall perception. As the first visual element users encounter when browsing the Discovery Page, it can make or break a user's decision to download the app.

## Best Practices

Creating an effective app icon requires careful consideration of its display format, as it will be presented as a rectangle with a prominent rounded corner in the top-left (7x the size of a typical corner radius). To ensure optimal appearance, the icon should be designed as a full-bleed square image. Space applies a mask that seamlessly adapts the icon's corners to match the overall aesthetic.

An engaging and striking app icon can be achieved by incorporating a background of solid color or gradient with ample space around the centre. The centre should prominently feature the app's logo, which can be in 3D for added visual appeal. It is generally recommended to avoid using text in the icon, as it can make the icon appear cluttered and difficult to read.

The guidelines also include a safe zone where the logo should be placed to ensure it is always visible and not obscured by any elements like the top-left corner radius, app options menu in the bottom-right, or updates/notifications in the top-right.

![Safe Zone](/docs_assets/app_icon/guidelines.png)

This is the preferred and optimal size (512x512px). The centre place is where the logo should be, (196x196px).

![Size](/docs_assets/app_icon/size.png)

It is essential to avoid mimicking UI elements from your app in the design of your icon. Graphical images are usually preferred over photos as they tend to be more visually appealing and distinctive. Additionally, replicating first-party apps such as the Builder Icon is strictly prohibited, as it can cause confusion and may result in the removal of your app from the Discovery Page.

When selecting colors for the icon, it is important to ensure consistency with the overall design of the app to create a cohesive visual experience. Utilizing the same color scheme in both the icon and the app can aid users in easily identifying and remembering the app.

A well-chosen app name is short and memorable. This not only makes it easy for users to recall the app, but also ensures the name is clearly visible. A safe limit for text in the name is 10 characters, as longer names may be truncated depending on the letter width. Therefore, it is essential to keep the name concise.

We created an [Icon Tester](https://www.figma.com/community/file/1206563671424898764) for you to use in Figma. Use it to check if your icon is following the guidelines.

Here's a quick demo of how it works:
![Demo](/docs_assets/app_icon/demo.gif)

In order to enhance the Discovery App page, it is reccomened to extract the dominant color from the app icon and apply it as the theme color. This can be achieved by adding the following code snippet to the HTML document:

```html
<meta name="theme-color" content="#4285f4" />
```

This meta tag sets the browser theme color for the app, which is used by some browsers to customise the appearance of the browser UI elements, such as the address bar and the task switcher.
# local.md

## Starting a Development Server

Once you've created a Space project, you can start developing your app locally using the [Space CLI's](https://deta.space/docs/en/reference/cli) `space dev` command.

```bash
space dev
```

Behind the scenes, the Space CLI is:

- Generating and injecting a [Data Key](https://deta.space/changelog/post-6) so you can use the [Deta SDK](https://deta.space/docs/en/basics/data)
- Running each of your Micros in a separate process
- Exposing all of your Micros through a single entrypoint (following the routing in your Spacefile)

If you want to open the app in your browser automatically after starting your Micros, use the `--open` flag.

> Any data you save to Base or Drive using the Deta SDK will be stored in your Builder project. You can view and edit the data using the UI in the "Data" tab of the "Develop" page in your Builder project.

You can customize the development command for each Micro in your `Spacefile` using the `dev` key.

```yaml
v: 0
micros:
  - name: client
    src: ./client
    engine: svelte
    primary: true
    path: client
  - name: api
    src: ./api
    engine: nodejs16
    dev: nodemon index.js # start the micro in development mode
    path: api
```

The specified `dev` commands need to start a web server that listens on the port specified with the `PORT` environment variable. This way the CLI can properly forward requests to the Micro.

You can find instructions on how to setup the right `dev` command for each engine in the "Quickstart Guides".

## Advanced Usage

If you want to have more control over the development process, you can also split the `dev` command into two parts:

- First, start Micros individually using the `space dev up` command
- Then, start the reverse proxy using the `space dev proxy`

For our example above, this would look like this:

```bash
# Start the Micros individually
space dev up client
space dev up api

# Start the reverse proxy
space dev proxy
```

Some use cases for this approach include:

- Running each Micro in a separate terminal window
- Integrating Micros with other development tools (ex: vscode tasks)

The `space dev` command is just a shortcut for the combination of `space dev up` and `space dev proxy`.

## Running scheduled actions manually

You can trigger [scheduled actions](/docs/en/basics/micros#scheduled-actions) from your local development server by using the `space dev trigger` command.

First make sure you have defined a scheduled action in your Spacefile and set up the right handler in your Micro:

```yaml
v: 0
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

After starting your development server using either `space dev` or `space dev up`, you can trigger the action manually using the `space dev trigger` command:

```bash
space dev trigger cleanup
```

This will call your local action handler with a mock payload and print the returned response to your console.

## Running commands in the context of your project

If you don‚Äôt want to specify a dev command in your Spacefile or you want to run a one-off script while still benefitting from the automatic Base & Drive SDK setup you can wrap your command a `space exec` call:

```bash
# Run a command in the context of your project
space exec --project <project-id> -- npm run init-deta-base.py
```

If you run the command from a directory that is linked to a space app, you can omit the `--project` flag.

Some use cases include:

- testing Base & Drive locally
- pre-filling your projects Bases & Drives with data
- programmatically interacting with Base & Drive
- ‚Ä¶anything you can think of!
# teletype.md

# spacefile.md

## What's the Spacefile?

The `Spacefile` file contains the configuration of your app and is used by Deta Space to understand what your app looks like and how to run it.

The Spacefile file must be named `Spacefile` and needs to be in the root directory of your project. It uses a syntax similar to YAML, if you're new to YAML and want to learn more, see "[Learn YAML in Y minutes.](https://learnxinyminutes.com/docs/yaml/)".

You can use the [`space new`](/docs/en/reference/cli#space-new) command to let the [Space CLI](/docs/en/reference/cli) automatically create the `Spacefile` for you.

Here is an example `Spacefile`:

```yaml
v: 0
icon: ./icon.png
app_name: "My App"
micros:
  - name: python-app
    src: ./src/python
    engine: python3.9
    primary: true

  - name: custom-app
    src: ./src/custom
    engine: custom
    commands:
      - go get
      - go build main.go
    run: ./main
    include:
      - main
```

> To customize the appearence of your app on [Discovery](/discovery) you can add a  [`Discovery.md`](/docs/en/reference/discovery) file to your project.

## Options

Here are all the options supported by the `Spacefile`.

### `v` (version)

**Required**

The first key/value pair in your `Spacefile` should be the Spacefile version. The latest version at the moment is `0`.

```yaml
v: 0
```

### `icon`

*Optional*


Use `icon` to specify a path to an image file to use as your app's icon. The icon will be used wherever your app is displayed (e.g. the Canvas).

The path should be relative to your `Spacefile` and needs to point to a file inside your project's directory.

The image needs to be a PNG or WebP file of 512x512 pixels.

```yaml
icon: src/static/icon.png
```

### `app_name`

*Optional*

Use `app_name` to specify a name for your app. This name will be used wherever your app is displayed (e.g. the Canvas).

If it is not provided, `app_name` will fallback to your project's name.

The name can has a maximum of 12 characters. We recommend not exceeding 7 characters for optimal visibility across different screen sizes.

```yaml
app_name: My App
```

### `micros`

**Required**

The `micros` object is arguably the most important section in the `Spacefile`. It lists all the micros your app uses and configures each one individually.

#### `name`

**Required**

Each micro needs to have a unique `name` and **must follow the following rules:**

- can only contain alphanumeric characters and hyphen
- start with alphanumeric characters

```yaml
micros:
  - name: api
```

#### `src`

**Required**

Relative path to the root directory of the micro.

Each micro should be in its own directory which needs to contain all files required for the Micro to run.

```yaml
micros:
  - name: api
    src: ./api/
```

#### `engine`

**Required**

Runtime for the Micro, supported values:

- `static`
- `react`
- `svelte`
- `vue`
- `next`
- `nuxt`
- `svelte-kit`
- `python3.9`
- `python3.8`
- `nodejs16`
- `custom`

Example:

```yaml
micros:
  - name: api
    src: ./api/
    engine: nodejs16
```

Some engines require additional configuration. Refer to the "Quickstart Guides" section for more information about specific engines.

#### `primary`

**Required if your Spacefile contains more than one Micro**

If your app contains more than one Micro, use `primary` to identify which Micro should be used as the entry point of your application. The primary Micro will receive all requests made to your application which are not under another micro's path.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: svelte
    primary: true

  - name: backend
    src: ./backend/
    engine: nodejs16
```

#### `path`

*Optional*

If your app contains more than one Micro, use `path` to specify under which path relative to the hostname a Micro should receive requests. Requests are proxied so you your Micro will receive them at the root, no need to prefix your routes with the given Micro path.

If the `path` is missing, the path will fall back to the Micro `name`.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: svelte
    primary: true

  - name: backend
    src: ./backend/
    engine: nodejs16
    path: api
```

#### `serve`

*Required for static Micros*

Use `serve` to specify which directory should be served for your static Micro. All the files and directories inside the specified directory will be served relative to your Micro's path.

This option can only be used for Micro's with the `static` engine or engines based on it like `vue`, `react` and `svelte`.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: static
    serve: dist/
```

#### `commands`

*Optional*

Use `commands` to specify a set of commands to run before packaging the Micro.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    commands:
      - go get
      - go build main.go
```

#### `include`

*Optional*

Use `include` to specify which files and directories in your Micro's `src` should be part of the final app package. If `include` is used, everything not part of it will be ignored and won't be part of your app. You can specify multiple files and directories.

If your Micro uses a build step, `include` can be used to tell Space to only include the build output in your final app and ignore your source code and other unnecessary files.

```yaml
micros:
  - name: api
    src: ./api/
    engine: nodejs16
    commands:
      - npm run build
    include:
      - build/
      - images/
```

#### `run`

*Optional*

Use `run` to specify a command which starts your Micro. For the Micro to receive requests, it needs to listen on the port specified in the environment variable `PORT`.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    run: ./main
```

#### `dev`

Use `run` to specify a command which starts your Micro in **development** mode. This command will be used to start your micro when you run `deta dev`.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    run: ./main
    dev: go run main.go
```

#### `presets`

*Optional*

Specify different presets to use with your Micro.

##### `env`

*Optional*

Use the `env` preset to specify environment variables that the user can set for a Micro.

- `name` : environment variable name or key
- `description` : human friendly description
- `default` : default value for the variable

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      env:
        - name: SECRET_MESSAGE
          description: Secret message only available to this Micro
          default: "deta is cool"
```

More information on the `env` preset can be found in the [Micro Basics](/docs/en/basics/micros#custom-variables).

##### `api_keys`

*Optional*

Use the `api_keys` preset to enable the use of API keys to access a private routes of a Micro.

The user of your app will be able to generate API keys in the app settings and can use them in requests to a Micro using the `X-Space-App-Key` HTTP header.

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      api_keys: true
```

More information on API Keys can be found in the [Micro Basics](/docs/en/basics/micros#api-keys).

#### `public_routes`

*Optional*

Use `public_routes` to define which paths of your Micro should be available to the public. These routes will not be protected behind auth.

```yaml
micros:
  - name: backend
    src: backend
    engine: python3.9
    public_routes:
      - "/test" # exact match
      - "/public/*" # wildcards
      - "/api/*/docs" # wildcards can be placed anywhere
```

More information on public routes can be found in the [Micro Basics](/docs/en/basics/micros#public-routes).

#### `actions`

*Optional*

Specify actions that perform certain tasks inside your app on a specific trigger like a schedule.

```yaml
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

An action is compromised of the following fields:

- `id` (required): a unique identifier for the action (needs to be unique across the app)
- `name` (required): a human readable name for the action (needs to be unique across the app)
- `description` (optional): a human readable description for the action (max 142 chars)
- `trigger` (required): what triggers the action. Needs to be set to `schedule`.
- `default_interval` (required): interval with which the schedule will run at ([supported intervals](/docs/en/basics/micros#scheduled-actions))

When an action runs, a `POST` request containing the following body will be sent to the path `/__space/v0/actions` on your Micro:

```json
{
  "event": {
    "id": "cleanup",
    "trigger": "schedule"
  }
}
```

It is up to you to handle the request and run whatever logic you need.

Each scheduled action needs to have a default interval at which it runs at. Space currently supports two types of intervals:

##### Rates

You can define the rate at which an action should run. It is comprised of a value and unit.

- `value`: is a non-zero positive integer
- `unit`: unit of time, can be `minute`, `minutes`, `hour`, `hours`, `day`, `days`. If the value is `1` the unit must be `minute`, `hour` or `day`.

**Start Time**

The schedule starts from the time of installation rounded up to:

- `minute` ‚Üí next minute
- `hour` ‚Üí next nearest hour
- `day` ‚Üí next day at `00:00`

**Examples**

- `1 minute`: Run every minute
- `2 hours`: Run every two hours
- `5 days`: Run every five days

##### Cron Expressions

Cron expressions allow you more flexibility and precision when scheduling a task. Cron expressions have five required fields, which are separated by white space and run based on UTC.

| Field        | Values                            | Wildcards |
|--|--|
| Minute       | 0-59                              |  ,-*/     |
| Hour         | 0-23                              |  ,-*/     |
| Day-of-month | 1-31                              |  ,-*/     |
| Month        | 1-12 or jan-dec                   |  ,-*/     |
| Day-of-week  | 0-7 (0 or 7 is Sunday) or sun-sat |  ,-*      |

**Wildcards**

- The , (comma) wildcard includes additional values. In the Month field, jan,feb,mar would include January, February, and March.

- The - (dash) wildcard specifies ranges. In the Day field, 1-15 would include days 1 through 15 of the specified month.

- The * (asterisk) wildcard includes all values in the field. In the Hours field, * would include every hour. You cannot use * in both the Day-of-month and Day-of-week fields. If you use it in one, you must use ? in the other.

- The / (forward slash) wildcard specifies increments. In the Minutes field, you could enter 1/10 to specify every tenth minute, starting from the first minute of the hour (for example, the 11th, 21st, and 31st minute, and so on).

**Limits**

- You can't specify the Day-of-month and Day-of-week fields in the same cron expression. If you specify a value (or a *) in one of the fields, you must use a * (asterisk) in the other.

- Cron expressions that lead to rates faster than 1 minute are not supported.

**Examples**

- `0 10 * * *` : Run at 10:00 am (UTC) every day
- `15 12 * * *` : Run at 12:15 pm (UTC) every day
- `0 18 * * mon-fri` : Run at 6:00 pm (UTC) every Monday through Friday
- `0 8 1 * *` : Run at 8:00 am (UTC) every 1st day of the month
- `0/15 * * * *` : Run every 15 minutes
- `0/5 8-17 * * mon-fri` : Run every 5 minutes Monday through Friday between 8:00 am and 5:55 pm (UTC)


More information on scheduled actions and how to use them in your app can be found in the [Micro Basics](/docs/en/basics/micros#scheduled-actions).
# cli.md

## `space help`

Shows the help page

## `space login`

You can use `space login` to login to Space. The CLI will prompt you for an access token which it will use for future executions. Refer to the [Setting up the CLI](/docs/en/basics/cli#authentication) section for more details.

```bash
space login
```

## `space new`

You can use `space new` to create new projects.

Optional args:

- `-n, --name` string: name of the project
- `-d, --dir` string: where is the project (default ‚Äú./‚Äù)
- `-b, -‚Äîblank` bool: use this flag to create a blank project and ignore all the prompts

```bash
space new
```

## `space dev`

You can use `space dev` to start a local development server for your project. The cli will start one process for each of your micros, then expose a single enpoints for your space app.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-H, --host` string: host to run dev server on (default ‚Äúlocalhost‚Äù)
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev up`

You can use `space dev up` to start a single micro for local development.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev proxy`

You can use `space proxy` to start a reverse proxy for your micros. The micros will be automatically discovered and proxied to.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-H, --host` string: host to run dev server on (default ‚Äúlocalhost‚Äù)
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev trigger`

You can use `space trigger` to manually trigger action. Make sure that the corresponding micro is running before triggering the action.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project

## `space push`

You can use `space push` to push your changes to Space and create a new revision. Space will automatically update your Builder instance with the new revision.

Optional args:

- `-d, --dir`   string: src of project to push (default "./")
- `-i, --id`    string: project id of project to push
- `-t, --tag`   string: tag to identify this push
- `-o, --open`  boolean: open builder instance/project in browser after push
- `--skip-logs` boolean: skip following logs after push

```bash
space push
```

If you don't want to follow the logs of the build and update, pass the `--skip-logs` argument which will exit the process as soon as the build is started instead of waiting for it to finish.

Tip: you can use the [`.spaceignore` file](/docs/en/basics/revisions#ignoring-files-and-directories) to exclude certain files and directories from being uploaded during push.

## `space release`

You can use `space release` to create new releases out of revisions.

Optional args:

- `-d, --dir` string: src of project to release (default "./")
- `-c, --confirm` boolean: confirm all prompts and release latest revision
- `-i, --id` string: project id of an existing project
- `-r, --rid` string: revision id for release
- `-l, --listed` boolean: enable listing on Discovery
- `-n, --notes` provide release notes via interactive prompt
- `--notes="<RELEASE_NOTES>"`: provide release notes directly
- `-v, --version` string: version for the release

```bash
space release
```

## `space link`

You can use `space link` to link a directory with a existing project.

Optional args:

- `-d, --dir` string: src of project to link (default "./")
- `-i, --id` string: project id of project to link

```bash
space link
```

## `space exec`

You can use `space exec` to run a command in the context of your project. The project key will be automatically injected into the environment.

Required args:

- `-p, --project`   string: id of the project

## `space open`

You can use `space open` to open your local project in the Builder UI on [deta.space](https://deta.space).

Optional args:

- `-d, --dir` string: directory of project to open (default "./")
- `-i, --id` string: project id of project to open

```bash
space open
```

## `space validate`

You can use `space validate` to validate your [Spacefile](/docs/en/reference/spacefile/) and check for errors.

Optional args:

- `-d, --dir` string: src of project to validate (default "./")

```bash
space validate
```
# discovery.md

## What's the Discovery.md file?

The `Discovery.md` file allows you to customize the presentation of your Space app on [Discovery](/discovery) - Space's app marketplace.

Write Markdown inside the `Discovery.md` file to explain what your app does, what makes it unique, and its features & functionality. You can think of it as your app's `README` for Deta Space.

In addition to the Markdown description, the `Discovery.md` file supports a Frontmatter section where you can specify metadata like your app's title, its tagline, a theme color and links to a Git repository & an app's website.

Here is an example `Discovery.md` file:

```md


Your apps, your data. Your *personal cloud computer*.

Space comes with:

- Fully managed servers
- Fully managed security
- Fully managed data
- Fully managed payments
```

You can see that the metadata is separate from the Markdown content by two lines of 3 dashes (``) is the Frontmatter section.

> The `Discovery.md` file is different from the [Spacefile](/docs/en/reference/spacefile). The `Discovery.md` file _only_ affects how your app appears on Deta Discovery. It is meant for marketing purposes, whereas the `Spacefile` is used for technical purposes: it tells Space how to run your app and what it looks like once it's installed.

The `Discovery.md` file is uploaded during `space push` and is part of a [revision](/docs/en/basics/revisions#whats-a-revision). When you create a release out of a revision the revision's `Discovery.md` file will be used.

## Options

There are no required options in the `Discovery.md` section, you can pick and choose what to use. We recommend that your app has at least a title and a short Markdown description explaining what it does.

**Note:** To change your app's name or icon you need to modify its [Spacefile](/docs/en/reference/spacefile) since these are used by Space for technical purposes, not just its marketing on Discovery.

Here are all the options supported by `Discovery.md`:

### `title`

Use `title` to give your app a friendly and descriptive name on Discovery.

This is different from the app name used once the app is installed. You can change that using the [`app_name`](/docs/en/reference/spacefile#app_name) option in the [Spacefile](/docs/en/reference/spacefile). The `title` will only be used on Discovery.

Choose a simple and memorable title and try to stand out. Avoid names that use generic terms or are too similar to existing app names.

The `title` needs to start with your app's name and can only have a maximum of `45` characters. We recommend the `title` follows the following format: `App Name: Short Description`.

Here's an example:

```yaml
title: "Space: The Personal Cloud"
```

### `tagline`

Use the `tagline` to provide a short description of your app. This will be shown across Discovery on both the app's page and in featured sections or search.

Your app‚Äôs `tagline` is intended to summarize your app in a concise phrase. Avoid generic descriptions and instead highlight features or typical uses of your app.

The `tagline` can be a maximum of `69` characters.

Here's an example:

```yaml
tagline: "Your own personal computer in the cloud: private, secure & always online."
```

### `theme_color`

Use `theme_color` to style the color of your app's Discovery page to match your app.

`theme_color` only supports hex color values.

```yaml
theme_color: "#f26daa"
```

### `git`

Use `git` to link to your app's Git repository, so users can view its source and can contribute to your app.

You can provide any valid Git URL including a link to a GitHub or GitLab repository.

```yaml
git: "https://github.com/deta/deta"
```

### `homepage`

Use `homepage` to link to an abitrary URL related to your app. This could be your app's marketing page or a documentation website for example.

```yaml
homepage: "https://deta.space"
```

## Markdown content

The main section in the `Discovery.md` file is the Markdown content. It will be displayed on your app's Discovery page similar to a README.

You can use it to describe what your app does in more detail, what makes it unique and/or highlight its features and functionality. The ideal description is a concise, informative paragraph followed by a short list of main features.

The Markdown description has a limit of `4250` characters.

Here's an example:

```md
Your apps, your data. Your *personal cloud computer*.

Space comes with:

- Fully managed servers
- Fully managed security
- Fully managed data
- Fully managed payments
```

### Supported Syntax

The `Discovery.md` file currently does not support the full Markdown spec. You cannot use the following:

- Images (in the future we will add support for app screenshots)
- HTML
- h1 (`#`) headings (they will be converted to h2)
# HTTP.mdx

## General & Auth

> You can get your **Project Key** and your **Project ID** of your Project in [Builder](https://deta.space/builder). You need these to talk with the Deta API.

> ‚ÑπÔ∏è Base currently supports **maximum 16 digit numbers** (integers and floating points), please store larger numbers as a string.

### Root URL
This URL is the base for all your HTTP requests:

**`https://database.deta.sh/v1/{project_id}/{base_name}`**

> The `base_name` is the name given to your database. If you already have a **Base**, then you can go ahead and provide it's name here. Additionally, you could provide any name here when doing any `PUT` or `POST` request and our backend will automatically create a new base for you if it does not exist. There is no limit on how many "Bases" you can create.

### Auth
A **Project Key** _must_ to be provided in the request **headers** as a value for the `X-API-Key` key for authentication. This is how we authorize your requests.

Example `'X-API-Key: a0abcyxz_aSecretValue'`.

### Content Type

We only accept JSON payloads. Make sure you set the headers correctly: `'Content-Type: application/json'`

## Endpoints

### Put Items

**`PUT /items`**

Stores multiple items in a single request. This request overwrites an item if the key already exists.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type    | Description                              |
|--|||
| `items`      | Yes      | `array` | An array of items `object` to be stored. |


    ##### Example

    ```json
    {
       // array of items to put
       "items": [
            {
                "key": {key}, // optional, a random key is generated if not provided
                "field1": "value1",
                // rest of item
            },
            // rest of items
        ]
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `207 Multi Status`

    ```js
    {
        "processed": {
            "items": [
                // items which were stored
            ]
        },
        "failed": {
           "items": [
               // items failed because of internal processing
           ]
        }
    }
    ```

    ##### Client errors

    In case of client errors, **no items** in the request are stored.

    ##### `400 Bad Request`

    ```js
    {
        "errors" : [
           // error messages
        ]
    }
    ```



    Bad requests occur in the following cases:
    - if an item has a non-string key
    - if the number of items in the requests exceeds 25
    - if total request size exceeds 16 MB
    - if any individual item exceeds 400KB
    - if there are two items with identical keys
  </Fragment>

</RequestTabs>




### Get Item

**`GET /items/{key}`**

Get a stored item.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| URL Parameter | Required | Type     | Description                                        |
|-|-|
| `key`         | Yes      | `string` | The key (aka. ID) of the item you want to retrieve |
  </Fragment>

  <Fragment slot="response">
    ##### `200 OK`

    ```js
    {
      "key": {key},
      // the rest of the item
    }
    ```

    ##### `404 Not Found`
    ```js
    {
      "key": {key}
    }
    ```
  </Fragment>

</RequestTabs>



### Delete Item

**`DELETE /items/{key}`**

Delete a stored item.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| URL Parameter | Required | Type     | Description                                       |
|-||
| `key`         | Yes      | `string` | The key (aka. ID) of the item you want to delete. |
  </Fragment>

  <Fragment slot="response">
    The server will always return `200` regardless if an item with that `key` existed or not.

    ##### `200 OK`

    ```json
    {
      "key": {key}
    }
    ```
  </Fragment>

</RequestTabs>



### Insert Item

**`POST /items`**

Creates a new item only if no item with the same `key` exists.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type     | Description            |
|--|-||
| `item`       | Yes      | `object` | The item to be stored. |

    ##### Example

    ```json
    {
        "item": {
            "key": {key}, // optional
            // rest of item
        }
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `201 Created`

    ```json
    {
      "key": {key}, // auto generated key if key was not provided in the request
      "field1": "value1",
      // the rest of the item
    }
    ```

    ##### Client errors

    ##### `409 Conflict` (if key already exists)

    ```json
    {
      "errors": ["Key already exists"]
    }
    ```

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
         // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if the item has a non-string key
    - if size of the item exceeds 400KB
  </Fragment>

</RequestTabs>



### Update Item

**`PATCH /items/{key}`**

Updates an item only if an item with `key` exists.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type              | Description                                                          |
|--|-|
| `set`        | no       | `object`          | The attributes to be updated or created.                             |
| `increment`  | no       | `object`          | The attributes to be incremented. Increment value can be negative.   |
| `append`     | no       | `object`          | The attributes to append a value to. Appended value must be a list.  |
| `prepend`    | no       | `object`          | The attributes to prepend a value to. Prepended value must be a list.|
| `delete`     | no       | `string array`    | The attributes to be deleted.                                        |

    ##### Example

    If the following item exists in the database

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the request

    ```json
    {
       "set" : {
         // change ages to 33
         "profile.age": 33,
         // change active to true
         "profile.active": true,
         // add a new attribute `profile.email`
         "profile.email": "jimmy@deta.sh"
       },

       "increment" :{
         // increment purchases by 2
         "purchases": 2
       },

       "append": {
         // append to 'likes'
         "likes": ["ramen"]
       },

       // remove attributes 'profile.hometown' and 'on_mobile'
       "delete": ["profile.hometown", "on_mobile"]
    }
    ```

    results in the following item in the database:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes": ["anime", "ramen"],
      "purchases": 3
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `200 OK`

    ```json
    {
       "key": {key},
       "set": {
         // identical to the request
       },
       "delete": ["field1", ..] // identical to the request
    }
    ```

    ##### Client errors

    ##### `404 Not Found` (if key does not exist)

    ```json
    {
      "errors": ["Key not found"]
    }
    ```

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
         // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if you're updating or deleting the `key`
    - if `set` and `delete` have conflicting attributes
    - if you're setting a hierarchical attribute but an upper level attribute does not exist, for eg. `{"set": {"user.age": 22}}` but `user` is not an attribute of the item.
  </Fragment>

</RequestTabs>



### Query Items

**`POST /query`**

List items that match a [query](/docs/en/reference/base/queries).

<RequestTabs>

  <Fragment slot="request">
| JSON Payload    | Required | Type     | Description                                    |
|-|---|
| `query`         | No       | `list`   | list of a [query](/docs/en/reference/base/queries)|
| `limit`         | No       | `int`    | no of items to return. min value 1 if used     |
| `last`          | No       | `string` | last key seen in a previous paginated response |


    ##### Example

    ```json
    {
       "query": [
            // separate objects in the list are ORed
            // query evaluates to list all users whose hometown is Berlin and is active OR all users who age less than 40
            {"user.hometown": "Berlin", "user.active": true},
            {"user.age?lt": 40}
       ],
       "limit": 5,
       "last": "afsefasd" // last key if applicable
    }
    ```
  </Fragment>

  <Fragment slot="response">
    The response is paginated if data process size exceeds 1 MB (before the query is applied) or the total number of items matching the `query` exceeds the `limit` provided in the request.

    For paginated responses, `last` will return the last key seen in the response. You must use this `key` in the following request to continue retreival of items. If the response does not have the `last` key, then no further items are to be retreived.

    > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
    >
    > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

    ##### `200 OK`

    ```json
    {
        "paging": {
            "size": 5, // size of items returned
            "last": "adfjie" // last key seen if paginated, provide this key in the following request
        },
        "items": [
           {
             "key": {key},
             // rest of the item
           },
           // rest of the items
       ]
    }
    ```

    ##### Client Errors

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
        // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if a query is made on the `key`
    - if a query is not of the right format
    - if `limit` is provided in the request and is less than 1
  </Fragment>

</RequestTabs>



## Issues

If you run into any issues, consider reporting them in our [Github Discussions](https://github.com/orgs/deta/discussions).# async_sdk.md

## Installing

```
pip install deta[async]==1.1.0a2
```

## Instantiating

```py
from deta import Deta

# initialize with a project key
# you can also init without specfying the project key explicitly
# the sdk looks for the DETA_PROJECT_KEY env var in that case
deta = Deta("project_key")

# create an async base client
async_db = deta.AsyncBase("base_name")
```

## Methods

The **`AsyncBase`** class offers the same API to interact with your Base as the **`Base`** class:

### Put

```py
put(
	data: typing.Union[dict, list, str, int, float, bool],
	key: str = None,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime]
)
```

- **data** (required): The data to be stored.
- **key** (optional): The key to store the data under. It will be auto-generated if not provided.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](#./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def put_item():
	item = {"msg": "hello"}
	await async_db.put(item, "test")
	print("put item:", item)

	# put expiring items
	# expire item in 300 seconds
	await async_db.put(item, expire_in=300)

	# with expire at
	expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
	await async_db.put({"name": "max", "age": 28}, "max28", expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(put_item())
```

### Get

```py
get(key: str)
```

- **key** (required): The key of the item to be retrieved.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def get_item():
	item = await async_db.get("my_key")
	print("got item:", item)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(get_item())
```

### Delete

```py
delete(key: str)
```

- **key** (required): The key of the item to delete.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def del_item():
	await async_db.delete("my-key")
	print("Deleted item")

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(del_item())
```

### Insert

`insert` is unique from `put` in that it will raise an error if the `key` already exists in the database, whereas `put` overwrites the item.

```py
insert(
	data: typing.Union[dict, list, str, int, float, bool],
	key: str = None,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **data** (required): The data to be stored.
- **key** (optional): The key to store the data under, will be auto generated if not provided.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def insert_item():
	item = {"msg": "hello"}
	await async_db.insert(item, "test")
	print("inserted item:", item)

	# put expiring items
    # expire item in 300 seconds
    await async_db.insert(item, expire_in=300)

    # with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    await async_db.insert({"name": "max", "age": 28}, "max28", expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(insert_item())
```

### Put Many

```py
put_many(
	items: typing.List[typing.Union[dict, list, str, int, bool]],
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **items** (required): list of items to be stored.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def put_items():
	items = [{"key": "one", "value": 1}, {"key": "two", "value": 2}]
	await async_db.put_many(items)
	print("put items:", items)

	# put with expiring items
	# expire in 300 seconds
	await async_db.put_many(items, expire_in=300)

	# with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    await async_db.put_many(items, expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(put_items())
```

### Update

```py
update(
	updates:dict,
	key:str,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **updates** (required): A dict describing the updates on the item, refer to [updates](/docs/en/reference/base/sdk#update) for more details.
- **key** (required): The key of the item to update.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def update_item():
	updates = {"profile.age": 20, "likes": async_db.util.append("ramen")}
	await async_db.update(updates, "jimmy")
	print("updated user jimmy")

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(update_item())
```

### Fetch

**`fetch(query=None, limit=1000, last=None)`**

- **query** : a [query or a list of queries](/docs/en/reference/base/queries)
- **limit** : the limit of the number of items you want to recieve, min value `1` if used.
- **last**: the last key seen in a previous paginated response.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def fetch_items():
	query = {"profile.age?gt": 20}
	res = await async_db.fetch(query)
	print("fetched items": res.items)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(fetch_items())
```


# sdk.mdx

## Installing

<br />
<LangTabs>
  <Fragment slot="js">
  Using NPM:

    ```shell
    npm install deta
    ```

    Using Yarn:
    ```shell
    yarn add deta
    ```

  </Fragment>
  <Fragment slot="py">
  ```shell
	pip install deta
	```
  </Fragment>
  <Fragment slot="go">
  ```shell
	go get github.com/deta/deta-go
	```
  </Fragment>
</LangTabs>

> If you are using the Deta SDK within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your dependencies file (`package.json` or `requirements.txt`) to install the latest sdk version.



## Instantiating

To start working with your Base, you need to import the `Deta` class and initialize it with a **Project Key**. Then instantiate a subclass called `Base` with a database name of your choosing.

Deta Bases are created for you automatically when you start using them.

<br />
<LangTabs>

  <Fragment slot="js">
    ```js
    const { Deta } = require('deta'); // import Deta

    // Initialize with a Project Key
    const deta = Deta('project key');

    // This how to connect to or create a database.
    const db = deta.Base('simple_db');

    // You can create as many as you want without additional charges.
    const books = deta.Base('books');
    ```

    > If you are using Deta Base within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), the **Deta SDK** comes pre-installed and a valid project key is pre-set in the Micro's environment. There is no need to install the SDK or pass a key in the initialization step.
    > ```js
    > const { Deta } = require('deta');
    >
    > const deta = Deta();
    > ```

    > If you are using the `deta` npm package of `0.0.6` or below, `Deta` is the single default export and should be imported as such.
    > ```js
    > const Deta = require('deta');
    > ```
  </Fragment>

  <Fragment slot="py">
    ```py
    from deta import Deta  # Import Deta

    # Initialize with a Project Key
    deta = Deta("project key")

    # This how to connect to or create a database.
    db = deta.Base("simple_db")

    # You can create as many as you want without additional charges.
    books = deta.Base("books")

    ```

    > If you are using Deta Base within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), the **Deta SDK** comes pre-installed and a valid project key is pre-set in the Micro's environment. There is no need to install the SDK or pass a key in the the initialization step.
    > ```py
    > from deta import Deta
    >
    > deta = Deta()
    > ```
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        func main() {

          // initialize with project key
          // returns ErrBadProjectKey if project key is invalid
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          // initialize with base name
          // returns ErrBadBaseName if base name is invalid
          db, err := base.New(d, "base_name")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
            return
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        ```go
        import (
          "fmt"
          "github.com/deta/deta-go"
        )

        func main(){
          // initialize with project key
          // returns ErrBadProjectKey if project key is invalid
          d, err := deta.New("project_key")
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          // initialize with base name
          // returns ErrBadBaseName if base name is invalid
          db, err := d.NewBase("base_name")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
            return
          }
        }
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

</LangTabs>

> ‚ö†Ô∏è Your project key is confidential and meant to be used by you. Anyone who has your project key can access your database. Please, do not share it or commit it in your code.



## Using

Deta's **`Base`** class offers the following methods to interact with your Deta Base:

[**`put`**](#put) ‚Äì Stores an item in the database. It will update an item if the key already exists.

[**`insert`**](#insert) ‚Äì Stores an item in the database but raises an error if the key already exists. (2x slower than `put`).

[**`get`**](#get) ‚Äì Retrieves an item from the database by its key.

[**`fetch`**](#fetch) ‚Äì Retrieves multiple items from the database based on the provided (optional) filters.

[**`delete`**](#delete) ‚Äì Deletes an item from the database.

[**`update`**](#update) ‚Äì Updates an item in the database.



##### Storing Numbers

> ‚ö†Ô∏è Base currently supports **maximum 16 digit numbers** (integers and floating points), please store larger numbers as a string.



### Put

`put` is the fastest way to store an item in the database.

If an item already exists under a given key, put will replace this item.

In the case you do not provide us with a key, we will auto generate a 12 char long string as a key.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async put(data, key = null, options = null)`**

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` and `array`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `string`, `null` or `undefined`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull put operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    ##### Code Example

    ```js
    const Deta = require('deta');

    const deta = Deta("project key");
    const db = deta.Base("simple_db");

    // store objects
    // a key will be automatically generated
    await db.put({name: "alex", age: 77})
    // we will use "one" as a key
    await db.put({name: "alex", age: 77}, "one")
    // the key could also be included in the object itself
    await db.put({name: "alex", age: 77, key:"one"})

    // store simple types
    await db.put("hello, worlds")
    await db.put(7)
    // "success" is the value and "smart_work" is the key.
    await db.put("success", "smart_work")
    await db.put(["a", "b", "c"], "my_abc")

    // put expiring items
    // expire item in 300 seconds
    await db.put({"name": "alex", age: 21}, "alex21", {expireIn: 300})
    // expire item at expire date
    await db.put({"name": "max", age:28}, "max28", {expireAt: new Date('2023-01-01T00:00:00')})
    ```

    ##### Returns

    `put` returns a promise which resolves to the item on a successful put, otherwise it throws an Error.
  </Fragment>

  <Fragment slot="py">
    ```py
    put(
      data: typing.Union[dict, list, str, int, float, bool],
      key: str = None,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `dict`, `str`, [`int`](#storing-numbers), [`float`](#storing-numbers), `bool` and `list`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `str` and `None`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


    ##### Code Example
    ```py
    from deta import Deta
    deta = Deta("project key")
    db = deta.Base("simple_db")

    # store objects
    # a key will be automatically generated
    db.put({"name": "alex", "age": 77})
    # we will use "one" as a key
    db.put({"name": "alex", "age": 77}, "one")
    # the key could also be included in the object itself
    db.put({"name": "alex", "age": 77, "key": "one"})

    # simple types
    db.put("hello, worlds")
    db.put(7)
    # "success" is the value and "smart_work" is the key.
    db.put("success", "smart_work")
    db.put(["a", "b", "c"], "my_abc")

    # expiring items
    # expire item in 300 seconds
    db.put({"name": "alex", "age": 23}, "alex23", expire_in=300)
    # expire item at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put({"name": "max", "age": 28}, "max28", expire_at=expire_at)
    ```

    ##### Returns

    `put` returns the item on a successful put, otherwise it raises an error.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Put(item interface{}) (string, error)`**

        ##### Parameters

        - **item** : The item to be stored, should be a `struct` or a `map`. If the item is a `struct` provide the field keys for the data with json struct tags. The key of the item must have a json struct tag of `key`. For storing expiring items, the field name `__expires` should be used with a [Unix Time](https://pkg.go.dev/time#Time.Unix) value, see also [expiring items](./expiring_items).

        [Note for storing numbers](#storing-numbers)

        ##### Code Example
        ```go

        import (
          "log"
          "time"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          // json struct tag 'key' used to denote the key
          Key      string   `json:"key"`
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
          // json struct tag '__expires' for expiration timestamp
          // 'omitempty' for omission of default 0 value
          Expires  int64 `json:"__expires,omitempty"`
        }

        func main() {
          // errors ignored for brevity
          d, _ := deta.New(deta.WithProjectKey("project_key"))
          db, _ := base.New(d, "users")

          u := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }
          key, err := db.Put(u)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("successfully put item with key", key)

          // can also use a map
          um := map[string]interface{}{
            "key":      "kasdlj1",
            "username": "jimmy",
            "active":   true,
            "age":      20,
            "likes":    []string{"ramen"},
          }
          key, err = db.Put(um)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("Successfully put item with key:", key)

          // put with expires
          u := &User{
            Key: "will_be_deleted",
            Username: "test_user",
            Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, 0, time.UTC).Unix(),
          }
          key, err = db.Put(u)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("put item with key:", key)

          // put map with expires
          um = map[string]interface{}{
            "key": "will_be_deleted",
            "test": true,
            "__expires": time.Data(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
          }
          key, err = db.Put(um)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("put item with key:", key)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Put(item interface{}) (string, error)`**

        ##### Parameters

        - **item** : The item to be stored, should be a `struct` or a `map`. If the item is a `struct` provide the field keys for the data with json struct tags. The key of the item must have a json struct tag of `key`. For storing expiring items, the field name `__expires` should be used with a [Unix Time](https://pkg.go.dev/time#Time.Unix) value, see also [expiring items](./expiring_items).

        [Note for storing numbers](#storing-numbers)

        ##### Code Example
        ```go
        import (
            "log"
            "time"
            "github.com/deta/deta-go"
        )

        // User represents a user
        type User struct{
            // json struct tag 'key' used to denote the key
            Key      string `json:"key"`
            Username string `json:"username"`
            Active   bool `json:"active"`
            Age      int `json:"age"`
            Likes    []string `json:"likes"`
            // json struct tag '__expires' for expiration timestamp,
            // tag has 'omitempty' for ommission of default 0 values
            Expires  int64 `json:"__expires,omitempty"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a user
            u := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }

            // put item in the database
            key, err := db.Put(u)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // can also use a map
            um := map[string]interface{}{
              "key": "kasdlj1",
              "username": "jimmy",
              "active": true,
              "age": 20,
              "likes": []string{"ramen"},
            }

            key, err = db.Put(um)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // expiring items
            u = &User {
              Key: "will_be_deleted",
              Username: "test_user",
              Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
            }
            key, err = db.Put(u)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // maps with expiration timestamp
            um = map[string]interface{}{
              "key": "will_be_deleted",
              "test": true,
              "__expires": time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
            }

            key, err = db.Put(um)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns the `key` of the item stored and an `error`. Possible error values:

    - `ErrBadItem` : bad item, item is of unexpected type
    - `ErrBadRequest`: item caused a bad request response from the server
    - `ErrUnauthorized`: unuathorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Get
`get` retrieves an item from the database by it's `key`.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async get(key)`**

    ##### Parameters

    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of which item is to be retrieved.

    ##### Code Example

    ```js
    const item = await db.get('one'); // retrieving item with key "one"
    ```


    ##### Returns

    If the record is found, the promise resolves to:
    ```js
    {
      name: 'alex', age: 77, key: 'one'
    }
    ```
    If not found, the promise will resolve to `null`.
  </Fragment>

  <Fragment slot="py">
    ```py
    get(key: str)
    ```

    ##### Parameter Types

    - **key** (required) ‚Äì Accepts: `str`
        - Description: the key of which item is to be retrieved.

    ##### Code Example
    ```py
    item = db.get("one") # retrieving item with key "one"
    ```

    ##### Returns

    If the record is found:
    ```py
    {
      "name": "alex", "age": 77, "key": "one"
    }
    ```

    If not found, the function will return `None`.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Get(key string, dest interface{}) error`**

        ##### Parameters
        - **key**: the key of the item to be retrieved
        - **dest**: the result will be stored into the value pointed by `dest`

        ##### Code Example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // a variable to store the result
          var u User

          // get item
          // returns ErrNotFound if no item was found
          err = db.Get("kasdlj1", &u)
          if err != nil {
            fmt.Println("failed to get item:", err)
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Get(key string, dest interface{}) error`**

        ##### Parameters
        - **key**: the key of the item to be retrieved
        - **dest**: the result will be stored into the value pointed by `dest`

        ##### Code Example

        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a variable to store the result
            var u User

            // get item
            // returns ErrNotFound if no item was found
            err := db.Get("kasdlj1", &u)
            if err != nil{
                fmt.Println("failed to get item:", err)
            }
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns an `error`. Possible error values:

    - `ErrNotFound`: no item with such key was found
    - `ErrBadDestination`: bad destination, result could not be stored onto `dest`
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Delete
`delete` deletes an item from the database that matches the key provided.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async delete(key)`**

    ##### Parameters
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of which item is to be deleted.

    ##### Code Example

    ```js
    const res = await db.delete("one")
    ```



    ##### Returns

    Always returns a promise which resolves to `null`, even if the key does not exist.
  </Fragment>

  <Fragment slot="py">
    ```py
    delete(key: str)
    ```

    ##### Parameters
    - **key** (required) ‚Äì Accepts: `str`
        - Description: the key of the item that is to be deleted.

    ##### Code Example

    ```py
    res = db.delete("one")
    ```

    ##### Returns

    Always returns `None`, even if the key does not exist.
  </Fragment>

  <Fragment slot="go">
    **`Delete(key string) error`**

    ##### Parameters
    - **key**: the key of the item to be deleted
    ##### Code Example
    ```go
    // delete item
    // returns a nil error if item was not found
    err := db.Delete("dakjkfa")
    if err != nil {
      fmt.Println("failed to delete item:", err)
    }
    ```
    ##### Returns

    Returns an `error`. A `nil` error is returned if no item was found with provided `key`. Possible error values:

    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Insert
The `insert` method inserts a single item into a **Base**, but is unique from [`put`](#put) in that it will raise an error of the `key` already exists in the database.

> ‚ÑπÔ∏è `insert` is roughly 2x slower than [`put`](#put).

<br />
<LangTabs>

  <Fragment slot="js">
    **`async insert(data, key = null, options = null)`**

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` and `array`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `string` and `null`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull insert operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).


    ##### Code Example
    ```js
    // will succeed, a key will be auto-generated
    const res1 = await db.insert('hello, world');

    // will succeed.
    const res2 = await db.insert({message: 'hello, world'}, 'greeting1');

    // will raise an error as key "greeting1" already existed.
    const res3 = await db.insert({message: 'hello, there'}, 'greeting1');

    // expire item in 300 seconds
    await db.insert({message: 'will be deleted'}, 'temp_key', {expireIn: 300})

    // expire at date
    await db.insert({message: 'will be deleted'}, 'temp_key_2', {expireAt: new Date('2023-01-01T00:00:00')})
    ```

    ##### Returns

    Returns a promise which resolves to the item on a successful insert, and throws an error if the key already exists.
  </Fragment>

  <Fragment slot="py">
    ```py
    insert(
      data: typing.Union[dict, list, str, int, float, bool],
      key: str = None,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `dict`, `str`, [`int`](#storing-numbers), [`float`](#storing-numbers), `bool` and `list`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `str` and `None`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

    ##### Code Example
    ```py
    # will succeed, a key will be auto-generated
    db.insert("hello, world")

    # will succeed.
    db.insert({"message": "hello, world"}, "greeting1")

    # will raise an error as key "greeting1" already existed.
    db.insert({"message": "hello, there"}, "greeting1")

    # expiring items
    # expire in 300 seconds
    db.insert({"message": "will be deleted"}, "temp_greeting", expire_in=300)

    # expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.insert({"message": "will_be_deleted"}, "temp_greeting2", expire_at=expire_at)
    ```

    ##### Returns

    Returns the item on a successful insert, and throws an error if the key already exists.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Insert(item interface{}) (string, error)`**

        ##### Parameters
        - **item** : similar to `item` parameter to [`Put`](#put)

        ##### Code Example

        ```go

        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          u := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }

          // insert item in the database
          key, err := db.Insert(u)
          if err != nil {
            fmt.Println("failed to insert item:", err)
            return
          }
          fmt.Println("Successfully inserted item with key:", key)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Insert(item interface{}) (string, error)`**

        ##### Parameters
        - **item** : similar to `item` parameter to [`Put`](#put)


        ##### Code Example

        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a user
            u := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }

            // insert item in the database
            key, err := db.Insert(u)
            if err != nil {
                fmt.Println("failed to insert item:", err)
                return
            }
            fmt.Println("Successfully inserted item with key:", key)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns
    Returns the `key` of the item inserted and an `error`. Possible error values:

    - `ErrConflict` : if item with provided `key` already exists
    - `ErrBadItem`: bad item, if item is of unexpected type
    - `ErrBadRequest`: item caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Put Many
The Put Many method puts up to 25 items into a Base at once on a single call.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async putMany(items, options)`**

    ##### Parameters

    - **items** (required) ‚Äì Accepts: `Array` of items, where each "item" can be an `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` or `array`.
        - Description: The list of items to be stored.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
      - Description: Optional parameters.
        - **expireIn** : item will expire in `expireIn` seconds after a successfull put operation, see also [expiring items](./expiring_items).
        - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    ##### Code Example
    ```js

    await db.putMany([
      {"name": "Beverly", "hometown": "Copernicus City", "key": "one"}, // key provided
      "dude", // key auto-generated
      ["NamaskƒÅra", "marhabaan", "hello", "yeoboseyo"] // key auto-generated
    ]);

    // putMany with expire in 300 seconds
    await db.putMany(
      [
        {"key": "temp-1", "name": "test-1"},
        {"key": "temp-2", "name": "test-2"},
      ],
      {expireIn: 300}
    );

    // putMany with expire at
    await db.putMany(
      [
        {"key": "temp-1", "name": "test-1"},
        {"key": "temp-2", "name": "test-2"},
      ],
      {expireAt: new Date('2023-01-01T00:00:00')}
    );

    ```

    ##### Returns

    Returns a promise which resolves to the put items on a successful insert, and throws an error if you attempt to put more than 25 items.

    ```json
    {
        "processed": {
            "items": [
                {
                    "hometown": "Copernicus City",
                    "key": "one",
                    "name": "Beverly"
                },
                {
                    "key": "jyesxxlrezo0",
                    "value": "dude"
                },
                {
                    "key": "5feqybn7lb05",
                    "value": [
                        "NamaskƒÅra",
                        "hello",
                        "marhabaan",
                        "yeoboseyo"
                    ]
                }
            ]
        }
    }
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    put_many(
      items: list,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None,
    )
    ```

    ##### Parameters

    - **items** (required) ‚Äì Accepts: `list` of items, where each "item" can be an `dict` (JSON serializable), `str`, [`int`](#storing-numbers), `bool`, [`float`](#storing-numbers) or `list`.
        - Description: The list of items to be stored.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)



    ##### Code Example
    ```py
    db.put_many([
      {"name": "Beverly", "hometown": "Copernicus City", "key": "one"}, // key provided
      "dude", // key auto-generated
      ["NamaskƒÅra", "marhabaan", "hello", "yeoboseyo"] // key auto-generated
    ])

    # put many to expire in 300 seconds
    db.put_many(
      [{"key": "tmp-1", "value": "test-1"}, {"key": "tmp-2", "value": "test-2"}],
      expire_in=300,
    )

    # put many with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put_many(
      [{"key": "tmp-1", "value": "test-1"}, {"key": "tmp-2", "value": "test-2"}],
      expire_at=expire_at,
    )
    ```

    ##### Returns

    Returns a dict with `processed` and `failed`(if any) items .

    ```json
    {
        "processed": {
            "items": [
                {
                    "hometown": "Copernicus City",
                    "key": "one",
                    "name": "Beverly"
                },
                {
                    "key": "jyesxxlrezo0",
                    "value": "dude"
                },
                {
                    "key": "5feqybn7lb05",
                    "value": [
                        "NamaskƒÅra",
                        "hello",
                        "marhabaan",
                        "yeoboseyo"
                    ]
                }
            ]
        }
    }
    ```
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`PutMany(items interface{}) ([]string, error)`**

        ##### Parameters:
        - **items**: a slice of items, each item in the slice similar to the `item` parameter in [`Put`](#put)

        ##### Code Example:
        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // users
          u1 := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }
          u2 := &User{
            Key:      "askdjf",
            Username: "joel",
            Active:   true,
            Age:      23,
            Likes:    []string{"coffee"},
          }
          users := []*User{u1, u2}

          // put items in the database
          keys, err := db.PutMany(users)
          if err != nil {
            fmt.Println("failed to put items:", err)
            return
          }
          fmt.Println("Successfully put item with keys:", keys)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`PutMany(items interface{}) ([]string, error)`**

        ##### Parameters:
        - **items**: a slice of items, each item in the slice similar to the `item` parameter in [`Put`](#put)


        ##### Code Example:
        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // users
            u1 := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }
            u2 := &User{
              Key: "askdjf",
              Username: "joel",
              Active: true,
              Age: 23,
              Likes: []string{"coffee"},
            }
            users := []*User{u1, u2}

            // put items in the database
            keys, err := db.PutMany(users)
            if err != nil {
                fmt.Println("failed to put items:", err)
                return
            }
            fmt.Println("Successfully put item with keys:", keys)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns
    Returns the list of keys of the items stored and an `error`. In case of an error, none of the items are stored. Possible error values:

    - `ErrTooManyItems`: if there are more than 25 items
    - `ErrBadItem`: bad item/items, one or more item of unexpected type
    - `ErrBadRequest`: one or more item caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Update
`update` updates an existing item from the database.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async update(updates, key, options)`**

    ##### Parameters

    - **updates** (required) - Accepts: `object` (JSON serializable)
        - Description: a json object describing the updates on the item
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of the item to be updated.
    - **options** (optional) - Accepts: `object`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull update operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    [Note for storing numbers](#storing-numbers)

    ###### Update operations
    - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided in the `set` object if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

    - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `base.util.increment(value)` should be used to increment the value. The *default value is 1* if not provided and it can also be negative.

    - **Append**: `Append` appends to a list. The util `base.util.append(value)` should be used to append the value. The value can be a `primitive type` or an `array`.

    - **Prepend**: `Prepend` prepends to a list. The util `base.util.prepend(value)` should be used to prepend the value. The value can be a `primitive type` or an `array`.

    - **Trim**: `Trim` removes an attribute from the item, the util `base.util.trim()` should be used as the value of an attribute.

    ##### Code Example

    Consider we have the following item in a base `const users = deta.Base('users')`:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the following update operation :

    ```js
    const updates = {
      "profile.age": 33, // set profile.age to 33
      "profile.active": true, // set profile.active to true
      "profile.email": "jimmy@deta.sh", // create a new attribute 'profile.email'
      "profile.hometown": users.util.trim(), // remove 'profile.hometown'
      "on_mobile": users.util.trim(), // remove 'on_mobile'
      "purchases": users.util.increment(2), // increment 'purchases' by 2, default value is 1
      "likes": users.util.append("ramen") // append 'ramen' to 'likes', also accepts an array
    }

    const res = await db.update(updates, "user-a");
    ```

    Results in the following item in the base:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes": ["anime", "ramen"],
      "purchases": 3
    }
    ```

    ##### Returns

    If the item is updated, the promise resolves to `null`. Otherwise, an error is raised.
  </Fragment>

  <Fragment slot="py">
    ```py
    update(
      updates: dict,
      key: str,
      *,
      expire_in: int = None,
      expire_at: typing.Union [int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **updates** (required) - Accepts: `dict` (JSON serializable)
        - Description: a dict describing the updates on the item
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of the item to be updated.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

    [Note for storing numbers](#storing-numbers)

    ###### Update operations
    - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided in the `set` dict if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

    - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `base.util.increment(value)` should be used to increment the value. The *default value is 1* if not provided and it can also be negative.

    - **Append**: `Append` appends to a list. The util `base.util.append(value)` should be used to append the value. The value can be a `primitive type` or a `list`.

    - **Prepend**: `Prepend` prepends to a list. The util `base.util.prepend(value)` should be used to prepend the value. The value can be a `primitive type` or a `list`.

    - **Trim**: `Trim` removes an attribute from the item, the util `base.util.trim()` should be used as the value of an attribute.

    ##### Code Example

    Consider we have the following item in a base `users = deta.Base('users')`:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the following update operation:

    ```py
    updates = {
      "profile.age": 33,  # set profile.age to 33
      "profile.active": True, # set profile.active to true
      "profile.email": "jimmy@deta.sh", # create a new attribute 'profile.email'
      "profile.hometown": users.util.trim(), # remove 'profile.hometown'
      "on_mobile": users.util.trim(), # remove 'on_mobile'
      "purchases": users.util.increment(2), # increment by 2, default value is 1
      "likes": users.util.append("ramen") # append 'ramen' to 'likes', also accepts a list
    }

    db.update(updates, "user-a")
    ```

    Results in the following item in the base:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes":["anime", "ramen"],
      "purchases": 3
    }
    ```

    ##### Returns

    If the item is updated, returns `None`. Otherwise, an exception is raised.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Update(key string, updates Updates) error`**

        ##### Parameters

        - **key**: the key of the item to update
        - **updates** : updates applied to the item, is of type `base.Updates` which is a `map[string]interface{}`

        [Note for storing numbers](#storing-numbers)

        ###### Update operations
        - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

        - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `Base.Util.Increment(value interface{})` should be used to increment the value. The value can also be negative.

        - **Append**: `Append` appends to a list. The util `Base.Util.Append(value interface{})` should be used to append the value. The value can be a slice.

        - **Prepend**: `Prepend` prepends to a list. The util `Base.Util.Prepend(value interface{})` should be used to prepend the value. The value can be a slice.

        - **Trim**: `Trim` removes an attribute from the item, the util `Base.Util.Trim()` should be used as the value of an attribute.

        ##### Code Example

        Consider we have the following item in a base `users`:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 32,
            "active": false,
            "hometown": "pittsburgh"
          },
          "likes": ["anime"],
          "purchases": 1
        }
        ```

        Then the following update operation :

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type Profile struct {
          Active   bool   `json:"active"`
          Age      int    `json:"age"`
          Hometown string `json:"hometown"`
        }

        type User struct {
          Key       string   `json:"key"` // json struct tag 'key' used to denote the key
          Username  string   `json:"username"`
          Profile   *Profile `json:"profile"`
          Purchases int      `json:"purchases"`
          Likes     []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // define the updates
          updates := base.Updates{
            "profile.age": 33, // set profile.age to 33
            "profile.active": true, // set profile.active to true
            "profile.hometown": db.Util.Trim(), // remove 'profile.hometown'
            "purchases": db.Util.Increment(2), // increment 'purchases' by 2
            "likes": db.Util.Append("ramen"), // append 'ramen' to 'likes', also accepts a slice
          }
          // update
          err = db.Update("user-a", updates)
          if err != nil {
            fmt.Println("failed to update", err)
            return
          }
        }
        ```

        Results in the following item in the base:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 33,
            "active": true,
          },
          "likes": ["anime", "ramen"],
          "purchases": 3
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Update(key string, updates Updates) error`**

        ##### Parameters

        - **key**: the key of the item to update
        - **updates** : updates applied to the item, is of type `deta.Updates` which is a `map[string]interface{}`

        [Note for storing numbers](#storing-numbers)

        ###### Update operations
        - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

        - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `Base.Util.Increment(value interface{})` should be used to increment the value. The value can also be negative.

        - **Append**: `Append` appends to a list. The util `Base.Util.Append(value interface{})` should be used to append the value. The value can be a slice.

        - **Prepend**: `Prepend` prepends to a list. The util `Base.Util.Prepend(value interface{})` should be used to prepend the value. The value can be a slice.

        - **Trim**: `Trim` removes an attribute from the item, the util `Base.Util.Trim()` should be used as the value of an attribute.

        ##### Code Example

        Consider we have the following item in a base `users`:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 32,
            "active": false,
            "hometown": "pittsburgh"
          },
          "on_mobile": true,
          "likes": ["anime"],
          "purchases": 1
        }
        ```

        Then the following update operation :

        ```go
        // define the updates
        updates := deta.Updates{
          "profile.age": 33, // set profile.age to 33
          "profile.active": true, // set profile.active to true
          "profile.email": "jimmy@deta.sh", // create a new attribute 'profile.email'
          "profile.hometown": users.Util.Trim(), // remove 'profile.hometown'
          "on_mobile": users.Util.Trim(), // remove 'on_mobile'
          "purchases": users.Util.Increment(2), // increment 'purchases' by 2
          "likes": users.Util.Append("ramen") // append 'ramen' to 'likes', also accepts a slice
        }

        // update
        err := users.Util.Update("user-a", updates);
        ```

        Results in the following item in the base:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 33,
            "active": true,
            "email": "jimmy@deta.sh"
          },
          "likes": ["anime", "ramen"],
          "purchases": 3
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns an `error`. Possible error values:

    - `ErrBadRequest`: the update operation caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Fetch
Fetch retrieves a list of items matching a query. It will retrieve everything if no query is provided.

A query is composed of a single [query](/docs/en/reference/base/queries) object or a list of [queries](/docs/en/reference/base/queries).
In the case of a list, the indvidual queries are OR'ed.

<br />
<LangTabs>

  <Fragment slot="js">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`async fetch(query, options)`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb).
        - **options**: optional params:
          - `limit`: the limit of the number of items you want to retreive, min value `1` if used.
          - `last`: the last key seen in a previous paginated response, provide this in a subsequent call to fetch further items.

        > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
        >
        > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

        ##### Returns

        A promise which resolves to an object with the following attributes:

        - `count` : The number of items in the response.

        - `last`: The last key seen in the fetch response. If `last` is not `undefined` further items are to be retreived.

        - `items`: The list of items retreived.


        ##### Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```js
        const { items: myFirstSet } = await db.fetch({"age?lt": 30});
        const { items: mySecondSet } = await db.fetch([
          { "age?gt": 50 },
          { "hometown": "Greenville" }
        ])
        ```

        ... will come back with following data:

        ###### `myFirstSet`:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `mySecondSet`:

        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Fetch All Items

        ```js
        let res = await db.fetch();
        let allItems = res.items;

        // continue fetching until last is not seen
        while (res.last){
          res = await db.fetch({}, {last: res.last});
          allItems = allItems.concat(res.items);
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`async fetch(query, pages=10, buffer=null)`**

        ##### Parameters

        - **query**: is a single [query object](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1 MB).
        - **pages**: how many pages of items should be returned.
        - **buffer**: the number of items which will be returned for each iteration (aka "page") on the return iterable. This is useful when your query is returning more than 1mb of data, so you could buffer the results in smaller chunks.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```js
        const {value: myFirstSet} = await db.fetch({"age?lt": 30}).next();
        const {value: mySecondSet} = await db.fetch([
          { "age?gt": 50 },
          { "hometown": "Greenville" }
        ]).next();
        ```

        ... will come back with following data:

        ###### `myFirstSet`:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `mySecondSet`:

        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```
        ##### Returns

        A promise which resolves to a generator of objects that meet the `query` criteria.

        The total number of items will not exceed the defined using `buffer` and `pages. Max. number of items

        Iterating through the generator yields arrays containing objects, each array of max length `buffer`.


        ##### Example using buffer, pages

        ```js
        const foo = async (myQuery, bar) => {

          items = db.fetch(myQuery, 10, 20) // items is up to the limit length (10*20)

          for await (const subArray of items) // each subArray is up to the buffer length, 20
            bar(subArray)
        }
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

  <Fragment slot="py">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`fetch(query=None, limit=1000, last=None):`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb or max 1000 items).
        - **limit**: the limit of the number of items you want to retreive, min value `1` if used
        - **last**: the last key seen in a previous paginated response

        > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
        >
        > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

        ##### Returns

        Returns an instance of a `FetchResponse` class which has the following properties.

        - `count` : The number of items in the response.

        - `last`: The last key seen in the fetch response. If `last` is not `None` further items are to be retreived

        - `items`: The list of items retreived.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```py
        first_fetch_res = db.fetch({"age?lt": 30})
        second_fetch_res = db.fetch([{"age?gt": 50}, {"hometown": "Greenville"}])
        ```

        ... will come back with following data:

        ###### `first_fetch_res.items`:
        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `second_fetch_res.items`:
        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```


        ##### Fetch All Items

        ```py
        res = db.fetch()
        all_items = res.items

        # fetch until last is 'None'
        while res.last:
          res = db.fetch(last=res.last)
          all_items += res.items
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`fetch(query=None, buffer=None, pages=10):`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb).
        - **pages**: how many pages of items should be returned.
        - **buffer**: the number of items which will be returned for each iteration (aka "page") on the return iterable. This is useful when your query is returning more 1mb of data, so you could buffer the results in smaller chunks.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```py
        my_first_set = next(db.fetch({"age?lt": 30}))
        my_second_set = next(db.fetch([{"age?gt": 50}, {"hometown": "Greenville"}]))
        ```

        ... will come back with following data:

        ###### `my_first_set`:
        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `my_second_set`:
        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Returns

        A generator of objects that meet the `query` criteria.

        The total number of items will not exceed the defined using `buffer` and `pages. Max. number of items

        Iterating through the generator yields lists containing objects, each list of max length `buffer`.


        ##### Example using buffer, pages

        ```py
        def foo(my_query, bar):
          items = db.fetch(my_query, pages=10, buffer=20) # items is up to the limit length (10*20)

          for sub_list in items: # each sub_list is up to the buffer length, 10
            bar(sub_list)
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Fetch(i *FetchInput) error`**

        ##### Parameters

        - **i**: is a pointer to a `FetchInput`

          ```go
          // FetchInput input to Fetch operation
          type FetchInput struct {
            // filters to apply to items
            // A nil value applies no queries and fetches all items
            Q Query
            // the destination to store the results
            Dest interface{}
            // the maximum number of items to fetch
            // value of 0 or less applies no limit
            Limit int
            // the last key evaluated in a paginated response
            // leave empty if not a subsequent fetch request
            LastKey string
          }
          ```
          - `Q`: fetch query, is of type `deta.Query` which is a `[]map[string]interface{}`
          - `Dest`: the results will be stored into the value pointed by `Dest`
          - `Limit`: the maximum number of items to fetch, value of `0` or less applies no limit
          - `LastKey`: the last key evaluated in a paginated response, leave empty if not a subsequent fetch request

        ##### Code Example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key string `json:"key"`
          Name string `json:"name"`
          Age int `json:"age"`
          Hometown string `json:"hometown"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // query to get users with age less than 30
          query := base.Query{
            {"age?lt": 50},
          }

          // variabe to store the results
          var results []*User

          // fetch items
          _, err = db.Fetch(&base.FetchInput{
            Q:    query,
            Dest: &results,
          })
          if err != nil {
            fmt.Println("failed to fetch items:", err)
          }
        }
        ```

        ... `results` will have the following data:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Paginated example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // query to get users with age less than 30
          query := base.Query{
            {"age?lt": 50},
          }

          // variabe to store the results
          var results []*User

          // variable to store the page
          var page []*User

          // fetch input
          i := &base.FetchInput{
            Q:     query,
            Dest:  &page,
            Limit: 1, // limit provided so each page will only have one item
          }

          // fetch items
          lastKey, err := db.Fetch(i)
          if err != nil {
            fmt.Println("failed to fetch items:", err)
            return
          }

          // append page items to results
          results = append(results, page...)

          // get all pages
          for lastKey != "" {
            // provide the last key in the fetch input
            i.LastKey = lastKey

            // fetch
            lastKey, err = db.Fetch(i)
            if err != nil {
              fmt.Println("failed to fetch items:", err)
              return
            }

            // append page items to all results
            results = append(results, page...)
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Fetch(i *FetchInput) error`**

        ##### Parameters

        - **i**: is a pointer to a `FetchInput`

          ```go
          // FetchInput input to Fetch operation
          type FetchInput struct {
            // filters to apply to items
            // A nil value applies no queries and fetches all items
            Q Query
            // the destination to store the results
            Dest interface{}
            // the maximum number of items to fetch
            // value of 0 or less applies no limit
            Limit int
            // the last key evaluated in a paginated response
            // leave empty if not a subsequent fetch request
            LastKey string
          }
          ```
          - `Q`: fetch query, is of type `deta.Query` which is a `[]map[string]interface{}`
          - `Dest`: the results will be stored into the value pointed by `Dest`
          - `Limit`: the maximum number of items to fetch, value of `0` or less applies no limit
          - `LastKey`: the last key evaluated in a paginated response, leave empty if not a subsequent fetch request

        ##### Code Example

        ```go
        import (
            "github.com/deta/deta-go"
        )

        type User struct {
            Key string `json:"key"`
            Name string `json:"name"`
            Age int `json:"age"`
            Hometown string `json:"hometown"`
        }

        func main(){
            // errors ignored for brevity
            d, _ := deta.New("project key")
            db, _ := deta.NewBase("users")

            // query to get users with age less than 30
            query := deta.Query{
              {"age?lt": 50},
            }

            // variabe to store the results
            var results []*User

            // fetch items
            _, err := db.Fetch(&deta.FetchInput{
              Q: query,
              Dest: &results,
            })
            if err != nil {
                fmt.Println("failed to fetch items:", err)
            }
        }
        ```

        ... `results` will have the following data:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Paginated example

        ```go
        import (
            "github.com/deta/deta-go"
        )

        type User struct {
            Key string `json:"key"`
            Name string `json:"name"`
            Age int `json:"age"`
            Hometown string `json:"hometown"`
        }

        func main(){
            // errors ignored for brevity
            d, _ := deta.New("project key")
            db, _ := deta.NewBase("users")

            // query to get users with age less than 30
            query := deta.Query{
              {"age?lt": 50},
            }

            // variabe to store the results
            var results []*User

            // variable to store the page
            var page []*User

            // fetch input
            i := &deta.FetchInput{
              Q: query,
              Dest: &page,
              Limit: 1, // limit provided so each page will only have one item
            }

            // fetch items
            lastKey, err := db.Fetch(i)
            if err != nil {
                fmt.Println("failed to fetch items:", err)
                return
            }

            // append page items to results
            results = append(allResults, page...)

            // get all pages
            for lastKey != ""{
              // provide the last key in the fetch input
              i.LastKey = lastKey

              // fetch
              lastKey, err := db.Fetch(i)
              if err != nil {
                  fmt.Println("failed to fetch items:", err)
                  return
              }

              // append page items to all results
              results = append(allResults, page...)
            }
        }
        ```
      </Fragment>

      ##### Returns

      Returns an `error`. Possible error values:

      - `ErrBadDestination`: bad destination, results could not be stored onto `dest`
      - `ErrBadRequest`: the fetch request caused a bad request response from the server
      - `ErrUnauthorized`: unauthorized
      - `ErrInternalServerError`: internal server error

    </LangVariantsTabs>
  </Fragment>

</LangTabs>

# queries.md

## Operators

Queries support the following operators:

### Equal

```json
{"age": 22, "name": "Beverly"}

// hierarchical
{"user.profile.age": 22, "user.profile.name": "Beverly"}
```

```json
{"fav_numbers": [2, 4, 8]}
```

```json
{"time": {"day": "Tuesday", "hour": "08:00"}}
```

### Not Equal

```json
{"user.profile.age?ne": 22}
```

### Less Than

```json
{"user.profile.age?lt": 22}
```

### Greater Than

```json
{"user.profile.age?gt": 22}
```

### Less Than or Equal

```json
{"user.profile.age?lte": 22}
```

### Greater Than or Equal

```json
{"user.profile.age?gte": 22}
```

### Prefix

```json
{"user.id?pfx": "afdk"}
```

### Range

```json
{"user.age?r": [22, 30]}
```

### Contains

```json
{
  // if user email contains the substring @deta.sh
  "user.email?contains": "@deta.sh"
}
```

```json
{
  // if berlin is in a list of places lived
  "user.places_lived_list?contains": "berlin"
}
```

### Not Contains

```json
{
  // if user email does not contain @deta.sh
  "user.email?not_contains": "@deta.sh" // 'user.email?!contains' also valid
}
```

```json
{
  // if berlin is not in a list of places lived
  "user.places_lived_list?not_contains": "berlin" // 'user.places_lived_list?!contains' also valid
}
```

> `?contains` and `?not_contains` only works for a list of strings if checking for membership in a list; it does not apply to list of other data types. You can store your lists always as a list of strings if you want to check for membership.

## Logical Operators

### AND

The entries in a single query object are `AND` ed together. For e.g. the query:

```json
{
    "active": true,
    "age?gte": 22
}
```

will retrieve items where `active` is `true` **and** `age` is greater than or equal to `22`.

The query above would translate to `SQL` as:

```sql
SELECT * FROM base WHERE active=1 AND age>=22;
```


### OR

Multiple query objects in a list are `OR` ed together. For eg. the queries:

```json
[{"age?lte": 30}, {"age?gte": 40}]
```

will retrieve items where `age` is less than equal to `30` **or** `age` is greater than equal to `40`.

The query above would translate to `SQL` as:

```sql
SELECT * FROM base WHERE age<=30 OR age>=40;
```


## Hierarchy

You can use the period character `.` to query for hierarchical fields within the data. For instance if you have the following item in the base:

```json
{
    "key": "user-key",
    "profile": {
        "age": 22,
        "active": true
    }
}
```

Then you can query for the `active` and `age` within `profile` directly:

```json
{
    "profile.age": 22,
    "profile.active": true
}
```

## Querying Keys

You need to consider the following when querying on keys:

- The keys must be strings hence the operation values **must** also be strings.
- The [contains](#contains) and [not-contains](#not-contains) operators **are not supported**.
- The [`AND`](#and) and [`OR`](#or) operations for different query values **are not supported**.
    For e.g. **the following queries are invalid**:
    ```json
    {
        // different AND key queries (invalid query)
        "key": "a",
        "key?pfx": "b"
    }
    ```

    ```json
    {
        // different OR key queries (invalid query)
        [{"key?pfx":"a"}, {"key?pfx": "b"}]
    }
    ```
# expiring_items.mdx

## Storing

Items specify the expiration timestamp value in a field name `__expires` in the item itself. The value is a [Unix time](https://en.wikipedia.org/wiki/Unix_time), a number.

For e.g.
```json
{
  "key": "item_key",
  "msg": "this will be deleted",
  "__expires": 1672531200
}
```

The item above will be deleted automatically on `2023-01-01 00:00:00 GMT` (the equivalent date of the timestamp above).

You can use the [Base SDK](./sdk.md) to [`put`](./sdk#put), [`put_many`](./sdk#put_many) or [`insert`](./sdk#insert) items with an expiration timestamp (or the [HTTP API](./HTTP.md) directly).

> ‚ö†Ô∏è Storing an item with an already expired timestamp will not fail but the item will be immediately deleted.

> ‚ÑπÔ∏è Base SDKs might offer higher level methods with easier APIs to specify the expiration timestamp. If they do so, they still store the timestamp in the item itself as mentioned above.

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    const Deta = require('deta');
    const db = Deta("project_key").Base('examples');

    const item = {'value': 'temp'};

    // expire in 300 seconds
    await db.put(item, 'temp_key', {expireIn:300})

    // expire at date
    await db.put(item, 'temp_key', {expireAt: new Date('2023-01-01T00:00:00')})
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    import datetime
    from deta import Deta

    db = Deta("project_key").Base("examples")

    item = {"key": "temp_key", "value": "temp"}

    # expire in 300 seconds
    db.put(item, expire_in=300)

    # expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put(item, expire_at=expire_at)
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    import (
      "log"
      "time"

      "github.com/deta/deta-go/deta"
      "github.com/deta/deta-go/service/base"
    )

    type TmpData struct {
      Key string `json: "key"`
      Value string `json:"value"`
      // json struct tag `__expires` for expiration timestamp
      // 'omitempty' to prevent default 0 value
      Expires int64 `json:"__expires,omitempty"`
    }

    func main() {
      // errors ignored for brevity
      d, _ := deta.New(deta.WithProjectKey("project_key"))
      db, _ := base.New(d, "examples")

      tmp := &TmpData{
        Key: "temp_key",
        Value: "temp",
        Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
      }
      _, err := db.Put(tmp)
      if err != nil {
        log.Fatal("failed to put item:", err)
      }
    }
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl -X PUT "https://database.deta.sh/v1/test_project_id/examples/items" \
        -H "Content-Type: application/json" \
        -H "X-Api-Key: test_project_key" \
        -d {"items":[{"key": "temp_key", "value": "temp", "__expires": 1672531200}]}
    ```
  </Fragment>

</LangTabsExtended>

## Retrieving

When you retrieve items with an expiration timestamp, the timestamp value will be present in the `__expires` field. The value is a [Unix time](https://en.wikipedia.org/wiki/Unix_time).

`Get` and `Query` operations will not retrieve already expired items.

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    const { __expires } = await db.get("temp_key");
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    expires = db.get("temp_key").get("__expires")
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    dest := struct{
      Key     string `json:"key"`
      Expires int64  `json:"__expires,omitempty"`
    }{}

    if err := db.Get("temp_key", &dest); err != nil {
      log.Fatal("failed to get item:", err)
    }

    expires := dest.Expires
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl "https://database.deta.sh/v1/test_project_id/examples/items/temp_key" \
        -H "X-Api-Key: test_project_key"

    {"key": "temp_key", "value": "temp", "__expires": 1672531200}
    ```
  </Fragment>

</LangTabsExtended>




## Updating

You can update the expiration timestamp with a new timestamp by updating the value of the `__expires` as long as the item has not already expired.

Updating other fields of the item **does not** update (or renew) the expiration timestamp. You **must** update the value of `__expires` field.

You can use the [Base SDK](./sdk.md) to [`update`](./sdk#update) the expiration timestamp (or the [HTTP API](./HTTP.md) directly).

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    // update item to expire in 300 seconds from now
    await db.update(null, "temp_key", {expireIn: 300})

    // update item to expire at date
    await db.update(null, "temp_key", {expireAt: new Date('2023-01-01T00:00:00')})
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    # update item to expire in 300 seconds from now
    db.update(None, "temp_key", expire_in=300)

    # update item to expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.update(None, "temp_key", expire_at=expire_at)
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    updates := base.Updates{
      "__expires": 1672531200,
    }
    if err := db.Update("temp_key", updates); err != nil {
      log.Fatal("failed to update item:", err)
    }
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl -X PATCH "https://database.data.sh/v1/test_project_id/examples/items/temp_key" \
        -H "Content-Type: application/json" \
        -H "X-Api-Key: test_project_key" \
        -d {"set": {"__expires": 1672531200}}
    ```
  </Fragment>

</LangTabsExtended>


# py_tutorial.md

## Building a Simple CRUD with Deta Base


### Setup

Two dependencies are needed for this project, `deta` and `flask`:

```shell
pip install deta flask
```


To configure the app, import the dependencies and instantiate your database.

```py
from flask import Flask, request, jsonify
from deta import Deta


deta = Deta('myProjectKey') # configure your Deta project
db = deta.Base('simpleDB')  # access your DB
app = Flask(__name__)
```


### Creating Records

For our database we are going to store records of users under a unique `key`. Users can have three properties:

```py
{
    "name": str,
    "age": int,
    "hometown": str
}

```


We'll expose a function that creates user records to HTTP `POST` requests on the route `/users`.


```py
@app.route('/users', methods=["POST"])
def create_user():
    name = request.json.get("name")
    age = request.json.get("age")
    hometown = request.json.get("hometown")

    user = db.put({
        "name": name,
        "age": age,
        "hometown": hometown
    })

    return jsonify(user, 201)
```

##### Request

`POST` a payload to the endpoint:

```json
{
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

##### Response

Our server should respond with a status of `201` and a body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Reading Records

To read records, we can simply use `db.get(key)`.

If we tie a `GET` request to the `/users` path with a param giving a user id (i.e. `/users/dl9e6w6859a9`), we can return a record of the user over HTTP.


```py
@app.route("/users/<key>")
def get_user(key):
    user = db.get(key)
    return user if user else jsonify({"error": "Not found"}, 404)
```

##### Request

Let's try reading the record we just created.

Make a `GET` to the path (for example) `/users/dl9e6w6859a9`.

##### Response

The server should return the same record:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Updating Records

To update records under a given `key`, we can use `db.put()`, which will replace the record under a given key.

We can tie a `PUT` request to the path `/users/{id}` to update a given user record over HTTP.


```py
@app.route("/users/<key>", methods=["PUT"])
def update_user(key):
    user = db.put(request.json, key)
    return user
```

##### Request

We can update the record by passing a `PUT` to the path `/users/dl9e6w6859a9` with the following payload:

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with the new body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```


### Deleting Records

To delete records under a given `key`, we can use `Base.delete(key)`, which will remove the record under a given key.

We can tie a `DELETE` request to the path `/users/{id}` to delete a given user record over HTTP.

```js
@app.route("/users/<key>", methods=["DELETE"])
def delete_user(key):
    db.delete(key)
    return jsonify({"status": "ok"}, 200)
```

##### Request

We can delete the record by passing a `DELETE` to the path `/users/dl9e6w6859a9`.

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with:

```json
None
```
# about.md

## What can Deta Base be used for?

Deta Base is great for projects where configuring and maintaining a database is overkill or when you want to store data as part of [building a Space app](/docs/en/basics/data).

Examples:

- Serverless Applications
- Internal Tools
- Stateful Integrations
- Hackathons and Side Projects
- Prototyping

## Getting started

- [Dealing with data in a Space App](/docs/en/basics/data)
- [Base UI](/docs/en/reference/base/base_ui)
- [Base SDK](/docs/en/reference/base/sdk)
- [Base HTTP API](/docs/en/reference/base/HTTP)
# base_ui.md

### Opening Base UI

You can open the Base UI of an app instance by opening an app's context menu and clicking "View Data"

<img src="/docs_assets/instance/context_menu.png" alt="drive_ui_1" width="200"/>

In the now open dialog navigate to the "Base" tab and all the data from your Base should load into the table view.

You can edit individual cells directly, if they do not contain an array or an object. Modified cells will turn yellow.

<img src="/docs_assets/base_ui/base_ui_2.png" alt="base_ui_2" width="500"/>


### Advanced Editing

You can expand any cell if you want to do advanced editing (like the editing of objects and arrays or type changes).

<img src="/docs_assets/base_ui/base_ui_3.png" alt="base_ui_3" width="500"/>

### Queries

If you don't want to deal with all of your data at once, you can use Deta Base's queries to get a filtered view. Click the **Query** button, enter your query, and hit enter or click **Fetch**.

<img src="/docs_assets/base_ui/base_ui_4.png" alt="base_ui_4" width="600"/>


### Adding Items

You can add new items by clicking **+ Add**.

<img src="/docs_assets/base_ui/base_ui_6.png" alt="base_ui_6" width="600"/>

New rows and edited rows will appear in yellow.

You can permanently save these modifications by clicking **Save edits**.

### Deleting Items

To delete items, click on the checkbox(es) for any item(s) and then click the **Delete** button.

<img src="/docs_assets/base_ui/base_ui_7.png" alt="base_ui_7" width="600"/>

### Undoing Changes

You can revert your local changes, restoring the BaseUI state to the last fetch by clicking the **Undo** button.

<img src="/docs_assets/base_ui/base_ui_8.png" alt="base_ui_8" width="300"/>

### Final Notes

We hope you enjoy Base UI!

Base UI is still in Beta; it has been internally tested but may have some uncaught bugs or issues.
# node_tutorial.mdx

## Building a Simple CRUD with Deta Base

### Setup

Two dependencies are needed for this project, `deta` and `express`:
```shell
npm install deta express
```

To configure the app, import the dependencies and instantiate your database.

```js
const express = require('express');
const { Deta } = require('deta');

const deta = Deta('myProjectKey'); // configure your Deta project
const db = deta.Base('simpleDB');  // access your DB


const app = express(); // instantiate express

app.use(express.json()) // for parsing application/json bodies
```



### Creating Records

For our database we are going to store records of users under a unique `key`. Users can have three properties:
```js
{
    "name": "string",
    "age": number,
    "hometown": "string"
}

```

We'll expose a function that creates user records to HTTP `POST` requests on the route `/users`.
```js
app.post('/users', async (req, res) => {
    const { name, age, hometown } = req.body;
    const toCreate = { name, age, hometown};
    const insertedUser = await db.put(toCreate); // put() will autogenerate a key for us
    res.status(201).json(insertedUser);
});
```



##### Request

`POST` a payload to the endpoint:
```json
{
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```



##### Response

Our server should respond with a status of `201` and a body of:
```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Reading Records

To read records, we can simply use `Base.get(key)`.

If we tie a `GET` request to the `/users` path with a path param giving a user id (i.e. `/users/dl9e6w6859a9`), we can return a record of the user over HTTP.

```js
app.get('/users/:id', async (req, res) => {
    const { id } = req.params;
    const user = await db.get(id);
    if (user) {
        res.json(user);
    } else {
        res.status(404).json({"message": "user not found"});
    }
});
```

Another option would to use `Base.fetch(query)` to search for records to return, like so:

<LangVariantsTabs>

  <Fragment slot="current">
    ```js
    app.get('/search-by-age/:age, async (req, res) => {
        const { age } = req.params;
        const { items } = await db.fetch({'age': age});
        return items;
    });
    ```
  </Fragment>

  <Fragment slot="legacy">
    ```js
    app.get('/search-by-age/:age, async (req, res) => {
        const { age } = req.params;
        return (await db.fetch({'age': age}).next()).value;
    });
    ```
  </Fragment>

</LangVariantsTabs>

##### Request

Let's try reading the record we just created.

Make a `GET` to the path `/users/dl9e6w6859a9`.

##### Response

The server should return the same record:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Updating Records

To update records under a given `key`, we can use `Base.put()`, which will replace the record under a given key.

We can tie a `PUT` request to the path `/users/{id}` to update a given user record over HTTP.

```js
app.put('/users/:id', async (req, res) => {
    const { id } = req.params;
    const { name, age, hometown } = req.body;
    const toPut = { key: id, name, age, hometown };
    const newItem = await db.put(toPut);
    return res.json(newItem)
});
```

##### Request

We can update the record by passing a `PUT` to the path `/users/dl9e6w6859a9` with the following payload:

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with the new body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```


### Deleting Records

To delete records under a given `key`, we can use `Base.delete(key)`, which will remove the record under a given key.

We can tie a `DELETE` request to the path `/users/{id}` to delete a given user record over HTTP.

```js
app.delete('/users/:id', async (req, res) => {
    const { id } = req.params;
    await db.delete(id);
    res.json({"message": "deleted"})
});
```

##### Request

We can delete the record by passing a `DELETE` to the path `/users/dl9e6w6859a9`.

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with:

```json
{
    "message": "deleted"
}
```
# HTTP.mdx

## General

> üí° You can get your **Project Key** and your **Project ID** of your project in [Builder](https://deta.space/builder). You need these to talk with the Deta Drive API.

### Root URL
This URL is the base for all your HTTP requests:

**`https://drive.deta.sh/v1/{project_id}/{drive_name}`**

> The `drive_name` is the name given to your drive. If you already have a **Drive**, then you can go ahead and provide it's name here. Additionally, you could provide any name here when doing any `PUT` or `POST` request and our backend will automatically create a new drive for you if it does not exist. There is no limit on how many "Drives" you can create.

### Auth
A **Project Key** _must_ be provided in the request **headers** as a value for the `X-Api-Key` key for authentication and authorization.

Example `X-Api-Key: a0kjsdfjda_thisIsYourSecretKey`

### File Names And Directories
Each file needs a unique `name` which identifies the file. Directorial hierarchies are represented logically by the `name` of the file itself with the use of backslash `/`.

For example, if you want to store a file `world.txt` under the directory `hello` , the `name` of the file should be `hello/world.txt`.

The file name **must not** end with a `/`. This also means that you can not create an empty directory.

A directory ceases to exist if there are no more files in it.
## Endpoints
### Put File
`POST /files?name={name}`

Stores a smaller file in a single request. Use this endpoint if the file size is small enough to be sent in a single request. The file is overwritten if the file with given `name` already exists.

> We do not accept payloads larger than 10 Mb on this endpoint. For larger uploads, use chunked uploads.

<RequestTabs>

<Fragment slot="request">

| Headers | Required | Description |
| --|--|-|
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories).

</Fragment>
<Fragment slot="response">

##### `201 Created`

```js
Content-Type: application/json

{
    "name": "file name",
    "project_id": "deta project id",
    "drive_name": "deta drive_name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: "application/json"
{
    "errors": [
        // error messages
    ]
}
```

`413 Payload Too Large`

```html
Content-Type: text/html
<h1> 413 - Request Entity Too Large </h1>
```

</Fragment>
</RequestTabs>

### Initialize Chunked Upload

Initializes a chunked file upload. If the file is larger than 10 MB, use this endpoint to initialize a chunked file upload.

`POST /uploads?name={name}`

<RequestTabs>

<Fragment slot="request">

|Params | Required | Description |
||-||
|`upload_id`| Yes | The `upload_id` received after [initiating a chunked upload](#initialize-chunked-upload) |
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories). |
|`part`| Yes | The chunk part number, start with `1` |



</Fragment>
<Fragment slot="response">

##### `200 Ok`

```js
Content-Type: application/json

{
    "name": "file name",
    "upload_id": "a unique upload id"
    "part": 1, // upload part number
    "project_id": "deta project id",
    "drive_name": "deta drive name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`413 Payload Too Large`

```html
Content-Type: text/html
<h1> 413 Request Entity Too Large </h1>
```
</Fragment>
</RequestTabs>

### End Chunked Upload

End a chunked upload.

`PATCH /uploads/{upload_id}?name={name}`

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
||-||
|`upload_id`| Yes | The `upload_id` received after [initiating a chunked upload](#initialize-chunked-upload) |
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories). |


</Fragment>
<Fragment slot="response">

##### `200 Ok`

```js
Content-Type: application/json

{
    "name": "file name",
    "upload_id": "a unique upload id"
    "project_id": "deta project id",
    "drive_name": "deta drive name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```
</Fragment>
</RequestTabs>

### Download File

Download a file from drive.

` GET /files/download?name={name}`

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
||-||
|`limit`| No | The `limit` of number of file names to get, defaults to `1000`|
|`prefix`| No | The `prefix` that each file name must have. |
|`last` | No | The `last` file name seen in a paginated response. |


</Fragment>
<Fragment slot="response">

##### `200 Ok`

The response is paginated based on the `limit` provided in the request. By default, maximum `1000` file names are sent.

If the response is paginated, the response contains a `paging` object with `size` and `last` keys; `size` is the number of file
names in the response, and `last` is the last file name seen in the response. The value of `last` should be used in subsequent
requests to continue recieving further pages.

```js
Content-Type: application/json

{
    "paging": {
        "size": 1000, // the number of file names in the response
        "last": "last file name in response"
    },
    "names": ["file1", "file2", ...]
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

</Fragment>
</RequestTabs>

### Delete Files

Delete files from drive.

`DELETE /files`

<RequestTabs>

<Fragment slot="request">

```js
Content-Type: "application/json"
{
    "names": ["file_1", "file_2"]
}
```

| Params | Required | Description |
||---|
|`names`| Yes | The `names` of the files to delete, maximum `1000` file names|

</Fragment>
<Fragment slot="response">

##### `200 Ok`


```js
Content-Type: application/json

{
    "deleted": ["file_1", "file_2", ...] // deleted file names
    "failed": {
        "file_3": "reason why file could not be deleted",
        "file_4": "reason why file could not be deleted",
        //...
    }
}
```

> File names that did not exist will also be under `deleted`, `failed` will only contain names of files that existed but were not deleted for some reason

</Fragment>
</RequestTabs>
# sdk.mdx

## Installing

<br />
<LangTabs>
  <Fragment slot="js">
  Using NPM:

    ```shell
    npm install deta
    ```

    Using Yarn:
    ```shell
    yarn add deta
    ```

  </Fragment>
  <Fragment slot="py">
  ```shell
	pip install deta
	```
  </Fragment>
  <Fragment slot="go">
  ```shell
	go get github.com/deta/deta-go
	```
  </Fragment>
</LangTabs>

## Instantiating

To start working with your Drive, you need to import the `Deta` class and initialize it with a **Project Key**. Then instantiate a subclass called `Drive` with a database name of your choosing.

<br />

<LangTabs>
  <Fragment slot="js">
	```js
	const { Deta } = require('deta'); // import Deta

    // this also works
    import { Deta } from 'deta';

    // Initialize with a Project Key
    const deta = Deta('project key');

    // You can create as many as you want
    const photos = deta.Drive('photos');
    const docs = deta.Drive('docs');
    ```

    If you are using Deta Drive within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your `package.json` file to install the latest sdk version.

    A valid project key is pre-set in the Micro's environment. There is no need to pass a key in the initialization step.

    ```js
    const { Drive } = require('deta');
    const drive = Drive('simple_drive');
    ```

    If you are using the `deta` npm package of `0.0.6` or below, `Deta` is the single default export and should be imported as such.

    ```js
    const Deta = require('deta');
    ```

  </Fragment>
  <Fragment slot="py">
  	```py
	from deta import Deta  # Import Deta

    # Initialize with a Project Key
    deta = Deta("project key")

    # This how to connect to or create a database.
    drive = deta.Drive("simple_drive")

    # You can create as many as you want
    photos = deta.Drive("photos")
    docs = deta.Drive("docs")

    ```

    If you are using Deta Drive within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your `requirements.txt` file to install the latest sdk version.

    A valid project key is pre-set in the Micro's environment. There is no need to pass a key in the the initialization step.

    ```py
    from deta import Drive

    drive = Drive("simple_drive")
    ```

  </Fragment>
  <Fragment slot="go">
  	```go
	import (
		"fmt"

    	"github.com/deta/deta-go/deta"
    	"github.com/deta/deta-go/service/drive"
    )

    func main() {

    	// initialize with project key
    	// returns ErrBadProjectKey if project key is invalid
    	d, err := deta.New(deta.WithProjectKey("project_key"))
    	if err != nil {
    		fmt.Println("failed to init new Deta instance:", err)
    		return
    	}

    	// initialize with drive name
    	// returns ErrBadDriveName if base name is invalid
    	drive, err := drive.New(d, "drive_name")
    	if err != nil {
    		fmt.Println("failed to init new Drive instance:", err)
    		return
    	}
    }
    ```

  </Fragment>
</LangTabs>

> ‚ö†Ô∏è Your project key is confidential and meant to be used by you. Anyone who has your project key can access your database. Please, do not share it or commit it in your code.

## Using

Deta's **`Drive`** offers the following methods to interact with your Deta Drive:

[**`put`**](#put) - Stores a file to drive. It will overwrite the file if the file already exists.

[**`get`**](#get) - Retrieves a file from drive by the file name.

[**`delete`**](#delete) - Deletes a file from drive.

[**`list`**](#list) - Lists the file names in a drive.

### Put

`Put` uploads and stores a file in a drive with a given `name`. It will overwrite the file if the file name already exists.

<LangTabs>
  <Fragment slot="js">

**`async put(name, options)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file.
- **options** (required) - `{data : string | Uint8Array | Buffer, path: string, contentType: string}`

  - Description: An object with three optional parameters.
    - **data** - `string` or `Buffer`
      - Description: Either the data string or a buffer.
    - **path** - `string`
      - Description: The path of the file to be uploaded to drive.
    - **contentType** - `string`
      - Description: The content type of the file to be uploaded to drive. If the content type is not provided, `drive` tries to figure out the content type from the `name` provided. It defaults to `application/octet-stream` if the content type can not be figured out from the file name.

  `options` must have at least and at most one of two properties `data` or `path` defined.

##### Returns

Returns a promise which resolves to the name of the item on a successful `put`, otherwise, it throws an `Error` on error.

##### Example

```js
drive.put('hello.txt', {data: "Hello world"});
drive.put('hello.txt', {data: "Hello world", contentType: 'text/plain'});

drive.put('hello.txt', {data: Buffer.from('Hello World'), contentType: 'text/plain'});
drive.put('hello.txt', {path: './my/file/path/file.txt'});
drive.put('hello.txt', {path: './my/file/path/file.txt', contentType: 'text/plain'}});
```

  </Fragment>
  <Fragment slot="py">
  **`put(name, data, *, path, content_type)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file.
- **data** - `string | bytes | io.TextIOBase | io.BufferedIOBase | io.RawIOBase`
  - Description: The data content of the file.
- **path** - `string`
  - Description: The local path of the file to be uploaded to drive.
- **content_type** - `string`

  - Description: The content type of the file to be uploaded to drive. If the content type is not provided, `drive` tries to figure out the content type from the `name` provided. It defaults to `application/octet-stream` if the content type can not be figured out from the file name.

  At least and at most one of two args `data` or `path` must be provided. `path` and `content_type` must be provided with the key words.

##### Returns

Returns the name of the file on a successful `put`, otherwise, raises an `Exception` on error.

##### Example

```py
drive.put('hello.txt', 'Hello world')
drive.put(b'hello.txt', 'Hello world')
drive.put('hello.txt', content_type='text/plain')

import io
drive.put('hello.txt', io.StringIO('hello world'))
drive.put('hello.txt', io.BytesIO(b'hello world'))

f = open('./hello.txt', 'r')
drive.put('hello.txt', f)
f.close()

drive.put('hello.txt', path='./hello.txt')
```

  </Fragment>
  <Fragment slot="go">
  **`Put(i *PutInput) (string, error)`**

##### Parameters

- **i** (required) - pointer to a `PutInput`
  - ```go
    // PutInput input to Put operation
    type PutInput struct {
      // Name of the file
      Name string
      // io.Reader with contents of the file
      Body io.Reader
      // ContentType of the file to be uploaded to drive.
      ContentType string
    }
    ```
  - `Name` (required) - `string`
    - Description: Name of the file to be uploaded.
  - `Body` (required) - `io.Reader`
    - Description: File content to be uploaded.
  - `ContentType` - `string`
    - Description: If the content type is not provided, drive tries to figure out the content type from Name provided. It defaults to application/octet-stream if the content type can not be figured out from the file name.

##### Returns

Returns the `name` of the file on a successful put (otherwise empty name), and an `error`.

##### Example

```go
import (
	"bufio"
	"fmt"
	"os"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}
	// PUT
	// reading from a local file
	file, err := os.Open("./art.svg")
	defer file.Close()

	name, err := drawings.Put(&drive.PutInput{
		Name:        "art.svg",
		Body:        bufio.NewReader(file),
		ContentType: "image/svg+xml",
	})
	if err != nil {
		fmt.Println("failed to put file:", err)
		return
	}
	fmt.Println("Successfully put file with name:", name)
}
```

  </Fragment>
</LangTabs>

### Get

`Get` retrieves a file from a drive by its name.

<LangTabs>
  <Fragment slot="js">

**`async get(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a promise that resolves to a `blob` of data if found, else `null`.
Throws an `Error` on errors.

##### Example

```js
const buf = await drive.get("hello.txt");
```

</Fragment>

<Fragment slot="py">

**`get(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a instance of a `DriveStreamingBody` class which has the following methods/properties.

- `read(size=None)` : Reads all or up to the next `size` bytes. Calling `read` after all the content has been read will return empty bytes.

- `iter_chunks(chunk_size:int=1024)` : Returns an iterator that yields chunks of bytes of `chunk_size` at a time.

- `iter_lines(chunk_size:int=1024)` : Returns an iterator that yields lines from the stream. Bytes of `chunk_size` at a time is read from the raw stream and lines are yielded from there. The line delimiter is always `b'\n'`.

- `close()` : Closes the stream.

- `closed` : Returns `True` if the stream has been closed.

##### Example

```py
hello = drive.get('hello.txt')
content = hello.read()
hello.close()

# larger files
# iterate chunks of size 4096 and save to disk
large_file = drive.get('large_file.txt')
with open("large_file.txt", "wb+") as f:
  for chunk in large_file.iter_chunks(4096):
      f.write(chunk)
  large_file.close()
```

</Fragment>

<Fragment slot="go">

**`Get(name string) (io.ReadCloser, error)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a `io.ReadCloser` for the file.

##### Example

```go
import (
	"fmt"
	"io/ioutil"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	// GET
	name := "art.svg"
	f, err := drawings.Get(name)
	if err != nil {
		fmt.Println("failed to get file with name:", name)
		return
	}
	defer f.Close()

	c, err := ioutil.ReadAll(f)
	if err != nil {
		fmt.Println("failed read file content with err:", err)
		return
	}
	fmt.Println("file content:", string(c))
}
```

</Fragment>

</LangTabs>

### Delete

`Delete` deletes a file from drive.

<LangTabs>
<Fragment slot="js">

**`async delete(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns a promise that resolves to the `name` of the deleted file on successful deletions, otherwise raises an `Error`

> If the file did not exist, the file is still returned as deleted.

##### Example

```js
const deletedFile = await drive.delete("hello.txt");
```

</Fragment>

<Fragment slot="py">

**`delete(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns the `name` of the deleted file on successful deletions, otherwise raises an `Exception`

> If the file did not exist, the file is still returned as deleted.

##### Example

```py
deleted_file = drive.delete("hello.txt")
```

</Fragment>
<Fragment slot="go">

**`Delete(name string) (string, error)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns the `name` of the deleted file on successful deletions, and an `error`.

> If the file did not exist, the name is still returned.

##### Example

```go
import (
	"fmt"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	// DELETE
	name, err := drawings.Delete("art.svg")
	if err != nil {
		fmt.Println("failed to delete file with name:", name)
		return
	}
	fmt.Println("Successfully deleted file with name:", name)
}
```

</Fragment>
</LangTabs>

### Delete Many

Deletes multiple files (up to 1000) from a drive.

<LangTabs>

<Fragment slot="js">

**`async deleteMany(names)`**

##### Parameters

- **names** (required) - `Array of string`
  - description: The names of the files to be deleted.

##### Returns

Returns a promise which resolves to an object with `deleted` and `failed` keys indicating deleted and failed file names.

```js
{
  deleted : ["file1.txt", "file2.txt", ...],
  failed: {
    "file_3.txt": "reason for failure",
  }
}
```

> If a file did not exist, the file is still returned as deleted.

##### Example

```js
const result = await drive.DeleteMany(["file1.txt", "file2.txt"]);
console.log("deleted:", result.deleted);
console.log("failed:", result.failed);
```

</Fragment>

<Fragment slot="py">

**`delete_many(names)`**

##### Parameters

- **names** (required): `string`
  - Description: The names of the files to be deleted.

##### Returns

Returns a `dict` with `deleted` and `failed` keys indicating deleted and failed file names.

```py
{
  "deleted" : ["file1.txt", "file2.txt", ...],
  "failed": {
    "file_3.txt": "reason for failure"
  }
}
```

> If a file did not exist, the file is still returned as deleted.

##### Example

```py
result = drive.delete_many(["file1.txt", "file2.txt"]);
print("deleted:", result.get("deleted"))
print("failed:", result.get("failed"))
```

</Fragment>
	<Fragment slot="go">

	**`DeleteMany(names []string) (*DeleteManyOutput, error)`**

	##### Parameters

	- **names** (required): `[]string`
	- Description: The names of the files to be deleted.

	##### Returns

	Returns a pointer to a `DeleteManyOutput` and an `error`.

	```go
	// DeleteManyOutput output to DeleteMany operation
	type DeleteManyOutput struct {
		Deleted []string          `json:"deleted"`
		Failed  map[string]string `json:"failed"`
	}
	```

	- `Deleted` - string slice indicating deleted file names.
	- `Failled` - map indicating the names of failed file names along with an error message.

	##### Example

	```go
	import (
		"fmt"

		"github.com/deta/deta-go/deta"
		"github.com/deta/deta-go/service/drive"
	)

	func main() {
		// initialize with project key
		// returns ErrBadProjectKey if project key is invalid
		d, err := deta.New(deta.WithProjectKey("project_key"))
		if err != nil {
			fmt.Println("failed to init new Deta instance:", err)
			return
		}

		// initialize with drive name
		// returns ErrBadDriveName if drive name is invalid
		drawings, err := drive.New(d, "drawings")
		if err != nil {
			fmt.Println("failed to init new Drive instance:", err)
			return
		}

		names := []string{"a", "b", "c"}
		dr, err := drawings.DeleteMany(names)

		if err != nil {
			fmt.Println("failed to delete files")
			return
		}
		fmt.Println("deleted:", dr.Deleted)
		fmt.Println("failed:", dr.Failed)
	}
	```

	</Fragment>
</LangTabs>

### List

`List` files in your drive.

<LangTabs>

<Fragment slot="js">

**`async list(options)`**

##### Parameters

- **options** (required) : `{prefix: string, limit: number, last: string}`
  - Description: An object with three optional parameters.
    - **prefix**: `string`
      - Description: The prefix that file names must have.
    - **limit**: `number`
      - Description: The maximum number of files names to be returned, defaults to `1000`
    - **last**: `string`
      - Description: The `last` name seen in a previous paginated result. Provide `last` to fetch further pages.

##### Returns

Returns a promise which resolves to an `object` with `paging` and `names` keys.

```js
{
  names: ["file1.txt", "file2.txt", ...],
  paging: {
    size: 2,
    last: "file_2.txt"
  }
}
```

- `names`: The names of the files
- `paging`: Contains paging information.
  - `size` : The number of files returned.
  - `last` : The last name seen in the paginated response. Provide this value in subsequent api calls to fetch further pages. For the last page, `last` is not present in the response.

##### Example

```js
// get all files
let result = await drive.list();
let allFiles = result.names;
let last = result.paging.last;

while (last) {
  // provide last from previous call
  result = await drive.list({ last: result.paging.last });

  allFiles = allFiles.concat(result.names);

  // update last
  last = result.paging.last;
}
console.log("all files:", allFiles);

const resultWithPrefix = await drive.list({ prefix: "blog/" });
const resultWithLimit = await drive.list({ limit: 100 });
const resultWIthLimitAndPrefix = await drive.list({
  limit: 100,
  prefix: "blog/",
});
```

</Fragment>

<Fragment slot="py">

**`list(limit, prefix, last)`**

##### Parameters

- **limit**: `int`
  - Description: The maximum number of files names to be returned, defaults to `1000`
- **prefix**: `string`
  - Description: The prefix that file names must have.
- **last**: `string`
  - Description: The `last` name seen in a previous paginated result. Provide `last` from previous response to fetch further pages.

##### Returns

Returns a `dict` with `paging` and `names` keys.

```py
{
  "names": ["file1.txt", "file2.txt", ...],
  "paging": {
    "size": 2,
    "last": "file_2.txt"
  }
}
```

- `names`: The names of the files
- `paging`: Contains paging information.
  - `size` : The number of files returned.
  - `last` : The last name seen in the paginated response. Provide this value in subsequent api calls to fetch further pages. For the last page, `last` is not present in the response.

##### Example

```py
# get all files
result = drive.list()

all_files = result.get("names")
paging = result.get("paging")
last = paging.get("last") if paging else None

while (last):
  # provide last from previous call
  result = drive.list(last=last)

  all_files += result.get("names")
  # update last
  paging = result.get("paging")
  last = paging.get("last") if paging else None

print("all files:", all_files)

res_with_prefix = drive.list(prefix="/blog")
res_with_limit = drive.list(limit=100)
res_with_prefix_limit = drive.list(prefix="/blog", limit=100)
```

</Fragment>

<Fragment slot="go">

**`List(limit int, prefix, last string) (*ListOutput, error)`**

##### Parameters

- **limit** (required) - `int`
  - Description: Maximum number of file names to be returned.
- **prefix** (required) - `string`
  - Description: The prefix that file names must have.
- **last** (required) - `string`
  - Description: The `last` name seen in a previous paginated result. Provide `last` from previous response to fetch further pages.

##### Returns

Returns a pointer to a `ListOutput`

```go
type ListOutput struct {
	Paging *paging  `json:"paging"`
	Names  []string `json:"names"`
}

type paging struct {
	Size int     `json:"size"`
	Last *string `json:"last"`
}
```

- `Paging` - indicates the size and last name of the current page. `nil` if there are no further pages.
- `Names` - names of the files.

##### Example

```go
import (
	"fmt"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	lr, err := drawings.List(1000, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// ["a", "b", "c/d"]
	fmt.Println("names:", lr.Names)

	lr, err = drawings.List(1, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// ["a"]
	fmt.Println("names:", lr.Names)


	lr, err = drawings.List(2, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// "b"
	fmt.Println("last:", *lr.Paging.Last)
}
```

</Fragment>
</LangTabs>
# drive_ui.md

### Opening Drive UI

You can open the Drive UI of an app instance by opening an app's context menu and clicking "View Data".

<img src="/docs_assets/instance/context_menu.png" alt="drive_ui_1" width="200"/>

In the now open dialog navigate to the "Drive" tab and all the files and folders from within the path `/` should load into the table view.


### Preview and Navigation

Files that are previewable (and folders) are marked in blue.

<img src="/docs_assets/drive_ui/drive_ui_2.png" alt="drive_ui_2" width="600"/>


Clicking a folder will navigate to that folder, while clicking a file will open up a preview.

<img src="/docs_assets/drive_ui/drive_ui_3.png" alt="drive_ui_3" width="600"/>

<p />

Your current location is highlighted in black in the navigation bar at the top of Drive UI.

<img src="/docs_assets/drive_ui/drive_ui_4.png" alt="drive_ui_4" width="600"/>

You can click a parent folder, or the Drive name, to jump to that location.

### Uploading & Downloading Files

You can upload a file by dragging it into the list of files & folders. This will upload the file in the current directory.

<img src="/docs_assets/drive_ui/drive_ui_5.png" alt="drive_ui_5" width="600"/>

To download a file, click the download icon, which is on the right side of the the table.

### Deleting Files

To delete files, click on the checkbox(es) for any files(s) and then click the trash icon in the top right corner of the Drive UI panel.

<img src="/docs_assets/drive_ui/drive_ui_6.png" alt="drive_ui_6" width="600"/>

You will be asked to confirm you want to delete the file(s).


### Final Notes

We hope you enjoy Drive UI!

Drive UI is still in Beta; it has been internally tested but may have some uncaught bugs or issues.
# py_tutorial.md

## Building a Simple Image Server with Deta Drive

### Setup
To get started, create a directory `image-server` and change the current directory into it.
```shell
$ mkdir image-server && cd image-server
```
Before we begin, let's install all the necessary dependencies for this project. Create a `requirements.txt` with the following lines:
```json
fastapi
uvicorn
deta
python-multipart
```

> If you are using Deta Drive within a Deta Micro, you should ignore `uvicorn`, but you must include `deta` in your `requirements.txt` file to install the lastest sdk version, other than that it won't work.

We are using `FastAPI` to build our simple image server, and `python-multipart` allows us access the uploaded files.

Run the following command to install the dependencies.
```shell
$ pip install -r requirements.txt
```

To configure the app, import the dependencies and instantiate drive in `main.py`

```python
from fastapi import FastAPI, File, UploadFile
from fastapi.responses import HTMLResponse, StreamingResponse
from deta import Deta

app = FastAPI()
deta = Deta("Project_Key")  # configure your Deta project
drive = deta.Drive("images") # access to your drive
```

We have everything we need to üöÄ

### Uploading Images
First, we need to render a HTML snippet to display the file upload interface.

We'll expose a function that renders the HTML snippet on the base route `/`
```python
@app.get("/", response_class=HTMLResponse)
def render():
    return """
    <form action="/upload" enctype="multipart/form-data" method="post">
        <input name="file" type="file">
        <input type="submit">
    </form>
    """
```

We are simply rendering a form that sends a HTTP `POST` request to the route `/upload` with file data.

Let's complete file upload by creating a function to handle `/upload`

```python
@app.post("/upload")
def upload_img(file: UploadFile = File(...)):
    name = file.filename
    f = file.file
    res = drive.put(name, f)
    return res
```

Thanks to the amazing tools from FastAPI, we can simply wrap the input around `UploadFile` and `File` to access the image data. We can retrieve the name as well as bytes from `file` and store it in Drive.

### Downloading images
To download images, we can simply use `drive.get(name)`

If we tie a `GET` request to the `/download` path with a param giving a name (i.e `/download/space.png`), we can return the image over HTTP.
```python
@app.get("/download/{name}")
def download_img(name: str):
    res = drive.get(name)
    return StreamingResponse(res.iter_chunks(1024), media_type="image/png")
```

You can learn more about `StreamingResponse` [here](https://fastapi.tiangolo.com/advanced/custom-response/#streamingresponse).

### Running the server
To run the server locally, navigate to the terminal in the project directory (`image-server`) and run the following command:
```shell
$ uvicorn main:app
```

Your image server is now ready! You can interact with it at `/` and check it out!

<img src="/docs_assets/img/drive/drive-py-tut.png" alt="/"/>
<img src="/docs_assets/img/drive/drive-py-tut-1.png" alt="/download/tut.jpg"/>


```shell

curl -X 'POST' \
  'http://127.0.0.1:8000/upload' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'file=@space.png;type=image/png'

Response
"space.png"


curl -X 'GET' \
  'http://127.0.0.1:8000/download/space.png' \
  -H 'accept: application/json'

Response
The server should respond with the image.
```
# node_tutorial.md

## Building a Simple Image Server with Deta Drive

### Setup

To get started, create a directory `image-server` and change the current directory into it.
```shell
$ mkdir image-server && cd image-server
```
Before we begin, let's install all the necessary dependencies for this project.

```shell
$ npm install deta express express-fileupload
```
In this tutorial, we are using `express` to build our server, and `express-fileupload` allows us to access the uploaded file data.

To configure the app, import the dependencies and instantiate drive in `index.js`

```js
const { Deta } = require("deta");
const express = require("express");
const upload = require("express-fileupload");

const app = express();

app.use(upload());

const deta = Deta("Project_Key");
const drive = deta.Drive("images");
```


We have everything we need to üöÄ

### Uploading Images
First, we need to render a HTML snippet to display the file upload interface.

We'll expose a function that renders the HTML snippet on the base route `/`
```javascript
app.get('/', (req, res) => {
    res.send(`
    <form action="/upload" enctype="multipart/form-data" method="post">
      <input type="file" name="file">
      <input type="submit" value="Upload">
    </form>`);
});
```

We are simply rendering a HTML form that sends a HTTP `POST` request to the route `/upload` with file data.

Let's complete file upload by creating a function to handle `/upload`

```javascript
app.post("/upload", async (req, res) => {
    const name = req.files.file.name;
    const contents = req.files.file.data;
    const img = await drive.put(name, {data: contents});
    res.send(img);
});
```
We can access the image details from `req` and store it in Drive.

### Downloading Images
To download images, we can simply use `drive.get(name)`

If we tie a `GET` request to the `/download` path with a param giving a name (i.e `/download/space.png`), we can return the image over HTTP.

```javascript
app.get("/download/:name", async (req, res) => {
    const name = req.params.name;
    const img = await drive.get(name);
    const buffer = await img.arrayBuffer();
    res.send(Buffer.from(buffer));
});

app.listen(3000);
```

### Running the server
To run the server locally, navigate to the terminal in the project directory (`image-server`) and run the following command:
```shell
$ node index.js
```

<img src="/docs_assets/img/drive/drive-py-tut.png" alt="/"/>
<img src="/docs_assets/img/drive/drive-py-tut-1.png" alt="/download/tut.jpg"/>


```shell
curl -X 'POST' \
  'http://127.0.0.1:3000/upload' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'file=@space.png;type=image/png'

Response
"space.png"

curl -X 'GET' \
  'http://127.0.0.1:3000/download/space.png' \
  -H 'accept: application/json'

Response
The server should respond with the image.
```
# about.md

## What can Deta Drive be used for?

Deta Drive is great for projects where you need to store files or when you want to store files as part of [building a Space app](/docs/en/basics/data).

## Getting started

- [Dealing with data in a Space App](/docs/en/basics/data)
- [Drive UI](/docs/en/reference/drive/base_ui)
- [Drive SDK](/docs/en/reference/drive/sdk)
- [Drive HTTP API](/docs/en/reference/drive/HTTP)
# personal-cloud.md

## What is the personal cloud?

The ‚Äòpersonal cloud‚Äô is pretty simple conceptually. It is just a departure from the common model of web application development on 'public cloud'.

### The public cloud

In a public cloud application, end users of an app by-and-large share infrastructure resources: servers, databases, file stores, etc. These resources are controlled by (and operated by) the providers of the web application, and accessed by end users when they login to the app.

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/public_cloud.png" width="500px" />
<div style="max-width: 100%; white-space: pre-wrap; word-break: break-word; caret-color: rgb(55, 53, 47); font-size: 14px; line-height: 1.4; color: rgba(55, 53, 47, 0.65); padding-top: 6px; padding-bottom: 6px; padding-left: 2px;" data-content-editable-leaf="true" contenteditable="false">Public cloud application architecture</div>
</div>

In this model, if the provider of the app shuts down this infrastructure, the user loses access. Meanwhile, the user can't directly delete their trace data, as it is in the provider's hands.

### The personal cloud

The personal cloud is a return to the personal computer model of applications, but in the cloud. Instead of one giant shared pool of resources for all users, *each user gets their own complete and sandboxed cloud application instance, consisting of the resources needed to power their app.*

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/personal_cloud.png" width="500px" />
<div style="max-width: 100%; white-space: pre-wrap; word-break: break-word; caret-color: rgb(55, 53, 47); font-size: 14px; line-height: 1.4; color: rgba(55, 53, 47, 0.65); padding-top: 6px; padding-bottom: 6px; padding-left: 2px;" data-content-editable-leaf="true" contenteditable="false">Personal cloud application architecture</div>
</div>

In this case, the users control the infrastructure which runs the app.  We think this shift solves a number of hairy problems for developers and users.

## 0 Infrastructure, ‚àû Scale

Due to the personal cloud architecture, each user owns their own infra. What this means for you as a developer, *is that you have effectively 0 infrastructure burden, no matter how many users your app scales to.* No servers or DBs to manage, secure, or maintain. All you need to do is build your application logic.

## Distribution

We've discovered two routes in which we think the personal cloud model improves application distribution today:


1. When a developer has built an application, but wants nothing to do with building auth layer or managing any infrastructure. These applications are really cool demo apps, or even use something like local storage for data persistence, but they aren't reaching their full potential for end users. We think these apps find a happy channel to end users on a personal cloud.
2. Where users really need to their own copy of an app for whatever reason. As it stands now, self hosting applications fill this niche, but it‚Äôs a niche: it requires a lot of time consuming expertise on the part of end users. With the personal cloud, we think many of the benefits of self-hosting are made accessible, which loops back to benefit app developers‚Äô distribution possibilities.

## Turn-key payments (planned for Space)

Developers have told us two things about taking their app to the next level:

1. They'd like to add some type of paywall & earn money once they start bringing external users onboard
2. Payments work ‚Äî in and of itself ‚Äî is fuss-y, infra like work. App devs would rather not do it.

So we thought about it, and wondered:
- Why should multiple app developers all have to implement a similar payment system into their app?
- Why should application users have to give billing information to every app they want to buy?

We think we can solve these problems with Deta Space, removing the payments work, just like we do for the other infra work. As a developer, we'd like you to have 'turn key' payments. Ideally you turn on a pricing knob, select a pricing model, provide your payment information and Deta will send you money every month.

## Control & interoperability (planned for Space)

On the personal cloud, we think control of the app and data is the biggest draw for end-users. This helps ensure that apps keep working if an app's developer decides to call it quits, while also providing privacy advantages.

For *users who are also developers*, we think control is a huge win, for an additional reason. This is because developers are fundamentally hackers and tinkerers who turn ideas into software, and personal computing fundamentally empowers them to do this. With personal control over apps and data, developers can hack and tinker their apps and data into more apps and data. We think this will allow developers to discover new frontiers in their own computational lives, paving the way for everyone else.

Build your first app on the personal cloud with Deta Space [here](/docs/en/introduction/first-app).
# first-app.mdx

## Prerequisites

The first thing to do is to create a Deta account if you haven‚Äôt already. You can [signup](https://deta.space/signup) in seconds, it‚Äôs completely free!

In this tutorial, we will launch a Space app built with Svelte. Deta Space supports any frontend framework alongside backend APIs built with Node, Python, Go, Rust or other custom binaries. We will only use Svelte for illustration purposes, but you can use any framework of your choice for this guide.

We will start by creating our Svelte app using the official instructions found on [Svelte.dev](https://svelte.dev/):

```bash
npm create vite@latest my-space-app -- --template svelte
```

Afterwards, let's make sure to go into the directory of our new Svelte app:

```bash
cd my-space-app
```

Now we are ready to continue with the Space specific steps.

## Installing the CLI

In this tutorial, we will use the Space [CLI](/docs/en/reference/cli) to create a new project on Space and then release it as a Space app.


<OSTabs>
  <Fragment slot="mac">
    To install the Space CLI on MacOS, open a Terminal session and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="win">
    To install the Space CLI on Windows, open PowerShell and enter:

    ```bash
    iwr https://get.deta.dev/space-cli.ps1 -useb | iex
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="linux">
    To install the Space CLI on Linux, open a Terminal and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

</OSTabs>

Once you have successfully installed the Space CLI, you'll need to log in to Space.

The Space CLI authenticates itself with 'Access Tokens'. You can create an access token under Settings in your Space. Just type 'settings' in Teletype to open them.

After you have generated a new key you can add it to the CLI using `space login`. It will prompt you for the key and then store it safely.

From a terminal type:

```bash
space login
```

After you've entered the key the Space CLI is ready to be used!

## Creating a project

A "[project](/docs/en/basics/projects)" allows you to start building an app, experiment with different Space features, test if your app works in a Space environment and finally release it to the public so others can get their own copies in their own personal clouds.

Let's create a new project inside our local directory with the following command:

```bash
space new
```

The CLI will ask you to name your project, we will call ours "awesome-app". Then it will try to detect which framework or language you are using and show you what's found. In our case it should correctly identify our Svelte app with the following message, prompting you to confirm:

```bash
‚öôÔ∏è No Spacefile found, trying to auto-detect configuration ...
üëá Deta detected the following configuration:

Micros:
name: frontend
 L src: .
 L engine: svelte

? Do you want to bootstrap "awesome-app" with this configuration? (y/n)
```

After confirming it will create a new project in [Builder](/docs/en/basics/projects#projects-in-builder) (a Space App for building and releasing Space Apps) and generate a [Spacefile](/docs/en/reference/spacefile) in your local directory:

```yaml
v: 0
micros:
  - name: frontend
    src: .
    engine: svelte
```

For now, it's enough to say that your `Spacefile` contains the configuration of your app which is used by Space to understand what your app looks like and how to run it.

The CLI also created a hidden `.space` directory locally which contains information necessary to work with your project in Builder. This file should not be included in your version control and was automatically added to your `.gitignore`, if you have initialized a Git repository.

After you've created a project you can view and manage it in [Builder](/docs/en/basics/projects#projects-in-builder). Builder is available on your Space Canvas.

## Pushing to Space

Now that we have created our project, we can push our local changes to a live Space environment.

Let's use another CLI command to do this:

```yaml
space push
```

`space push` will package and upload all the necessary files to create a new "[revision](/docs/en/basics/revisions#whats-a-revision)". A revision is a complete package of your app at a single point in time. New Revisions are created with each push. You can view this new revision by opening your project inside Builder. It will be shown on the "Develop" tab.

## Creating a release

The last step is to create a "[release](/docs/en/basics/releases)" out of our revision. A release makes your app installable to others.

Let's use one final CLI command:

```bash
space release
```

That's it, you can now share the release link with *anyone* you want and they will be able to install their own copy of your app in their Space.

Welcome to the Detaverse! üöÄ# why-deta.md

## Computers, ideas, and their authors

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/developer.gif" width="400px" />
</div>

We believe computers are incredible: one single tool can activate a tremendous diversity of human ideas. For this to happen, software developers play a *magical* role. They encode these ideas into a format usable to the computer, which puts them to work at a wonderous efficiency. This combination, of computers & apps, helps us throughout much of our everyday lives, automating much of the boring and routine. But it also lets us explore & author our own ideas, and create our own worlds. This is all made possible because a software developer sat down and turned an idea into an app. With computing, many of the limits of the doable are defined by the limits placed on the people sitting down and turning dreams into software.

## The modern cloud: destroying dreams

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/broken.gif" width="400px" />
<a target=‚Äù_blank‚Äù rel="noopener noreferrer" style="max-width: 100%; white-space: pre-wrap; word-break: break-word font-size: 9px; line-height: 1.15; padding-top: 4px; padding-bottom: 6px; padding-left: 2px; color: rgba(55, 53, 47, 0.65); font-style: italic;" href="https://64.media.tumblr.com/437f41a5c3525e3f5252b03f1c55b38c/tumblr_myhf2vr7Hy1r34zhyo6_400.gifv">source
</a>
</div>

In theory, combining computers and the internet is a huge win for activating these ideas. With ‚Äòcloud computing‚Äô, software becomes accessible to any human or computer with an internet connection. An idea is not tied to a single device and it can serve others, regardless of where they are. This magnifies the limits of the doable: we can instantly interact with & use the ideas of others, collaborate on authorship of new ideas, share our own worlds, and explore the worlds of others.

In practice, there are two big problems with cloud computing on today‚Äôs large ‚Äòpublic clouds‚Äô, *particularly for the  special group we mentioned earlier: software developers.*

First, the public cloud asks way too much from developers who want to move from an idea to working app. To deliver web applications that others can use, developers have to fight a steep tooth and nail battle creating, operating, and paying for a complex web of cloud infrastructure. We think this is holding back millions of developers around the world from delivering billions of incredible dreams that do.

Second, software developers are not just authors, they are critical *users* of computers. Many of their most important ideas for the rest of us come from dreaming and tinkering for themselves. Personal computing empowers them to do this, but the public cloud & its apps do not. Instead, developers have little control of their own personal 'cloud stuff', which is crucial raw material to build on top of, explore, and extend.

Without these issues, we think developers can unlock these frontiers in their own computing lives, paving the way for everyone else.

## Deta's next act: *the personal cloud*

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/drive.gif" width="400px" />
<a target=‚Äù_blank‚Äù rel="noopener noreferrer" style="max-width: 100%; white-space: pre-wrap; word-break: break-word font-size: 9px; line-height: 1.15; padding-top: 4px; padding-bottom: 6px; padding-left: 2px; color: rgba(55, 53, 47, 0.65); font-style: italic;" data-content-editable-leaf="true" contenteditable="false" href="https://64.media.tumblr.com/4951e22fd1e5d2fb91fa04057ec1b149/tumblr_mji8cbwQ921r34zhyo8_500.gifv">source
</a>
</div>

In short, at Deta we believe:
1. individual software developers around the world are the key to getting cloud computing right
2. the ‚Äòpublic cloud‚Äô is crippling their creativity with unnecessary complexity, costs, and limits

We've run into these issues ourselves and got pretty frustrated. So we decided to build a cloud that's a lot more personal and friendly for the individual developer. We see it as two things, to start:

- a personal launchpad for devs to bring their ideas into the world with ***0-ops***
- a personal computer in the cloud for devs to host and use their own apps and data

[Read on](/docs/en/introduction/personal-cloud) to learn about how the personal cloud works and some of the benefits we see for developers.
# start.md

## ‚ú® Key features

Deta Space is standing behind you, fully.

- **Fully managed servers**: App developers have an ops burden of zero, as they scale their users to space.

- **Fully managed data**: App developers don't have to worry about user data/compliance.

- **Fully managed security**: App developers don't think about security and auth - each user gets their own sandboxed app with managed auth.

- **Fully managed payments**: App developers can earn money with their apps, activated easy-peasy (planned).

## üíª Build your first Space app

Follow our [guide](/docs/en/introduction/first-app) on how to build your first app for Space. We also have tutorials on how to launch your favorite frameworks on Space in the **Quickstarts** section.

## üìö Learn Space

Learn about the key concepts of Space:

- [Apps](/docs/en/introduction/app-anatomy)
- [Micros](/docs/en/basics/micros)
- [Data storage](/docs/en/basics/data)
- [Development](/docs/en/basics/revisions)
- [Publishing](/docs/en/basics/releases)

*‚Ä¶ find our full API documentation under the **Reference** section.*

## üí¨ Join our community

We have a growing community of like minded developers who are happy to help or provide feedback on your Space projects. Join us on [Discord](https://go.deta.dev/discord)!

You can also follow us on [Twitter](https://twitter.com/detahq) to stay up to date on all the shenanigans.
# app-anatomy.md

## Computing with Micros

The 'brains' of an app are made up of what are called [Micros](/docs/en/basics/micros#whats-a-micro). A Micro is essentially a lightweight runtime capable of running different frameworks and languages. Micros are exposed via an HTTP endpoint. Micros within the same app can talk to one another.

## Storing and retrieving data

In addition to the compute provided by Micros, each app instance also has its own database called [Base](/docs/en/basics/data#base) and file store called [Drive](/docs/en/basics/drive#base). This data is sandboxed at the level of a single copy of the app; the data is separate from both other apps belonging to the same user and other users' copies of the same app. Nonetheless, the data is shared between all Micros inside a single copy of an app.

As a Space app developer, you'll code your app slightly differently than you would on the '[public cloud](/docs/en/introduction/personal-cloud#the-public-cloud)'. The good news is you do not have to worry about data separation or user authentication & authorization. You will end up writing a lot less code; you can code your app as if there is only one user, where auth 'just works'.

## Resource limits

A single app can consist of up to five Micros and an unlimited number of Bases and Drives. All these resources do not have to be created. Micros can be defined in your [Spacefile](/docs/en/reference/spacefile), while Bases and Drives can be created by your app during runtime.

On the public cloud, as a developer, you would pay and take responsibility for the resources 3rd party users consume through an app you wrote. On the personal cloud, this is completely different: the resources live with the users, so you do not need to worry about either.

## Developing and releasing your app

During development, you have access to a [Builder instance](/docs/en/basics/revisions#testing-changes) of your app. This instance gets continuously updated with your latest changes as soon as you push them to Deta. You can use this instance in Deta Space before "releasing" it.

On the personal cloud, Space apps are not "deployed" once, but they are "[released](/docs/en/basics/releases)". People can install releases of a Space app in their own Space.
# accessing-client-ip-address.md



You might want to collect some information about the clients accessing your app, like their IP address, which can be useful for analytics or security purposes. However, you might have noticed that when you directly try to access the IP address in your app, you receive `127.0.0.1` or an undefined response due to technical limitations.

Fortunately, there is a workaround that you can use to access the client's IP address. This is by using the [`CF-Connecting-IP` header](https://developers.cloudflare.com/fundamentals/get-started/reference/http-request-headers/#cf-connecting-ip), which is available when using [Cloudflare](https://www.cloudflare.com/) as the DNS provider for your [custom domain](/docs/en/basics/micros#custom-domains) with Cloudflare Proxy enabled. Cloudflare is a content delivery network (CDN) that acts as an intermediary between your website and your visitors, improving the speed and security of your site.

Once you've added your domain to Cloudflare, follow these steps:

1. Open [Canvas](https://deta.space/), click on the three dots (...) at the bottom right of your app's icon and select **Configuration** (or **Settings** if your app has been released) to open your app's settings

2. Click **Add Custom Domain** (in the Domains tab for released apps) and enter your domain name (e.g. `app-name.example.com`)

3. Go to the DNS settings in your [Cloudflare Dashboard](https://dash.cloudflare.com/) and add the required records. Make sure that **Cloudflare Proxy** is enabled when adding the A record.

![Cloudflare Proxy](/docs_assets/guides/accessing-client-ip-address/cloudflare-proxy.png)

> Make sure to change your SSL/TLS encryption mode to **Full** in the [Cloudflare Dashboard](https://dash.cloudflare.com/) before doing this to avoid any unexpected issues

4. Verify that your domain has been added. Now, you can use the `CF-Connecting-IP` header to determine your client's IP address when your app is accessed via the custom domain.

Here's an example of how to access the header in ExpressJS:

```js
app.get("/endpoint", (req, res) => {
  const ipAddress = req.get("CF-Connecting-IP");
  res.send(`Your IP address is ${ipAddress}`);
})
```

It's important to be note that the `CF-Connecting-IP` header can be spoofed, so you should always use additional security measures in conjunction with it.# sveltekit.md

## Configure your SvelteKit app
To run a SvelteKit app on Space, you'll need to use the SvelteKit node adapter: [`@sveltejs/adapter-node`](https://kit.svelte.dev/docs/adapter-node). If you already use the Node adapter, skip to the [next section](#run-it-on-space).


First, install the `@sveltejs/adapter-node` dependency:

```sh
npm install @sveltejs/adapter-node
```

Then, in your `svelte.config.js` file, replace the current adapter with the node adapter:

```js
import adapter from '@sveltejs/adapter-node';
// rest of the file
```


Your project is now configured to run on Space. Let's run it!

## Run it on Space
After making sure you've installed the [Space CLI](/docs/en/basics/cli), run the following command in your project's directory:

```sh
space new
```
Follow the prompts to give your app a name. Once that's done, let's push your app to Space:

```sh
space push
```

Great job! You've just deployed your first SvelteKit app on Space. You can now access your app at the URL provided by the CLI.# go.md



Space supports Go Micros, but it requires a bit more configuration.

- `engine` needs to be set to `custom`
- `commands` needs to include commands that build a binary
- `include` should be set to the binary file that is built as a result of running `commands`
- `dev` should be the command to start the program in development mode
- `run` should be the command to run the binary

Here is an example:

```yaml
v: 0
micros:
  - name: go-app
    src: ./src/go-app
    engine: custom
    dev: go run main.go
    commands:
      - go get
      - go build main.go
    run: ./main
    include:
      - main
```

- The first command `go get` installs any external packages/modules.
- The second command `go build main.go` builds the program into an executable file.
- `include` specifies which file(s) to include in the final package of the micro. In this case only our build binary file.
- Finally, `run` specifies the command that should be run to start the program. In this case, it is running the executable that was generated from the previous step.
# next.md



> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

If you don't have an existing Next app already you can create a new one by following the offical [Next instructions](https://nextjs.org/docs#automatic-setup).

For Space to be able to run Next it needs to be configured to ouput a standalone app. This ensures that the app is built to be served by a NodeJS server, refer to the [Next Docs](https://nextjs.org/docs/advanced-features/output-file-tracing#automatically-copying-traced-files) for more information.

Please modify `next.config.js` to set the output to `standalone`:

```jsx
/** @type {import('next').NextConfig} */
const nextConfig = {
    output: "standalone",
}

module.exports = nextConfig
```

Once you've edited your `next.config.js` file, just modify your [Spacefile](/docs/en/reference/spacefile/) file before [pushing changes](/docs/en/basics/revisions/) to Space.

Spacefile Configuration:

```yaml
v: 0
micros:
  - name: next-app
    src: ./src/fullstack/next-app
    engine: next
```
# custom.md



Deta Space supports most runtimes and frameworks out of the box without much configuration. The only requirements you have to keep in mind are:

- All web servers need to run on the port specified in the environment variable `PORT`
- 250 MB is the max size of the package
# nuxt.md



> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

If you don't have an existing Nuxt app already you can create a new one by following the offical [Nuxt instructions](https://v3.nuxtjs.org/getting-started/installation#new-project). Only Nuxt 3 is supported out of the box.

By default Nuxt will automatically output a standalone server which Space can run without additional configuration.

Once you've got a Nuxt 3 app locally paired with a [Space Project](/docs/en/basics/projects/), just modify your [Space Spacefile](/docs/en/reference/spacefile/) file before [pushing changes](/docs/en/basics/revisions/) to Space.

Space Spacefile configuration for Nuxt 3:

```yaml
v: 0
micros:
  - name: nuxt
    src: ./src/fullstack/nuxt
    engine: nuxt
```# node.md



To run a Node.js app on a Space Micro, **it is recommended to use Node.js v16** since it works with Space out of the box.

> ‚ö†Ô∏è Make sure that your Micro is configured to listen on the port number specified in the environment variable `PORT`.

Here's the Spacefile needed to get a basic Node.js app running on Space:

```yaml
v: 0
micros:
  - name: node-micro
    src: src/node
    engine: nodejs16
    dev: nodemon index.js
    run: "node index.js"
```

index.js

```js
const express = require('express')
const app = express()

const port = process.env.PORT

app.get('/', (req, res) => {
  res.send('Hello from Space!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
```

> ‚ÑπÔ∏è We use [`nodemon`](https://www.npmjs.com/package/nodemon) to watch for changes in our code and restart the server automatically. You can use any other tool you like.

If your Node Micro has a build step (e.g. because you are using TypeScript) use a config similar to the following:

```yaml
v: 0
micros:
  - name: node-micro
    src: src/node
    engine: nodejs16
    dev: "npm run dev"
    commands:
      - npm run build
    include:
      - build
    run: "node build/index.js"
```

- `commands` specifies which commands to run during build, in our case our NPM script `build`
- `include` specifies which directory to include in the final app package, everything else will be ignored. In our case we set it to the directory of our build output
- `dev` specifies the command to start your Micro in development mode. In our case running the `dev` script in our `package.json`
- `run` specifies the command to start your Micro. In our case running the `index.js` file in our `build` directory using `node`

> ‚ÑπÔ∏è Support for Node.js v18 is coming soon.
# static.md



> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

Static micros work out of the box with most frontend frameworks like React, Vue, and Svelte. Just set the right `engine` value in your [Space Spacefile](/docs/en/reference/spacefile/) and you are good to go:

```yaml
v: 0
micros:
  - name: frontend
    src: src/frontend-app
    engine: svelte # or react/vue
```

The following frameworks are supported configuration-free using `engine`:

- `react`
- `svelte`
- `vue`

For other frameworks the configuration is minimal.

Set the engine to `static` and specify the directory to serve with `serve`. If your framework has a build step, include your build command with the `commands` field:

```yaml
v: 0
micros:
  - name: frontend
    src: src/frontend-app
    engine: static
    dev: npm run dev
    commands:
      - npm run build
    serve: dist
```
# rust.md

## Step 1: Create a Space project
Make sure you have the [Space CLI installed and set up](/docs/en/basics/cli). Then, in the root directory of your Rust project, run the following to create a Space project and an empty [`Spacefile`](/docs/en/reference/spacefile):

```sh
space new
```

## Step 2: Configure your Spacefile

Configuring your project for Rust requires two steps. First, replace the contents of the `Spacefile` with the following:

```yaml
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: main
    src: .
    engine: custom
    dev: cargo run
    commands:
      - cargo build --release
    run: ./nameofyourbinary
    include:
      - target/release/nameofyourbinary
```

Make sure to replace `nameofyourbinary` with the name of your binary. Feel free to adjust the `commands` and `run` to your needs.

> __Explanation of the Spacefile:__
> - We are using the `custom` engine, which allows us to run any command we want
> - We are building the Rust app using `cargo build --release`
> - We are running the binary that was created in the previous step
> - We are including the binary in the final image (using `include`)
> - We are setting `src: .` as the current directory is the root of the Rust project
> - We are specifying a command to run during development using `dev`

Second,  create a `.spaceignore` file in the root of your project and add the following:

```
.git
target
```

## Step 3: Run it on Space

Now you can run your Rust app on Space:

```sh
space push
```

This will build your Rust app and push it to Space. You can now access your app at the URL provided by the CLI.
The build process will take a few minutes, as it has to build the Rust app from scratch.

`space push` is the same command you would also use to update your app.

Done! ‚ú®
# python.md

## Step 1: Code configuration

For Space to run your Python app, you need to have a file called `main.py` that contains the the main instance of your app, which __must__ be called `app`. You can structure your app however you want, but the `main.py` file must be in the root of your project. Make sure you also have a `requirements.txt` file that contains the dependencies of your app.

### Starlette
Here is an example of a simple Starlette app:

```yaml
v: 0
micros:
  - name: python-app
    src: ./src/python
    engine: python3.9
```

`main.py`
```python
from starlette.responses import PlainTextResponse


async def app(scope, receive, send):
    assert scope['type'] == 'http'
    response = PlainTextResponse('Hello, Space!')
    await response(scope, receive, send)
```

### FastAPI
Here is an example of a simple FastAPI app:

`main.py`
```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def read_root():
    return {"Hello": "Space!"}
```

### Flask
Here is an example of a simple Flask app:

`main.py`
```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello_world():
    return "Hello, Space!"
```


## Step 2: Run it on Space
Make sure you have the Space CLI installed & authenticated, then run the following command:

```bash
space new
```
This will create a new Space project in the current directory. You can then run the following command to push your code to Space:
> __Important__: before `space push`, we recommend creating a [`.spaceignore`](/docs/en/basics/revisions#ignoring-files-and-directories) file to ignore files that you don't want to be deployed to Space. For example, you should ignore `.git` and `.venv` folders.


```bash
space push
```

Great job! You've just deployed your Python app on Space. You can now access your app at the URL provided by the CLI.

## Limitations
- Space only supports Python 3.8 and 3.9
- Space only supports ASGI and WSGI apps (HTTP servers). So raw scripts won't work.
- Only `/tmp` is writable
- SQLite, MySQL, and PostgreSQL are not supported (we recommend using [Deta Base](/docs/en/reference/base/sdk), which is built into every Space app by default)
- Total size of deployed app is limited to 250MB (including dependencies, source code, etc). So many large dependencies like `numpy` or `streamlit` might not work, as well as larger models.

## Setting up local development

We recommend using virtual environment for local development. If you have listed your app dependencies in a `requirements.txt` file, you can install them to your virtual environment with the following commands:

```bash
# Create a virtual environment in the current directory
python -m venv .venv
# Activate the virtual environment
source .venv/bin/activate
# Install dependencies
pip install -r requirements.txt

# If you are using FastAPI, you will also need to install uvicorn
pip install uvicorn[standard]
```

Then you will need to setup the dev command inside your Spacefile. Just reference the executable file from your virtual environment:

```yaml
  - name: python-app
    src: ./src/python
    engine: python3.9
    dev: .venv/bin/uvicorn main:app --reload
```# guide.md

## The application

For this guide we will use a simple "Hello World" Next app.

TODO: show how to create a sample next app and how to run it locally

## Install the Deta CLI and login

Now we are ready to launch our app to Space which means we will need the Deta CLI. If you've already installed it, just carry on. If not, checkout our [installation guide](/docs/en/basics/cli).

## Create a Builder Project

We can create a new project inside our local directory with the `deta new` command:

```bash
deta new
```

The CLI will ask you for your project‚Äôs name and will try to detect which framework or language you are using based on your source code. It will show you the configuration it detected for your app and prompt you to confirm it. In our case it correctly indentified our Next app.

After confirming it will create a new project with Builder and generate a `space.yml` file in your local directory:

```yaml
v: 0
micros:
  - name: app
    src: ./src
    engine: next
```

This file contains the configuration of your app which is used by Space to understand what your app looks like and how to run it.

As you can see above it added a single [Micro](/docs/en/basics/micros#whats-a-micro) to our project.

## Configuring our Micro

You can find more information about the properties of `space.yml` file in the [Spacefile Reference](/docs/en/reference/spacefile).

TODO: show how to configure this micro

## Pushing to Space

Now that we have created our project we can push our local changes to Space.

We will once again use the CLI to do this:

```yaml
deta push
```

This will package and upload all the necessary files and create a new [revision](/docs/en/basics/revisions#whats-a-revision). A revision is a complete package of your app at a single point in time. New revisions are created with each push. You can view this new revision by opening your project inside Builder. It will be shown on the "Develop" tab.

## Creating a release

The last step is to create a [release](/docs/en/basics/releases) out of our revision. A release makes your app installable to others.

TODO: use the CLI instead of builder

To do this head to the ‚ÄúPublish‚Äù tab in Builder and click ‚ÄúCreate new release‚Äù.

There you can select a revision (choose the latest one in our case) and enter a version/tag. Since this is our first release we will call it `v1.0`. On the next page you can add a short description and listing text to this release. This will be shown on the [Discovery]() page before users will install your app. Once you are happy with everything hit ‚ÄúRelease‚Äù and watch your app take off!

You can share the release link with anyone you want and they will be able to install your app inside their Space.

Welcome to the Detaverse! üöÄ

# cloud.md


If you are migrating from Deta Cloud to Deta Space, take a look at our dedicated [Migration Hub](/migration).

# help.md
## Getting Help

We have answered some General [FAQs](/docs/en/other/faq) in these docs, but we are here to help and would love to hear what you think!

If you have any questions or feedback, you can reach us:
- Chat: [Discord](https://go.deta.dev/discord), (#space-mission channel, ask for access if we forgot to add you).

## Reporting Abuse

If you detect any kind of fraudulent, abusive and/or malicious content hosted on Deta, please report the site(s) by sending an email to us at [abuse@deta.sh](mailto:abuse@deta.sh).

We review each report.


# links.md


- [Discord](https://go.deta.dev/discord)
- [Twitter](https://twitter.com/detahq)
- [GitHub](https://github.com/deta)

# issues.md


# faq.md


# releases.md
## Creating releases

After you have [pushed changes](/docs/en/basics/revisions) to Space, you can turn a revision into an installable release.


### Releasing from the GUI

You can create a release for your project using [Builder](/docs/en/basics/projects#projects-in-builder).

Simply go to the "Develop" tab and click the "Create Release" button. The next page will let you select the [revision](/docs/en/basics/revisions) you would like to release and offer a version tag (this will be auto-generated if you leave it blank). After clicking next, you will be able to choose if your release should be `listed` on [Discovery](/discovery) or not and can optionally provide some [notes](#release-notes) for the release.

Once you are ready, click "Launch to Space". Then watch your app take off! Your app is now installable on Deta Space to anyone with the release url, which is provided on the following page.

### Releasing from the CLI

You can create a release using the [Space CLI](/docs/en/basics/cli). Simply use the following command:

```bash
space release
```

Pass the `--listed` argument to enable listing on [Discovery](/docs/en/basics/releases#discovery--app-pages).

Pass the `--notes` argument to add notes about the release (changes, features, etc). [More info below](#release-notes).

Then watch your app take off! Your app is now installable on Deta Space to anyone with the release url.

> You can provide specific options to your release (which revision to use, version tags, listed/unlisted) using specific options. See the cli reference for [`space release`](/docs/en/reference/cli#deta-release).

## Discovery & App Pages

Each release of your app is available for installation using [Discovery](/discovery) - Space's app marketplace.

![Screenshot of Discovery](/docs_assets/discovery.png)

There are two ways your app will be available on Discovery:

- **Unlisted**: If your app is *unlisted*, only people who have the link to your release will be able to view its page and install the app. This is the default behaviour when creating a release via the CLI or the UI.

- **Listed**: If your app is *listed*, it will be shown publicly on Discovery where other users can easily find and install it. To enable listing use the `--listed` argument in the CLI (`space release --listed`) or select "List on Discovery" when creating a release using Builder.

In both cases, your app will be available on its own page on Discovery.

Not only does your app's Discovery page allow users to install your app, it also gives you the opportunity to explain what your app does, how it is unique, and its features.

You can customize an app's Discovery page using a `Discovery.md` file, which gives you  a full Markdown description and options to specify things like an app title & tagline and links to a Git repository & homepage. More info on how to use the `Discovery.md` file to customize your app's Discovery page can be found in the [Discovery.md Reference](/docs/en/reference/discovery).

## App Updates

When you publish your app by creating a release, Deta creates an installable version of your app. If you update your app afterwards, you need to publish a new release. Anyone who has installed older versions of your app can update their instance to the latest release (they could also install a new instance). When updating an app, the data will be kept across the update.

> ‚ö†Ô∏è Important note: updates only work when the data your app stores are compatible with the new app version. In the future we will have data migrations to help with this. If a new release is not compatible with old versions, you need to create a separate app for it to prevent breaking installed apps.

Users of your app will be shown an update notification if you publish a **listed** release newer than the one they have installed. **Unlisted** releases will not be made available as updates.

## Release Notes

To notify your users of changes made with a new release you can add "Release Notes" to a release. These notes support the Markdown syntax with the [same limitations as the Discovery.md file](/docs/en/reference/discovery#supported-syntax).

Release notes will be shown to users of your app, before they install the release as an update and can be viewed on the app's Discovery page under "What's new?".

### Adding notes from the CLI

To add notes to a release you can use the `--notes` argument with the Space CLI:

```bash
space release --notes
```

It will prompt you to enter your release notes before creating the release. You can also provide a string to `--notes` directly to skip the prompt:

```bash
space release --notes="Fixed bug xyz"
```

### Adding notes from the GUI

During the publishing flow in Builder, you will be shown the option to add release notes as the second step.


# micros.mdx
## What's a Micro?

Deta Space can run almost any type of app. For example, Space supports:
- frontend sites built with frameworks like React, Vue and Svelte
- full-stack frameworks like Next, Nuxt or SvelteKit
- backend apps built with Node.js, Python and even Go, Rust or something more custom.

A Space app can also be built by combining these different technologies, for example, a SvelteKit app with a Go API, really any combination of up to 5 different languages/frameworks.

We call these individual parts of an app **Micros**. A Micro is a lightweight compute service running inside your app which can be exposed to the outside using HTTP.

Micros are defined in your project's [Spacefile](/docs/en/reference/spacefile), telling Deta Space what Micros your app contains and how to run them.

## Adding your first Micro

When you create a new project using the Space CLI, it will try to detect the type of app you want to deploy. This works for most frameworks like Next, Nuxt, SvelteKit, and backend runtimes like Node.js and Python.

If this detection works, it will show you what type of Micro is detected and its generated config. After you've confirmed the config is correct, the CLI will create the `Spacefile` in your local directory for you.

Even if this detection fails, Space supports almost any type of app via the `Spacefile`.

## Adding Micros via the Spacefile

If you want to run something more custom or need to add more Micros to an existing project, you can edit the project's `Spacefile` to add the required configuration.

Take a look at the [Spacefile reference](/docs/en/reference/spacefile) for a complete list of options.

Here's the `Spacefile` for an app consisting of a single Node.js Micro:

```yaml
v: 0
micros:
  - name: api
    src: ./node-api
    engine: nodejs16
    run: npm run start
```

The `name` field identifies your Micro inside your app and the `src` should point to the location of the Micro's source code relative to your project's root.

If your project contains more than one Micro, the `primary` field can be used to identify the entry point of your application (which Micro will be executed when the root path of your project is visited via HTTP).

## Directory structure

A Micro can be thought of as its own independent service. As a result, they need to be self-contained in their own directory in your project and your project root should not contain any Micro specific files.

Here's an example of the file & folder structure of an app with a Python backend and a Vue frontend:

```
Spacefile
backend/
    requirements.txt
    main.py
frontend/
    package.json
    src/
        index.vue
```

All files needed for the Vue frontend (including `package.json`) are inside the `frontend` directory, while all files needed for the Python backend are inside `backend`.

Here is the matching `Spacefile`:

```yaml
v: 0
micros:
  - name: frontend
    src: ./frontend
    engine: vue
    primary: true
  - name: backend
    src: ./backend
    engine: python3.9
```

> üîë It's recommended to put your first Micro in its own sub-directory of your project. A single Micro will work running in the root directory of your project, but this approach doesn't scale. You'll have to migrate this Micro as soon as you want to add a second Micro to your project.

## Micro Routing

Since your app can contain multiple Micros, the Space runtime needs to know what requests to route to which Micro.

On Space, this is handled by having a single primary Micro which receives all requests made to your app's root path `/`. Each other Micro defined in your [Spacefile](/docs/en/reference/spacefile) will be served under a specific path relative to your app's primary hostname. This is defined in the `path` field for each Micro in your `Spacefile`:

```yaml
v: 0
micros:
  - name: client
    src: ./client
    engine: svelte
    primary: true
    path: client
  - name: api
    src: ./api
    engine: nodejs16
    path: api
```
In this example, the `api` Micro will be available at `/api` while all other paths including the root `/` will be received by the primary Micro, in this case, the static Micro `client`.

If the path is missing, the path will fall back to the `name` field.

## Public Routes

If you want parts of your app to be available to the public (instead of being protected behind auth), you need to specify the routes with the `public_routes` keyword in your app's [Spacefile](/docs/en/reference/spacefile):

```yaml
micros:
  - name: backend
    src: backend
    engine: python3.9
    public_routes:
      - "/test" # exact match
      - "/public/*" # wildcards
      - "/api/*/docs" # wildcards can be placed anywhere
```

You can either match a route exactly, or use a wildcard (`*`) to match anything after it.

The paths specified with `public_routes` are _relative_ to a given Micro's root. This means you do not need to specify a Micro's own path as part of its own `public_routes`. For example, if `/api` is served by a secondary (backend) Micro, and you want to make the route `/api/public` public, then you only need to specify `/public` as a public route for this Micro:

```yaml
micros:
  - name: frontend
    src: frontend
    engine: static
    primary: true

  - name: backend
    src: backend
    path: api
    engine: python3.9
    public_routes:
    - "/public" # This Micro is served under `/api` so if we want to make `/api/public` available to the outside we only need to specify `/public`
```

Requests made to your Micro matching any of the routes defined in `public_routes` will bypass Space's authentication entirely.

## Cross Micro Communication

Micros within a project are independent services, but can call one another to get what they need.

How you can successfully call one Micro from another one depends on if the calling Micro is sending the request from the browser or server side (from).

### From the browser

If you are trying to call a backend Micro from another Micro in the browser, you can make requests to the relative path under which the Micro is served from:

```js
// In the browser
fetch('/api')
```

That's it. If Micros live in the same 'project', auth just works.

### Server side

If you are trying to call another Micro from the backend you need to get your app's assigned hostname to use as the origin, and use an api key to authenticate your request.

Both of these items are provided in the environment of the Micro:
- The primary hostname is under the `DETA_SPACE_APP_HOSTNAME` environment variable.
- The api key is under the `DETA_API_KEY` environment variable. This should be added as a header to your http request under `X-API-Key`.

Here's how you'd make a request to a second Micro (on the path `/second-micro`) within an app, using Python:

```python
import os

origin = f"https://{os.getenv('DETA_SPACE_APP_HOSTNAME')}"
api_key = os.getenv("DETA_API_KEY")
headers = {"x-api-key": api_key}

res = requests.get("/second-micro", headers=headers)
```

> ‚ö†Ô∏è If you expose this API Key, you risk compromising your Space app.

## API Keys

If you want users of your app to be able to access their app instance programmatically you can enable the `api_keys` preset for Micros in your app:

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      api_keys: true
```

If enabled, users of your app will be able to generate API keys in their app instance settings and use them to authenticate requests made to otherwise private routes of a Micro.

Generated keys need to be provided in the HTTP header `X-Space-App-Key` and only work with Micros that have the preset `api_keys` enabled. Public routes have a higher preference than API keys, if there are public routes specified these will always be public.

> Note: If you enable API keys you should show clearly in the app that API keys can be used and ideally have clear documentation on which endpoints of your app work with API key auth.

## Micro Environment Variables

### Pre-set Variables

The following environment variables will be set in all Micros,  accessible on the server side.

- `DETA_PROJECT_KEY` - deta project key
- `DETA_SPACE_APP` - will be set to `‚Äútrue‚Äù`
- `DETA_SPACE_APP_VERSION` - the app version
- `DETA_SPACE_APP_HOSTNAME` - will be set to the **primary** hostname
- `DETA_SPACE_APP_MICRO_NAME` - micro‚Äôs name
- `DETA_SPACE_APP_MICRO_TYPE` - will be set to `"primary"` if primary otherwise `‚Äúnormal‚Äù`

Please let us know if you need additional configuration.

### Custom Variables

Use the `env` preset if you need to set custom environment variables for your Micros. This can also be used to let users of your app specify things like external secrets or [API Keys](/docs/en/basics/extending_apps#api-keys) or [Data Keys](/docs/en/basics/extending_apps#data-keys) of different app instances.

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      env:
        - name: SECRET_MESSAGE
          description: Secret message only available to this Micro
          default: "deta is cool"
```

- `name` : environment variable name or key
- `description` : human friendly description (optional)
- `default` : default value for the variable (optional)

The user of the app will be shown a UI in the App's Settings where they can set the values for the specified environment variables. They will be exposed to the Micro's environment under the specified `name`.

## Custom Domains

If you already have your own domain you can assign it to any Builder or app instance with a few clicks. This ‚ÄúCustom Domain‚Äù works in addition to the default Space domain that gets assigned to an instance. The domain will be connected to the primary Micro of the app instance.

Follow just a few steps to add a custom domain to your app:

- To add a custom domain to a Builder instance, open the Builder project and head over to the "Develop" page and then to the "Configuration" tab. Click ‚ÄúAdd Domain‚Äù and enter your domain name.
- To add a custom domain to an app instance you installed, open the app settings by clicking the 3 dots (‚Ä¶) next to the app‚Äôs icon on the Canvas, click ‚ÄúSettings‚Äù and then switch to the ‚ÄúDomains‚Äù tab. Click ‚ÄúAdd Domain‚Äù and enter your domain name.

Before your domain is live, you need to setup a DNS record to point your domain to our servers. Follow the guide in our [User Manual](/manual/features/custom-domains) to learn how to do this.

## Scheduled Actions

Scheduled actions allow an app to perform certain tasks on a specific interval. These tasks can be anything you build into your app, from a cleanup job to automated data aggregation or revalidation.

### Adding a Scheduled Action

Scheduled actions are defined in the [Spacefile](/docs/en/reference/spacefile) on the Micro level:

```yaml
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

Each action with the trigger `schedule` needs to have a unique `id`, `name`, and `default_interval` at which it runs. You can optionally provide a description to inform the user about what the action is used for. More information on all the supported fields can be found in the [Spacefile Reference](/docs/en/reference/spacefile#actions).

When an action runs, a `POST` request containing the action `id` and the `trigger` in the event body will be sent to the Micro on the path `/__space/v0/actions`.

For example, the example Spacefile above will result in the following request body:

```json
{
  "event": {
    "id": "cleanup",
    "trigger": "schedule"
  }
}
```

It is up to you to handle the request and run whatever logic you need. You could for example call a function or interact with [Base](/docs/en/reference/base/about) and [Drive](/docs/en/reference/drive/about) through the Deta SDK:

<Tabs
  client:visible
  sharedStore="tabLang"
  defaultPanel="js"
  tabs={[
    { label: "JavaScript", value: "js" },
    { label: "Python", value: "py" }
  ]}
>
  <Fragment slot="panel.js">
  ```js
  // using express
  app.post('/__space/v0/actions', (req, res) => {
    const event = req.body.event

    if (event.id === "cleanup") {
      cleanup()
    }

    res.sendStatus(200)
  })
  ```
  </Fragment>
  <Fragment slot="panel.py">
  ```python
  # using flask
  @app.route('/__space/v0/actions', methods=['POST'])
  def actions():
    data = request.get_json()
    event = data['event']
    if event['id'] == 'cleanup':
      cleanup()
	```
  </Fragment>
</Tabs>

### Interval Types for Scheduled Actions

Space currently supports two types of intervals for scheduled actions:

- [Rates](/docs/en/reference/spacefile#rates) e.g. `2 hours`
- [Cron Expressions](/docs/en/reference/spacefile#cron-expressions) e.g. `0 10 * * *`

Check out the [Spacefile Reference](/docs/en/reference/spacefile#actions) on the exact syntax.

Scheduled actions have to be purposely enabled, setup and need to have a default interval which they will be executed on.

After installing an app, its scheduled actions are automatically enabled and set to run on the default interval. The user can at any point change the interval or disable an action completely. Check out the [User Manual](/manual/apps#schedules) on how scheduled actions are presented to app users.


# projects.md
## What's a project?

When building apps for Space, the first thing you will start with is a Space 'project'. A project allows you to start building an app, experiment with different Space features, test if your app works in the Space environment and finally release it to the public so others can start using it.

## Projects in Builder

Projects in Space live inside Builder, an app which can be found on your Canvas. Builder is your toolbox for building an app on Deta Space. It allows you to create new projects and manage them over time.

Each Project in Builder consists of 3 main pages:

- **Overview**: the overview page lets you see important information about your projects like its latest release and recent events

- **Develop**: the develop page allows you to configure and develop your project. Here you have access to your project resources like the development data as well as information about your Builder instance.

- **Publish**: the publish page allows you to create and manage releases of your app

## Creating a Project

You can create new projects using the [Deta Space CLI](/docs/en/basics/cli), which will guide you through the process.

Use the `space new` command to create a new project with the Space CLI:

```sh
space new
```

The CLI allows you to choose from a variety of templates to bootstrap your project or it can automatically set up the right project configuration based on what you have locally.

You will be prompted to enter a name for your project. Next, the CLI will try to detect any existing applications in your local directories. If found, the CLI will show a generated config for those applications.

Once you confirm the generated config, the CLI will create a new project in Builder and generate a [Spacefile](/docs/en/reference/spacefile) file in your local directory. The `Spacefile` contains the configuration of your app, used by Deta Space to understand what your app looks like and how to run it.

Additionally, the CLI created a hidden `.space` directory -- this contains information about the project, linking it to your Builder project. This directory should not be included in your version control and was automatically added to your `.gitignore`.

After you've created a project, you can view it inside the [Builder](/docs/en/basics/projects#projects-in-builder) app, which can be found on your Canvas in Space.

> Builder doesn't keep track of your source code, we recommend you use Git as a version control system.

## Project linking

Your local development environment is connected to Builder via a hidden `.space` directory, which contains a unique identifier: a project ID.

If you first run `space new` in a directory, the Space CLI will automatically connect the local directory via this ID with your newly created project in Builder.

If you ever need to connect an unlinked local directory to a project in Builder, you can use `space link` to link your current directory to the existing project:

```bash
space link
```

The CLI will prompt you to enter your project's ID and will then link your directory with the project on Space. This project ID is accessible in Builder in your project's "Develop" tab.


# cli.mdx
## Installation

<OSTabs>
  <Fragment slot="mac">
    To install the Space CLI on MacOS, open a Terminal session and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="win">
    To install the Space CLI on Windows, open PowerShell and enter:

    ```bash
    iwr https://get.deta.dev/space-cli.ps1 -useb | iex
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="linux">
    To install the Space CLI on Linux, open a Terminal and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

</OSTabs>


## Authentication

Once you have successfully installed the Space CLI, you'll need to log in to Deta Space.

The Space CLI authenticates itself with 'Access Tokens'. You can create an access token under Settings in your Space. Just type 'settings' in Teletype to open them.

After you have generated a new key you can add it to the CLI using `space login`. It will prompt you for the key and then store it safely.

From a terminal type:

```bash
space login
```

This command will ask for an 'access token' to authenticate your CLI.

```bash
? Enter access token >
```

To get an access token, enter your [Space dashboard](https://deta.space/), open the Teletype (command bar) and click 'Settings':

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli1.png" width="400px" />
</div>

This will open the Settings modal, where you can click 'Generate Token' to generate an access token:

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli2.png" width="400px" />
</div>

Copy the resulting token:

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/cli3.png" width="400px" />
</div>

You can paste this back into your CLI prompt. After you hit enter, you should be greeted by a success message.

```bash
üëç Login Successful!
```

Upon a successful log-in, you are ready to start building Space apps.


## CLI Commands

Run `space help` to get a overview of the available commands or refer to the [Reference section](/docs/en/reference/cli) for a complete list of CLI commands and options.

# revisions.md
## What's a revision

A revision is a complete package of your app at a single point in time. New revisions are created with each push. You can view this new revision by opening your project inside [Builder](/docs/en/basics/projects#projects-in-builder). It will be shown on the **Develop** tab.

A revision can now be used in your Space. It can also be used to [create a release](/docs/en/basics/releases), which you can share with others to install a copy of your app into their own Space!

## Testing changes

To test if your app works in Space, each project comes with your own personal *Builder instance*. This instance of your project is automatically kept up-to-date every time you successfully run `space push`.

The Builder instance is automatically added to your Canvas and can be used like any other app instance. You can also view your Builder instance via your Builder project under the **Develop** tab. Clicking the **Open Builder Instance** will open the instance.

If your Builder instance runs into a runtime error when handling a request, the error logs will be returned in the request's response. All runtime logs, including the error logs, are stored for 14 days and can be viewed in the **Develop** tab of your Builder project under **"Runtime Logs"**. The logs are sorted by time and can be filtered by a specific Micro using the dropdown. Runtime logs can help with debugging Space related errors and mis-configurations of your app.

The Builder instance shares its data with your whole Builder project, which you can [develop against](/data#developing-with-base-and-drive). You can also [view and update this data](/docs/en/basics/data#viewing-data) as you use your app. If you are also [developing your app locally](/docs/en/basics/local) using `space dev` the data will be shared between your local environment and the Builder instance.

## Ignoring files and directories

To exclude certain files and directories from being uploaded during `space push`, use the `.spaceignore` file. It acts similar to a `.gitignore` file, where each line in the file specifies a pattern. All files and directories matching the patterns will be excluded from `push`.

For example, a `.spaceignore` file with the following content `space push` will ignore the `test` and `docs` paths.

```
test
docs
```

Certain directories like the `node_modules` directory for node micros and the `__pycache__` directory for python micros are ignored by default and don't need to be specified in the `.spaceignore` file.

You can use an optional prefix `!` to negate the pattern; any matching file excluded by a previous pattern will become included again.

For eg, a `.spaceignore` file with the following content `space push` will not ignore the `node_modules` directory.

```
!node_modules/
```


# data.md
## How to store data

In addition to the compute provided Micros, each Deta Space app has its own database and file storage services. All the data stored with a Space app is 'sandboxed' within an application instance. By default, this storage is not shared across users and it's also not shared between a single user's app instances (interoperability between apps is planned).

As a result, you can just code your app as if it was only for a single user, without thinking about authentication or data separation.

### Deta Base

To store data, Space apps can use [Deta Base](/docs/en/reference/base/about),  a fully-managed, fast, and secure NoSQL database. Each app can create and use as many Bases as it needs. Base can be accessed using the [Deta Base SDK](/docs/en/reference/base/sdk) or the [Base HTTP API](/docs/en/reference/base/HTTP).

Take a look the the [Base Reference](/docs/en/reference/base/about) on how to use it.

### Deta Drive

To store files, Space apps can use [Deta Drive](/docs/en/reference/drive/about), a fully-managed, secure and scalable file storage service for Deta. Each app can create and use as many Drives as it needs. Drive can be accessed using the [Drive SDK](/docs/en/reference/drive/sdk) or the [Drive HTTP API](/docs/en/reference/base/HTTP).

Take a look the the [Drive Reference](/docs/en/reference/drive/about) on how to use it.

## Developing with Base and Drive

During development, you can share data between your local environment and your [project](/docs/en/basics/projects) in Space.

There is two ways to setup the Deta SDK to access the Bases & Drives of your project:

### Automatic setup

The Space CLI can automatically connect your local development environment with your Space Base & Drive using the `space dev` command.

More information on how to use the `space dev` command can be found in the in the [Developing Locally](/docs/en/basics/local) section.


### Manual setup

If the automatic set up does not work for your use-case, you can manually set up your local development environment by generating a data key from the "Data" tab on the "Develop" page, inside your Builder project.

If you are using an official Deta SDK, add this as an environment variable inside your dev environment:

```bash
DETA_PROJECT_KEY=<put_your_project_key_here>
```

The Deta SDKs will detect this key to access your development Bases and Drives.

If you are not using a Deta SDK, pass this Project Key using the `X-API-Key` header with the [Base HTTP API](/docs/en/reference/base/HTTP#auth) or [Drive HTTP API](/docs/en/reference/drive/HTTP#auth).

## Viewing data

Base and Drive both come with a UI where you can easily see, add, update and delete files and data. This UI is available inside Builder in the "Develop" tab under "Project Resources" and also through your Builder instance on your Canvas (click the `...` and then `View Data`).

For detailed guides, see the specific documentation for [Base UI](/docs/en/reference/base/base_ui) and [Drive UI](/docs/en/reference/drive/drive_ui).


# extending_apps.md
### API Keys

`API Keys` provide you with programmatic access to an installed app's HTTP APIs. Provided a developer has enabled API Keys, you can generate them from the "API Keys" tab in your "Settings" of the installed app.

The keys need to be provided under the `X-Space-App-Key` (case insensitive) header when making HTTP requests to the app.

Follow the specific documentation provided by the developer of the app on how to these APIs.


### Data Keys

`Data Keys` provide you direct access to data created by your installed Space apps. They allow you to read and manipulate your Space apps' data, and can be used to build custom integrations without explicit options (such as API Keys) from the app developer.

However, manipulating the data can result in breaking your app so use the keys with caution.

To generate Data Keys, go to the "Data Keys" tab in your "Settings" for your installed apps.

To use a Data Key, you can provide the key when initializing your `Deta` instance if you are using our official Deta SDKs.

An example in python:

```py
from deta import Deta

deta = Deta('your_data_key_here')
```

You need to create two different instances of `Deta` if you are connecting with two different apps.
Do not overwrite your `DETA_PROJECT_KEY` environment variable with this key, especially if you are building an integration from within a Space app.

If you are not using a Deta SDK, pass this key using the `X-API-Key` header with the [Base HTTP API](/docs/en/reference/base/HTTP#auth) or [Drive HTTP API](/docs/en/reference/drive/HTTP#auth). You need two separate HTTP clients if you want to connect to the data of two different apps.


# app_icon.md
## Make your app look good with a few tricks


The app icon is a crucial aspect for any Space App, as it influences its discoverability and overall perception. As the first visual element users encounter when browsing the Discovery Page, it can make or break a user's decision to download the app.

## Best Practices

Creating an effective app icon requires careful consideration of its display format, as it will be presented as a rectangle with a prominent rounded corner in the top-left (7x the size of a typical corner radius). To ensure optimal appearance, the icon should be designed as a full-bleed square image. Space applies a mask that seamlessly adapts the icon's corners to match the overall aesthetic.

An engaging and striking app icon can be achieved by incorporating a background of solid color or gradient with ample space around the centre. The centre should prominently feature the app's logo, which can be in 3D for added visual appeal. It is generally recommended to avoid using text in the icon, as it can make the icon appear cluttered and difficult to read.

The guidelines also include a safe zone where the logo should be placed to ensure it is always visible and not obscured by any elements like the top-left corner radius, app options menu in the bottom-right, or updates/notifications in the top-right.

![Safe Zone](/docs_assets/app_icon/guidelines.png)

This is the preferred and optimal size (512x512px). The centre place is where the logo should be, (196x196px).

![Size](/docs_assets/app_icon/size.png)

It is essential to avoid mimicking UI elements from your app in the design of your icon. Graphical images are usually preferred over photos as they tend to be more visually appealing and distinctive. Additionally, replicating first-party apps such as the Builder Icon is strictly prohibited, as it can cause confusion and may result in the removal of your app from the Discovery Page.

When selecting colors for the icon, it is important to ensure consistency with the overall design of the app to create a cohesive visual experience. Utilizing the same color scheme in both the icon and the app can aid users in easily identifying and remembering the app.

A well-chosen app name is short and memorable. This not only makes it easy for users to recall the app, but also ensures the name is clearly visible. A safe limit for text in the name is 10 characters, as longer names may be truncated depending on the letter width. Therefore, it is essential to keep the name concise.

We created an [Icon Tester](https://www.figma.com/community/file/1206563671424898764) for you to use in Figma. Use it to check if your icon is following the guidelines.

Here's a quick demo of how it works:
![Demo](/docs_assets/app_icon/demo.gif)

In order to enhance the Discovery App page, it is reccomened to extract the dominant color from the app icon and apply it as the theme color. This can be achieved by adding the following code snippet to the HTML document:

```html
<meta name="theme-color" content="#4285f4" />
```

This meta tag sets the browser theme color for the app, which is used by some browsers to customise the appearance of the browser UI elements, such as the address bar and the task switcher.


# local.md
## Starting a Development Server

Once you've created a Space project, you can start developing your app locally using the [Space CLI's](https://deta.space/docs/en/reference/cli) `space dev` command.

```bash
space dev
```

Behind the scenes, the Space CLI is:

- Generating and injecting a [Data Key](https://deta.space/changelog/post-6) so you can use the [Deta SDK](https://deta.space/docs/en/basics/data)
- Running each of your Micros in a separate process
- Exposing all of your Micros through a single entrypoint (following the routing in your Spacefile)

If you want to open the app in your browser automatically after starting your Micros, use the `--open` flag.

> Any data you save to Base or Drive using the Deta SDK will be stored in your Builder project. You can view and edit the data using the UI in the "Data" tab of the "Develop" page in your Builder project.

You can customize the development command for each Micro in your `Spacefile` using the `dev` key.

```yaml
v: 0
micros:
  - name: client
    src: ./client
    engine: svelte
    primary: true
    path: client
  - name: api
    src: ./api
    engine: nodejs16
    dev: nodemon index.js # start the micro in development mode
    path: api
```

The specified `dev` commands need to start a web server that listens on the port specified with the `PORT` environment variable. This way the CLI can properly forward requests to the Micro.

You can find instructions on how to setup the right `dev` command for each engine in the "Quickstart Guides".

## Advanced Usage

If you want to have more control over the development process, you can also split the `dev` command into two parts:

- First, start Micros individually using the `space dev up` command
- Then, start the reverse proxy using the `space dev proxy`

For our example above, this would look like this:

```bash
# Start the Micros individually
space dev up client
space dev up api

# Start the reverse proxy
space dev proxy
```

Some use cases for this approach include:

- Running each Micro in a separate terminal window
- Integrating Micros with other development tools (ex: vscode tasks)

The `space dev` command is just a shortcut for the combination of `space dev up` and `space dev proxy`.

## Running scheduled actions manually

You can trigger [scheduled actions](/docs/en/basics/micros#scheduled-actions) from your local development server by using the `space dev trigger` command.

First make sure you have defined a scheduled action in your Spacefile and set up the right handler in your Micro:

```yaml
v: 0
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

After starting your development server using either `space dev` or `space dev up`, you can trigger the action manually using the `space dev trigger` command:

```bash
space dev trigger cleanup
```

This will call your local action handler with a mock payload and print the returned response to your console.

## Running commands in the context of your project

If you don‚Äôt want to specify a dev command in your Spacefile or you want to run a one-off script while still benefitting from the automatic Base & Drive SDK setup you can wrap your command a `space exec` call:

```bash
# Run a command in the context of your project
space exec --project <project-id> -- npm run init-deta-base.py
```

If you run the command from a directory that is linked to a space app, you can omit the `--project` flag.

Some use cases include:

- testing Base & Drive locally
- pre-filling your projects Bases & Drives with data
- programmatically interacting with Base & Drive
- ‚Ä¶anything you can think of!


# teletype.md


# spacefile.md
## What's the Spacefile?

The `Spacefile` file contains the configuration of your app and is used by Deta Space to understand what your app looks like and how to run it.

The Spacefile file must be named `Spacefile` and needs to be in the root directory of your project. It uses a syntax similar to YAML, if you're new to YAML and want to learn more, see "[Learn YAML in Y minutes.](https://learnxinyminutes.com/docs/yaml/)".

You can use the [`space new`](/docs/en/reference/cli#space-new) command to let the [Space CLI](/docs/en/reference/cli) automatically create the `Spacefile` for you.

Here is an example `Spacefile`:

```yaml
v: 0
icon: ./icon.png
app_name: "My App"
micros:
  - name: python-app
    src: ./src/python
    engine: python3.9
    primary: true

  - name: custom-app
    src: ./src/custom
    engine: custom
    commands:
      - go get
      - go build main.go
    run: ./main
    include:
      - main
```

> To customize the appearence of your app on [Discovery](/discovery) you can add a  [`Discovery.md`](/docs/en/reference/discovery) file to your project.

## Options

Here are all the options supported by the `Spacefile`.

### `v` (version)

**Required**

The first key/value pair in your `Spacefile` should be the Spacefile version. The latest version at the moment is `0`.

```yaml
v: 0
```

### `icon`

*Optional*


Use `icon` to specify a path to an image file to use as your app's icon. The icon will be used wherever your app is displayed (e.g. the Canvas).

The path should be relative to your `Spacefile` and needs to point to a file inside your project's directory.

The image needs to be a PNG or WebP file of 512x512 pixels.

```yaml
icon: src/static/icon.png
```

### `app_name`

*Optional*

Use `app_name` to specify a name for your app. This name will be used wherever your app is displayed (e.g. the Canvas).

If it is not provided, `app_name` will fallback to your project's name.

The name can has a maximum of 12 characters. We recommend not exceeding 7 characters for optimal visibility across different screen sizes.

```yaml
app_name: My App
```

### `micros`

**Required**

The `micros` object is arguably the most important section in the `Spacefile`. It lists all the micros your app uses and configures each one individually.

#### `name`

**Required**

Each micro needs to have a unique `name` and **must follow the following rules:**

- can only contain alphanumeric characters and hyphen
- start with alphanumeric characters

```yaml
micros:
  - name: api
```

#### `src`

**Required**

Relative path to the root directory of the micro.

Each micro should be in its own directory which needs to contain all files required for the Micro to run.

```yaml
micros:
  - name: api
    src: ./api/
```

#### `engine`

**Required**

Runtime for the Micro, supported values:

- `static`
- `react`
- `svelte`
- `vue`
- `next`
- `nuxt`
- `svelte-kit`
- `python3.9`
- `python3.8`
- `nodejs16`
- `custom`

Example:

```yaml
micros:
  - name: api
    src: ./api/
    engine: nodejs16
```

Some engines require additional configuration. Refer to the "Quickstart Guides" section for more information about specific engines.

#### `primary`

**Required if your Spacefile contains more than one Micro**

If your app contains more than one Micro, use `primary` to identify which Micro should be used as the entry point of your application. The primary Micro will receive all requests made to your application which are not under another micro's path.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: svelte
    primary: true

  - name: backend
    src: ./backend/
    engine: nodejs16
```

#### `path`

*Optional*

If your app contains more than one Micro, use `path` to specify under which path relative to the hostname a Micro should receive requests. Requests are proxied so you your Micro will receive them at the root, no need to prefix your routes with the given Micro path.

If the `path` is missing, the path will fall back to the Micro `name`.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: svelte
    primary: true

  - name: backend
    src: ./backend/
    engine: nodejs16
    path: api
```

#### `serve`

*Required for static Micros*

Use `serve` to specify which directory should be served for your static Micro. All the files and directories inside the specified directory will be served relative to your Micro's path.

This option can only be used for Micro's with the `static` engine or engines based on it like `vue`, `react` and `svelte`.

```yaml
micros:
  - name: frontend
    src: ./frontend/
    engine: static
    serve: dist/
```

#### `commands`

*Optional*

Use `commands` to specify a set of commands to run before packaging the Micro.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    commands:
      - go get
      - go build main.go
```

#### `include`

*Optional*

Use `include` to specify which files and directories in your Micro's `src` should be part of the final app package. If `include` is used, everything not part of it will be ignored and won't be part of your app. You can specify multiple files and directories.

If your Micro uses a build step, `include` can be used to tell Space to only include the build output in your final app and ignore your source code and other unnecessary files.

```yaml
micros:
  - name: api
    src: ./api/
    engine: nodejs16
    commands:
      - npm run build
    include:
      - build/
      - images/
```

#### `run`

*Optional*

Use `run` to specify a command which starts your Micro. For the Micro to receive requests, it needs to listen on the port specified in the environment variable `PORT`.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    run: ./main
```

#### `dev`

Use `run` to specify a command which starts your Micro in **development** mode. This command will be used to start your micro when you run `deta dev`.

```yaml
micros:
  - name: api
    src: ./api/
    engine: custom
    run: ./main
    dev: go run main.go
```

#### `presets`

*Optional*

Specify different presets to use with your Micro.

##### `env`

*Optional*

Use the `env` preset to specify environment variables that the user can set for a Micro.

- `name` : environment variable name or key
- `description` : human friendly description
- `default` : default value for the variable

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      env:
        - name: SECRET_MESSAGE
          description: Secret message only available to this Micro
          default: "deta is cool"
```

More information on the `env` preset can be found in the [Micro Basics](/docs/en/basics/micros#custom-variables).

##### `api_keys`

*Optional*

Use the `api_keys` preset to enable the use of API keys to access a private routes of a Micro.

The user of your app will be able to generate API keys in the app settings and can use them in requests to a Micro using the `X-Space-App-Key` HTTP header.

```yaml
micros:
  - name: api
    src: ./api/
    engine: python3.9
    presets:
      api_keys: true
```

More information on API Keys can be found in the [Micro Basics](/docs/en/basics/micros#api-keys).

#### `public_routes`

*Optional*

Use `public_routes` to define which paths of your Micro should be available to the public. These routes will not be protected behind auth.

```yaml
micros:
  - name: backend
    src: backend
    engine: python3.9
    public_routes:
      - "/test" # exact match
      - "/public/*" # wildcards
      - "/api/*/docs" # wildcards can be placed anywhere
```

More information on public routes can be found in the [Micro Basics](/docs/en/basics/micros#public-routes).

#### `actions`

*Optional*

Specify actions that perform certain tasks inside your app on a specific trigger like a schedule.

```yaml
micros:
  - name: backend
    src: backend
    engine: nodejs16
    run: "node index.js"
    actions:
      - id: "cleanup"
        name: "Clean Up"
        description: "Cleans up unused data"
        trigger: "schedule"
        default_interval: "0/15 * * * *"
```

An action is compromised of the following fields:

- `id` (required): a unique identifier for the action (needs to be unique across the app)
- `name` (required): a human readable name for the action (needs to be unique across the app)
- `description` (optional): a human readable description for the action (max 142 chars)
- `trigger` (required): what triggers the action. Needs to be set to `schedule`.
- `default_interval` (required): interval with which the schedule will run at ([supported intervals](/docs/en/basics/micros#scheduled-actions))

When an action runs, a `POST` request containing the following body will be sent to the path `/__space/v0/actions` on your Micro:

```json
{
  "event": {
    "id": "cleanup",
    "trigger": "schedule"
  }
}
```

It is up to you to handle the request and run whatever logic you need.

Each scheduled action needs to have a default interval at which it runs at. Space currently supports two types of intervals:

##### Rates

You can define the rate at which an action should run. It is comprised of a value and unit.

- `value`: is a non-zero positive integer
- `unit`: unit of time, can be `minute`, `minutes`, `hour`, `hours`, `day`, `days`. If the value is `1` the unit must be `minute`, `hour` or `day`.

**Start Time**

The schedule starts from the time of installation rounded up to:

- `minute` ‚Üí next minute
- `hour` ‚Üí next nearest hour
- `day` ‚Üí next day at `00:00`

**Examples**

- `1 minute`: Run every minute
- `2 hours`: Run every two hours
- `5 days`: Run every five days

##### Cron Expressions

Cron expressions allow you more flexibility and precision when scheduling a task. Cron expressions have five required fields, which are separated by white space and run based on UTC.

| Field        | Values                            | Wildcards |
|--|--|
| Minute       | 0-59                              |  ,-*/     |
| Hour         | 0-23                              |  ,-*/     |
| Day-of-month | 1-31                              |  ,-*/     |
| Month        | 1-12 or jan-dec                   |  ,-*/     |
| Day-of-week  | 0-7 (0 or 7 is Sunday) or sun-sat |  ,-*      |

**Wildcards**

- The , (comma) wildcard includes additional values. In the Month field, jan,feb,mar would include January, February, and March.

- The - (dash) wildcard specifies ranges. In the Day field, 1-15 would include days 1 through 15 of the specified month.

- The * (asterisk) wildcard includes all values in the field. In the Hours field, * would include every hour. You cannot use * in both the Day-of-month and Day-of-week fields. If you use it in one, you must use ? in the other.

- The / (forward slash) wildcard specifies increments. In the Minutes field, you could enter 1/10 to specify every tenth minute, starting from the first minute of the hour (for example, the 11th, 21st, and 31st minute, and so on).

**Limits**

- You can't specify the Day-of-month and Day-of-week fields in the same cron expression. If you specify a value (or a *) in one of the fields, you must use a * (asterisk) in the other.

- Cron expressions that lead to rates faster than 1 minute are not supported.

**Examples**

- `0 10 * * *` : Run at 10:00 am (UTC) every day
- `15 12 * * *` : Run at 12:15 pm (UTC) every day
- `0 18 * * mon-fri` : Run at 6:00 pm (UTC) every Monday through Friday
- `0 8 1 * *` : Run at 8:00 am (UTC) every 1st day of the month
- `0/15 * * * *` : Run every 15 minutes
- `0/5 8-17 * * mon-fri` : Run every 5 minutes Monday through Friday between 8:00 am and 5:55 pm (UTC)


More information on scheduled actions and how to use them in your app can be found in the [Micro Basics](/docs/en/basics/micros#scheduled-actions).


# cli.md
## `space help`

Shows the help page

## `space login`

You can use `space login` to login to Space. The CLI will prompt you for an access token which it will use for future executions. Refer to the [Setting up the CLI](/docs/en/basics/cli#authentication) section for more details.

```bash
space login
```

## `space new`

You can use `space new` to create new projects.

Optional args:

- `-n, --name` string: name of the project
- `-d, --dir` string: where is the project (default ‚Äú./‚Äù)
- `-b, -‚Äîblank` bool: use this flag to create a blank project and ignore all the prompts

```bash
space new
```

## `space dev`

You can use `space dev` to start a local development server for your project. The cli will start one process for each of your micros, then expose a single enpoints for your space app.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-H, --host` string: host to run dev server on (default ‚Äúlocalhost‚Äù)
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev up`

You can use `space dev up` to start a single micro for local development.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev proxy`

You can use `space proxy` to start a reverse proxy for your micros. The micros will be automatically discovered and proxied to.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project
- `-H, --host` string: host to run dev server on (default ‚Äúlocalhost‚Äù)
- `-p, --port` string: port to run dev server on (default ‚Äú3000‚Äù)
- `-o, --open` bool: open dev server in browser after starting

## `space dev trigger`

You can use `space trigger` to manually trigger action. Make sure that the corresponding micro is running before triggering the action.

Optional args:

- `-d, --dir`  string: src of project to dev (default ‚Äú./‚Äù)
- `-i, --id`   string: id of the project

## `space push`

You can use `space push` to push your changes to Space and create a new revision. Space will automatically update your Builder instance with the new revision.

Optional args:

- `-d, --dir`   string: src of project to push (default "./")
- `-i, --id`    string: project id of project to push
- `-t, --tag`   string: tag to identify this push
- `-o, --open`  boolean: open builder instance/project in browser after push
- `--skip-logs` boolean: skip following logs after push

```bash
space push
```

If you don't want to follow the logs of the build and update, pass the `--skip-logs` argument which will exit the process as soon as the build is started instead of waiting for it to finish.

Tip: you can use the [`.spaceignore` file](/docs/en/basics/revisions#ignoring-files-and-directories) to exclude certain files and directories from being uploaded during push.

## `space release`

You can use `space release` to create new releases out of revisions.

Optional args:

- `-d, --dir` string: src of project to release (default "./")
- `-c, --confirm` boolean: confirm all prompts and release latest revision
- `-i, --id` string: project id of an existing project
- `-r, --rid` string: revision id for release
- `-l, --listed` boolean: enable listing on Discovery
- `-n, --notes` provide release notes via interactive prompt
- `--notes="<RELEASE_NOTES>"`: provide release notes directly
- `-v, --version` string: version for the release

```bash
space release
```

## `space link`

You can use `space link` to link a directory with a existing project.

Optional args:

- `-d, --dir` string: src of project to link (default "./")
- `-i, --id` string: project id of project to link

```bash
space link
```

## `space exec`

You can use `space exec` to run a command in the context of your project. The project key will be automatically injected into the environment.

Required args:

- `-p, --project`   string: id of the project

## `space open`

You can use `space open` to open your local project in the Builder UI on [deta.space](https://deta.space).

Optional args:

- `-d, --dir` string: directory of project to open (default "./")
- `-i, --id` string: project id of project to open

```bash
space open
```

## `space validate`

You can use `space validate` to validate your [Spacefile](/docs/en/reference/spacefile/) and check for errors.

Optional args:

- `-d, --dir` string: src of project to validate (default "./")

```bash
space validate
```


# discovery.md
## What's the Discovery.md file?

The `Discovery.md` file allows you to customize the presentation of your Space app on [Discovery](/discovery) - Space's app marketplace.

Write Markdown inside the `Discovery.md` file to explain what your app does, what makes it unique, and its features & functionality. You can think of it as your app's `README` for Deta Space.

In addition to the Markdown description, the `Discovery.md` file supports a Frontmatter section where you can specify metadata like your app's title, its tagline, a theme color and links to a Git repository & an app's website.

Here is an example `Discovery.md` file:

```md


Your apps, your data. Your *personal cloud computer*.

Space comes with:

- Fully managed servers
- Fully managed security
- Fully managed data
- Fully managed payments
```

You can see that the metadata is separate from the Markdown content by two lines of 3 dashes (``) is the Frontmatter section.

> The `Discovery.md` file is different from the [Spacefile](/docs/en/reference/spacefile). The `Discovery.md` file _only_ affects how your app appears on Deta Discovery. It is meant for marketing purposes, whereas the `Spacefile` is used for technical purposes: it tells Space how to run your app and what it looks like once it's installed.

The `Discovery.md` file is uploaded during `space push` and is part of a [revision](/docs/en/basics/revisions#whats-a-revision). When you create a release out of a revision the revision's `Discovery.md` file will be used.

## Options

There are no required options in the `Discovery.md` section, you can pick and choose what to use. We recommend that your app has at least a title and a short Markdown description explaining what it does.

**Note:** To change your app's name or icon you need to modify its [Spacefile](/docs/en/reference/spacefile) since these are used by Space for technical purposes, not just its marketing on Discovery.

Here are all the options supported by `Discovery.md`:

### `title`

Use `title` to give your app a friendly and descriptive name on Discovery.

This is different from the app name used once the app is installed. You can change that using the [`app_name`](/docs/en/reference/spacefile#app_name) option in the [Spacefile](/docs/en/reference/spacefile). The `title` will only be used on Discovery.

Choose a simple and memorable title and try to stand out. Avoid names that use generic terms or are too similar to existing app names.

The `title` needs to start with your app's name and can only have a maximum of `45` characters. We recommend the `title` follows the following format: `App Name: Short Description`.

Here's an example:

```yaml
title: "Space: The Personal Cloud"
```

### `tagline`

Use the `tagline` to provide a short description of your app. This will be shown across Discovery on both the app's page and in featured sections or search.

Your app‚Äôs `tagline` is intended to summarize your app in a concise phrase. Avoid generic descriptions and instead highlight features or typical uses of your app.

The `tagline` can be a maximum of `69` characters.

Here's an example:

```yaml
tagline: "Your own personal computer in the cloud: private, secure & always online."
```

### `theme_color`

Use `theme_color` to style the color of your app's Discovery page to match your app.

`theme_color` only supports hex color values.

```yaml
theme_color: "#f26daa"
```

### `git`

Use `git` to link to your app's Git repository, so users can view its source and can contribute to your app.

You can provide any valid Git URL including a link to a GitHub or GitLab repository.

```yaml
git: "https://github.com/deta/deta"
```

### `homepage`

Use `homepage` to link to an abitrary URL related to your app. This could be your app's marketing page or a documentation website for example.

```yaml
homepage: "https://deta.space"
```

## Markdown content

The main section in the `Discovery.md` file is the Markdown content. It will be displayed on your app's Discovery page similar to a README.

You can use it to describe what your app does in more detail, what makes it unique and/or highlight its features and functionality. The ideal description is a concise, informative paragraph followed by a short list of main features.

The Markdown description has a limit of `4250` characters.

Here's an example:

```md
Your apps, your data. Your *personal cloud computer*.

Space comes with:

- Fully managed servers
- Fully managed security
- Fully managed data
- Fully managed payments
```

### Supported Syntax

The `Discovery.md` file currently does not support the full Markdown spec. You cannot use the following:

- Images (in the future we will add support for app screenshots)
- HTML
- h1 (`#`) headings (they will be converted to h2)


# HTTP.mdx
## General & Auth

> You can get your **Project Key** and your **Project ID** of your Project in [Builder](https://deta.space/builder). You need these to talk with the Deta API.

> ‚ÑπÔ∏è Base currently supports **maximum 16 digit numbers** (integers and floating points), please store larger numbers as a string.

### Root URL
This URL is the base for all your HTTP requests:

**`https://database.deta.sh/v1/{project_id}/{base_name}`**

> The `base_name` is the name given to your database. If you already have a **Base**, then you can go ahead and provide it's name here. Additionally, you could provide any name here when doing any `PUT` or `POST` request and our backend will automatically create a new base for you if it does not exist. There is no limit on how many "Bases" you can create.

### Auth
A **Project Key** _must_ to be provided in the request **headers** as a value for the `X-API-Key` key for authentication. This is how we authorize your requests.

Example `'X-API-Key: a0abcyxz_aSecretValue'`.

### Content Type

We only accept JSON payloads. Make sure you set the headers correctly: `'Content-Type: application/json'`

## Endpoints

### Put Items

**`PUT /items`**

Stores multiple items in a single request. This request overwrites an item if the key already exists.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type    | Description                              |
|--|||
| `items`      | Yes      | `array` | An array of items `object` to be stored. |


    ##### Example

    ```json
    {
       // array of items to put
       "items": [
            {
                "key": {key}, // optional, a random key is generated if not provided
                "field1": "value1",
                // rest of item
            },
            // rest of items
        ]
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `207 Multi Status`

    ```js
    {
        "processed": {
            "items": [
                // items which were stored
            ]
        },
        "failed": {
           "items": [
               // items failed because of internal processing
           ]
        }
    }
    ```

    ##### Client errors

    In case of client errors, **no items** in the request are stored.

    ##### `400 Bad Request`

    ```js
    {
        "errors" : [
           // error messages
        ]
    }
    ```



    Bad requests occur in the following cases:
    - if an item has a non-string key
    - if the number of items in the requests exceeds 25
    - if total request size exceeds 16 MB
    - if any individual item exceeds 400KB
    - if there are two items with identical keys
  </Fragment>

</RequestTabs>




### Get Item

**`GET /items/{key}`**

Get a stored item.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| URL Parameter | Required | Type     | Description                                        |
|-|-|
| `key`         | Yes      | `string` | The key (aka. ID) of the item you want to retrieve |
  </Fragment>

  <Fragment slot="response">
    ##### `200 OK`

    ```js
    {
      "key": {key},
      // the rest of the item
    }
    ```

    ##### `404 Not Found`
    ```js
    {
      "key": {key}
    }
    ```
  </Fragment>

</RequestTabs>



### Delete Item

**`DELETE /items/{key}`**

Delete a stored item.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| URL Parameter | Required | Type     | Description                                       |
|-||
| `key`         | Yes      | `string` | The key (aka. ID) of the item you want to delete. |
  </Fragment>

  <Fragment slot="response">
    The server will always return `200` regardless if an item with that `key` existed or not.

    ##### `200 OK`

    ```json
    {
      "key": {key}
    }
    ```
  </Fragment>

</RequestTabs>



### Insert Item

**`POST /items`**

Creates a new item only if no item with the same `key` exists.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type     | Description            |
|--|-||
| `item`       | Yes      | `object` | The item to be stored. |

    ##### Example

    ```json
    {
        "item": {
            "key": {key}, // optional
            // rest of item
        }
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `201 Created`

    ```json
    {
      "key": {key}, // auto generated key if key was not provided in the request
      "field1": "value1",
      // the rest of the item
    }
    ```

    ##### Client errors

    ##### `409 Conflict` (if key already exists)

    ```json
    {
      "errors": ["Key already exists"]
    }
    ```

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
         // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if the item has a non-string key
    - if size of the item exceeds 400KB
  </Fragment>

</RequestTabs>



### Update Item

**`PATCH /items/{key}`**

Updates an item only if an item with `key` exists.

> If the *key* contains url unsafe or reserved characters, make sure to url-encode the *key*. Otherwise, it will lead to unexpected behavior.

<RequestTabs>

  <Fragment slot="request">
| JSON Payload | Required | Type              | Description                                                          |
|--|-|
| `set`        | no       | `object`          | The attributes to be updated or created.                             |
| `increment`  | no       | `object`          | The attributes to be incremented. Increment value can be negative.   |
| `append`     | no       | `object`          | The attributes to append a value to. Appended value must be a list.  |
| `prepend`    | no       | `object`          | The attributes to prepend a value to. Prepended value must be a list.|
| `delete`     | no       | `string array`    | The attributes to be deleted.                                        |

    ##### Example

    If the following item exists in the database

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the request

    ```json
    {
       "set" : {
         // change ages to 33
         "profile.age": 33,
         // change active to true
         "profile.active": true,
         // add a new attribute `profile.email`
         "profile.email": "jimmy@deta.sh"
       },

       "increment" :{
         // increment purchases by 2
         "purchases": 2
       },

       "append": {
         // append to 'likes'
         "likes": ["ramen"]
       },

       // remove attributes 'profile.hometown' and 'on_mobile'
       "delete": ["profile.hometown", "on_mobile"]
    }
    ```

    results in the following item in the database:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes": ["anime", "ramen"],
      "purchases": 3
    }
    ```
  </Fragment>

  <Fragment slot="response">
    ##### `200 OK`

    ```json
    {
       "key": {key},
       "set": {
         // identical to the request
       },
       "delete": ["field1", ..] // identical to the request
    }
    ```

    ##### Client errors

    ##### `404 Not Found` (if key does not exist)

    ```json
    {
      "errors": ["Key not found"]
    }
    ```

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
         // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if you're updating or deleting the `key`
    - if `set` and `delete` have conflicting attributes
    - if you're setting a hierarchical attribute but an upper level attribute does not exist, for eg. `{"set": {"user.age": 22}}` but `user` is not an attribute of the item.
  </Fragment>

</RequestTabs>



### Query Items

**`POST /query`**

List items that match a [query](/docs/en/reference/base/queries).

<RequestTabs>

  <Fragment slot="request">
| JSON Payload    | Required | Type     | Description                                    |
|-|---|
| `query`         | No       | `list`   | list of a [query](/docs/en/reference/base/queries)|
| `limit`         | No       | `int`    | no of items to return. min value 1 if used     |
| `last`          | No       | `string` | last key seen in a previous paginated response |


    ##### Example

    ```json
    {
       "query": [
            // separate objects in the list are ORed
            // query evaluates to list all users whose hometown is Berlin and is active OR all users who age less than 40
            {"user.hometown": "Berlin", "user.active": true},
            {"user.age?lt": 40}
       ],
       "limit": 5,
       "last": "afsefasd" // last key if applicable
    }
    ```
  </Fragment>

  <Fragment slot="response">
    The response is paginated if data process size exceeds 1 MB (before the query is applied) or the total number of items matching the `query` exceeds the `limit` provided in the request.

    For paginated responses, `last` will return the last key seen in the response. You must use this `key` in the following request to continue retreival of items. If the response does not have the `last` key, then no further items are to be retreived.

    > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
    >
    > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

    ##### `200 OK`

    ```json
    {
        "paging": {
            "size": 5, // size of items returned
            "last": "adfjie" // last key seen if paginated, provide this key in the following request
        },
        "items": [
           {
             "key": {key},
             // rest of the item
           },
           // rest of the items
       ]
    }
    ```

    ##### Client Errors

    ##### `400 Bad Request`

    ```json
    {
      "errors": [
        // error messages
      ]
    }
    ```

    Bad requests occur in the following cases:
    - if a query is made on the `key`
    - if a query is not of the right format
    - if `limit` is provided in the request and is less than 1
  </Fragment>

</RequestTabs>



## Issues

If you run into any issues, consider reporting them in our [Github Discussions](https://github.com/orgs/deta/discussions).

# async_sdk.md
## Installing

```
pip install deta[async]==1.1.0a2
```

## Instantiating

```py
from deta import Deta

# initialize with a project key
# you can also init without specfying the project key explicitly
# the sdk looks for the DETA_PROJECT_KEY env var in that case
deta = Deta("project_key")

# create an async base client
async_db = deta.AsyncBase("base_name")
```

## Methods

The **`AsyncBase`** class offers the same API to interact with your Base as the **`Base`** class:

### Put

```py
put(
	data: typing.Union[dict, list, str, int, float, bool],
	key: str = None,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime]
)
```

- **data** (required): The data to be stored.
- **key** (optional): The key to store the data under. It will be auto-generated if not provided.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](#./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def put_item():
	item = {"msg": "hello"}
	await async_db.put(item, "test")
	print("put item:", item)

	# put expiring items
	# expire item in 300 seconds
	await async_db.put(item, expire_in=300)

	# with expire at
	expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
	await async_db.put({"name": "max", "age": 28}, "max28", expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(put_item())
```

### Get

```py
get(key: str)
```

- **key** (required): The key of the item to be retrieved.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def get_item():
	item = await async_db.get("my_key")
	print("got item:", item)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(get_item())
```

### Delete

```py
delete(key: str)
```

- **key** (required): The key of the item to delete.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def del_item():
	await async_db.delete("my-key")
	print("Deleted item")

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(del_item())
```

### Insert

`insert` is unique from `put` in that it will raise an error if the `key` already exists in the database, whereas `put` overwrites the item.

```py
insert(
	data: typing.Union[dict, list, str, int, float, bool],
	key: str = None,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **data** (required): The data to be stored.
- **key** (optional): The key to store the data under, will be auto generated if not provided.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def insert_item():
	item = {"msg": "hello"}
	await async_db.insert(item, "test")
	print("inserted item:", item)

	# put expiring items
    # expire item in 300 seconds
    await async_db.insert(item, expire_in=300)

    # with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    await async_db.insert({"name": "max", "age": 28}, "max28", expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(insert_item())
```

### Put Many

```py
put_many(
	items: typing.List[typing.Union[dict, list, str, int, bool]],
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **items** (required): list of items to be stored.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def put_items():
	items = [{"key": "one", "value": 1}, {"key": "two", "value": 2}]
	await async_db.put_many(items)
	print("put items:", items)

	# put with expiring items
	# expire in 300 seconds
	await async_db.put_many(items, expire_in=300)

	# with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    await async_db.put_many(items, expire_at=expire_at)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(put_items())
```

### Update

```py
update(
	updates:dict,
	key:str,
	*,
	expire_in: int = None,
	expire_at: typing.Union[int, float, datetime.datetime] = None
)
```

- **updates** (required): A dict describing the updates on the item, refer to [updates](/docs/en/reference/base/sdk#update) for more details.
- **key** (required): The key of the item to update.
- **expire_in** (optional) - Accepts: `int` and `None`
    - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
- **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
    - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def update_item():
	updates = {"profile.age": 20, "likes": async_db.util.append("ramen")}
	await async_db.update(updates, "jimmy")
	print("updated user jimmy")

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(update_item())
```

### Fetch

**`fetch(query=None, limit=1000, last=None)`**

- **query** : a [query or a list of queries](/docs/en/reference/base/queries)
- **limit** : the limit of the number of items you want to recieve, min value `1` if used.
- **last**: the last key seen in a previous paginated response.

##### Example

```py
import asyncio
from deta import Deta

async_db = Deta("project_key").AsyncBase("base_name")

async def fetch_items():
	query = {"profile.age?gt": 20}
	res = await async_db.fetch(query)
	print("fetched items": res.items)

	# close connection
	await async_db.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(fetch_items())
```




# sdk.mdx
## Installing

<br />
<LangTabs>
  <Fragment slot="js">
  Using NPM:

    ```shell
    npm install deta
    ```

    Using Yarn:
    ```shell
    yarn add deta
    ```

  </Fragment>
  <Fragment slot="py">
  ```shell
	pip install deta
	```
  </Fragment>
  <Fragment slot="go">
  ```shell
	go get github.com/deta/deta-go
	```
  </Fragment>
</LangTabs>

> If you are using the Deta SDK within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your dependencies file (`package.json` or `requirements.txt`) to install the latest sdk version.



## Instantiating

To start working with your Base, you need to import the `Deta` class and initialize it with a **Project Key**. Then instantiate a subclass called `Base` with a database name of your choosing.

Deta Bases are created for you automatically when you start using them.

<br />
<LangTabs>

  <Fragment slot="js">
    ```js
    const { Deta } = require('deta'); // import Deta

    // Initialize with a Project Key
    const deta = Deta('project key');

    // This how to connect to or create a database.
    const db = deta.Base('simple_db');

    // You can create as many as you want without additional charges.
    const books = deta.Base('books');
    ```

    > If you are using Deta Base within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), the **Deta SDK** comes pre-installed and a valid project key is pre-set in the Micro's environment. There is no need to install the SDK or pass a key in the initialization step.
    > ```js
    > const { Deta } = require('deta');
    >
    > const deta = Deta();
    > ```

    > If you are using the `deta` npm package of `0.0.6` or below, `Deta` is the single default export and should be imported as such.
    > ```js
    > const Deta = require('deta');
    > ```
  </Fragment>

  <Fragment slot="py">
    ```py
    from deta import Deta  # Import Deta

    # Initialize with a Project Key
    deta = Deta("project key")

    # This how to connect to or create a database.
    db = deta.Base("simple_db")

    # You can create as many as you want without additional charges.
    books = deta.Base("books")

    ```

    > If you are using Deta Base within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), the **Deta SDK** comes pre-installed and a valid project key is pre-set in the Micro's environment. There is no need to install the SDK or pass a key in the the initialization step.
    > ```py
    > from deta import Deta
    >
    > deta = Deta()
    > ```
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        func main() {

          // initialize with project key
          // returns ErrBadProjectKey if project key is invalid
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          // initialize with base name
          // returns ErrBadBaseName if base name is invalid
          db, err := base.New(d, "base_name")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
            return
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        ```go
        import (
          "fmt"
          "github.com/deta/deta-go"
        )

        func main(){
          // initialize with project key
          // returns ErrBadProjectKey if project key is invalid
          d, err := deta.New("project_key")
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          // initialize with base name
          // returns ErrBadBaseName if base name is invalid
          db, err := d.NewBase("base_name")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
            return
          }
        }
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

</LangTabs>

> ‚ö†Ô∏è Your project key is confidential and meant to be used by you. Anyone who has your project key can access your database. Please, do not share it or commit it in your code.



## Using

Deta's **`Base`** class offers the following methods to interact with your Deta Base:

[**`put`**](#put) ‚Äì Stores an item in the database. It will update an item if the key already exists.

[**`insert`**](#insert) ‚Äì Stores an item in the database but raises an error if the key already exists. (2x slower than `put`).

[**`get`**](#get) ‚Äì Retrieves an item from the database by its key.

[**`fetch`**](#fetch) ‚Äì Retrieves multiple items from the database based on the provided (optional) filters.

[**`delete`**](#delete) ‚Äì Deletes an item from the database.

[**`update`**](#update) ‚Äì Updates an item in the database.



##### Storing Numbers

> ‚ö†Ô∏è Base currently supports **maximum 16 digit numbers** (integers and floating points), please store larger numbers as a string.



### Put

`put` is the fastest way to store an item in the database.

If an item already exists under a given key, put will replace this item.

In the case you do not provide us with a key, we will auto generate a 12 char long string as a key.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async put(data, key = null, options = null)`**

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` and `array`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `string`, `null` or `undefined`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull put operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    ##### Code Example

    ```js
    const Deta = require('deta');

    const deta = Deta("project key");
    const db = deta.Base("simple_db");

    // store objects
    // a key will be automatically generated
    await db.put({name: "alex", age: 77})
    // we will use "one" as a key
    await db.put({name: "alex", age: 77}, "one")
    // the key could also be included in the object itself
    await db.put({name: "alex", age: 77, key:"one"})

    // store simple types
    await db.put("hello, worlds")
    await db.put(7)
    // "success" is the value and "smart_work" is the key.
    await db.put("success", "smart_work")
    await db.put(["a", "b", "c"], "my_abc")

    // put expiring items
    // expire item in 300 seconds
    await db.put({"name": "alex", age: 21}, "alex21", {expireIn: 300})
    // expire item at expire date
    await db.put({"name": "max", age:28}, "max28", {expireAt: new Date('2023-01-01T00:00:00')})
    ```

    ##### Returns

    `put` returns a promise which resolves to the item on a successful put, otherwise it throws an Error.
  </Fragment>

  <Fragment slot="py">
    ```py
    put(
      data: typing.Union[dict, list, str, int, float, bool],
      key: str = None,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `dict`, `str`, [`int`](#storing-numbers), [`float`](#storing-numbers), `bool` and `list`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `str` and `None`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)


    ##### Code Example
    ```py
    from deta import Deta
    deta = Deta("project key")
    db = deta.Base("simple_db")

    # store objects
    # a key will be automatically generated
    db.put({"name": "alex", "age": 77})
    # we will use "one" as a key
    db.put({"name": "alex", "age": 77}, "one")
    # the key could also be included in the object itself
    db.put({"name": "alex", "age": 77, "key": "one"})

    # simple types
    db.put("hello, worlds")
    db.put(7)
    # "success" is the value and "smart_work" is the key.
    db.put("success", "smart_work")
    db.put(["a", "b", "c"], "my_abc")

    # expiring items
    # expire item in 300 seconds
    db.put({"name": "alex", "age": 23}, "alex23", expire_in=300)
    # expire item at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put({"name": "max", "age": 28}, "max28", expire_at=expire_at)
    ```

    ##### Returns

    `put` returns the item on a successful put, otherwise it raises an error.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Put(item interface{}) (string, error)`**

        ##### Parameters

        - **item** : The item to be stored, should be a `struct` or a `map`. If the item is a `struct` provide the field keys for the data with json struct tags. The key of the item must have a json struct tag of `key`. For storing expiring items, the field name `__expires` should be used with a [Unix Time](https://pkg.go.dev/time#Time.Unix) value, see also [expiring items](./expiring_items).

        [Note for storing numbers](#storing-numbers)

        ##### Code Example
        ```go

        import (
          "log"
          "time"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          // json struct tag 'key' used to denote the key
          Key      string   `json:"key"`
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
          // json struct tag '__expires' for expiration timestamp
          // 'omitempty' for omission of default 0 value
          Expires  int64 `json:"__expires,omitempty"`
        }

        func main() {
          // errors ignored for brevity
          d, _ := deta.New(deta.WithProjectKey("project_key"))
          db, _ := base.New(d, "users")

          u := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }
          key, err := db.Put(u)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("successfully put item with key", key)

          // can also use a map
          um := map[string]interface{}{
            "key":      "kasdlj1",
            "username": "jimmy",
            "active":   true,
            "age":      20,
            "likes":    []string{"ramen"},
          }
          key, err = db.Put(um)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("Successfully put item with key:", key)

          // put with expires
          u := &User{
            Key: "will_be_deleted",
            Username: "test_user",
            Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, 0, time.UTC).Unix(),
          }
          key, err = db.Put(u)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("put item with key:", key)

          // put map with expires
          um = map[string]interface{}{
            "key": "will_be_deleted",
            "test": true,
            "__expires": time.Data(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
          }
          key, err = db.Put(um)
          if err != nil {
            log.Fatal("failed to put item:", err)
          }
          log.Println("put item with key:", key)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Put(item interface{}) (string, error)`**

        ##### Parameters

        - **item** : The item to be stored, should be a `struct` or a `map`. If the item is a `struct` provide the field keys for the data with json struct tags. The key of the item must have a json struct tag of `key`. For storing expiring items, the field name `__expires` should be used with a [Unix Time](https://pkg.go.dev/time#Time.Unix) value, see also [expiring items](./expiring_items).

        [Note for storing numbers](#storing-numbers)

        ##### Code Example
        ```go
        import (
            "log"
            "time"
            "github.com/deta/deta-go"
        )

        // User represents a user
        type User struct{
            // json struct tag 'key' used to denote the key
            Key      string `json:"key"`
            Username string `json:"username"`
            Active   bool `json:"active"`
            Age      int `json:"age"`
            Likes    []string `json:"likes"`
            // json struct tag '__expires' for expiration timestamp,
            // tag has 'omitempty' for ommission of default 0 values
            Expires  int64 `json:"__expires,omitempty"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a user
            u := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }

            // put item in the database
            key, err := db.Put(u)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // can also use a map
            um := map[string]interface{}{
              "key": "kasdlj1",
              "username": "jimmy",
              "active": true,
              "age": 20,
              "likes": []string{"ramen"},
            }

            key, err = db.Put(um)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // expiring items
            u = &User {
              Key: "will_be_deleted",
              Username: "test_user",
              Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
            }
            key, err = db.Put(u)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)

            // maps with expiration timestamp
            um = map[string]interface{}{
              "key": "will_be_deleted",
              "test": true,
              "__expires": time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
            }

            key, err = db.Put(um)
            if err != nil {
                log.Fatal("failed to put item:", err)
            }
            log.Println("put item with key:", key)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns the `key` of the item stored and an `error`. Possible error values:

    - `ErrBadItem` : bad item, item is of unexpected type
    - `ErrBadRequest`: item caused a bad request response from the server
    - `ErrUnauthorized`: unuathorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Get
`get` retrieves an item from the database by it's `key`.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async get(key)`**

    ##### Parameters

    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of which item is to be retrieved.

    ##### Code Example

    ```js
    const item = await db.get('one'); // retrieving item with key "one"
    ```


    ##### Returns

    If the record is found, the promise resolves to:
    ```js
    {
      name: 'alex', age: 77, key: 'one'
    }
    ```
    If not found, the promise will resolve to `null`.
  </Fragment>

  <Fragment slot="py">
    ```py
    get(key: str)
    ```

    ##### Parameter Types

    - **key** (required) ‚Äì Accepts: `str`
        - Description: the key of which item is to be retrieved.

    ##### Code Example
    ```py
    item = db.get("one") # retrieving item with key "one"
    ```

    ##### Returns

    If the record is found:
    ```py
    {
      "name": "alex", "age": 77, "key": "one"
    }
    ```

    If not found, the function will return `None`.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Get(key string, dest interface{}) error`**

        ##### Parameters
        - **key**: the key of the item to be retrieved
        - **dest**: the result will be stored into the value pointed by `dest`

        ##### Code Example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // a variable to store the result
          var u User

          // get item
          // returns ErrNotFound if no item was found
          err = db.Get("kasdlj1", &u)
          if err != nil {
            fmt.Println("failed to get item:", err)
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Get(key string, dest interface{}) error`**

        ##### Parameters
        - **key**: the key of the item to be retrieved
        - **dest**: the result will be stored into the value pointed by `dest`

        ##### Code Example

        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a variable to store the result
            var u User

            // get item
            // returns ErrNotFound if no item was found
            err := db.Get("kasdlj1", &u)
            if err != nil{
                fmt.Println("failed to get item:", err)
            }
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns an `error`. Possible error values:

    - `ErrNotFound`: no item with such key was found
    - `ErrBadDestination`: bad destination, result could not be stored onto `dest`
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Delete
`delete` deletes an item from the database that matches the key provided.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async delete(key)`**

    ##### Parameters
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of which item is to be deleted.

    ##### Code Example

    ```js
    const res = await db.delete("one")
    ```



    ##### Returns

    Always returns a promise which resolves to `null`, even if the key does not exist.
  </Fragment>

  <Fragment slot="py">
    ```py
    delete(key: str)
    ```

    ##### Parameters
    - **key** (required) ‚Äì Accepts: `str`
        - Description: the key of the item that is to be deleted.

    ##### Code Example

    ```py
    res = db.delete("one")
    ```

    ##### Returns

    Always returns `None`, even if the key does not exist.
  </Fragment>

  <Fragment slot="go">
    **`Delete(key string) error`**

    ##### Parameters
    - **key**: the key of the item to be deleted
    ##### Code Example
    ```go
    // delete item
    // returns a nil error if item was not found
    err := db.Delete("dakjkfa")
    if err != nil {
      fmt.Println("failed to delete item:", err)
    }
    ```
    ##### Returns

    Returns an `error`. A `nil` error is returned if no item was found with provided `key`. Possible error values:

    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Insert
The `insert` method inserts a single item into a **Base**, but is unique from [`put`](#put) in that it will raise an error of the `key` already exists in the database.

> ‚ÑπÔ∏è `insert` is roughly 2x slower than [`put`](#put).

<br />
<LangTabs>

  <Fragment slot="js">
    **`async insert(data, key = null, options = null)`**

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` and `array`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `string` and `null`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull insert operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).


    ##### Code Example
    ```js
    // will succeed, a key will be auto-generated
    const res1 = await db.insert('hello, world');

    // will succeed.
    const res2 = await db.insert({message: 'hello, world'}, 'greeting1');

    // will raise an error as key "greeting1" already existed.
    const res3 = await db.insert({message: 'hello, there'}, 'greeting1');

    // expire item in 300 seconds
    await db.insert({message: 'will be deleted'}, 'temp_key', {expireIn: 300})

    // expire at date
    await db.insert({message: 'will be deleted'}, 'temp_key_2', {expireAt: new Date('2023-01-01T00:00:00')})
    ```

    ##### Returns

    Returns a promise which resolves to the item on a successful insert, and throws an error if the key already exists.
  </Fragment>

  <Fragment slot="py">
    ```py
    insert(
      data: typing.Union[dict, list, str, int, float, bool],
      key: str = None,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **data** (required) ‚Äì Accepts: `dict`, `str`, [`int`](#storing-numbers), [`float`](#storing-numbers), `bool` and `list`.
        - Description: The data to be stored.
    - **key** (optional) ‚Äì Accepts: `str` and `None`
        - Description:  the key (aka ID) to store the data under. Will be auto generated if not provided.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

    ##### Code Example
    ```py
    # will succeed, a key will be auto-generated
    db.insert("hello, world")

    # will succeed.
    db.insert({"message": "hello, world"}, "greeting1")

    # will raise an error as key "greeting1" already existed.
    db.insert({"message": "hello, there"}, "greeting1")

    # expiring items
    # expire in 300 seconds
    db.insert({"message": "will be deleted"}, "temp_greeting", expire_in=300)

    # expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.insert({"message": "will_be_deleted"}, "temp_greeting2", expire_at=expire_at)
    ```

    ##### Returns

    Returns the item on a successful insert, and throws an error if the key already exists.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Insert(item interface{}) (string, error)`**

        ##### Parameters
        - **item** : similar to `item` parameter to [`Put`](#put)

        ##### Code Example

        ```go

        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          u := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }

          // insert item in the database
          key, err := db.Insert(u)
          if err != nil {
            fmt.Println("failed to insert item:", err)
            return
          }
          fmt.Println("Successfully inserted item with key:", key)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Insert(item interface{}) (string, error)`**

        ##### Parameters
        - **item** : similar to `item` parameter to [`Put`](#put)


        ##### Code Example

        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // a user
            u := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }

            // insert item in the database
            key, err := db.Insert(u)
            if err != nil {
                fmt.Println("failed to insert item:", err)
                return
            }
            fmt.Println("Successfully inserted item with key:", key)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns
    Returns the `key` of the item inserted and an `error`. Possible error values:

    - `ErrConflict` : if item with provided `key` already exists
    - `ErrBadItem`: bad item, if item is of unexpected type
    - `ErrBadRequest`: item caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Put Many
The Put Many method puts up to 25 items into a Base at once on a single call.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async putMany(items, options)`**

    ##### Parameters

    - **items** (required) ‚Äì Accepts: `Array` of items, where each "item" can be an `object` (serializable), `string`, [`number`](#storing-numbers), `boolean` or `array`.
        - Description: The list of items to be stored.
    - **options** (optional) - Accepts: `object`, `null` or `undefined`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
      - Description: Optional parameters.
        - **expireIn** : item will expire in `expireIn` seconds after a successfull put operation, see also [expiring items](./expiring_items).
        - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    ##### Code Example
    ```js

    await db.putMany([
      {"name": "Beverly", "hometown": "Copernicus City", "key": "one"}, // key provided
      "dude", // key auto-generated
      ["NamaskƒÅra", "marhabaan", "hello", "yeoboseyo"] // key auto-generated
    ]);

    // putMany with expire in 300 seconds
    await db.putMany(
      [
        {"key": "temp-1", "name": "test-1"},
        {"key": "temp-2", "name": "test-2"},
      ],
      {expireIn: 300}
    );

    // putMany with expire at
    await db.putMany(
      [
        {"key": "temp-1", "name": "test-1"},
        {"key": "temp-2", "name": "test-2"},
      ],
      {expireAt: new Date('2023-01-01T00:00:00')}
    );

    ```

    ##### Returns

    Returns a promise which resolves to the put items on a successful insert, and throws an error if you attempt to put more than 25 items.

    ```json
    {
        "processed": {
            "items": [
                {
                    "hometown": "Copernicus City",
                    "key": "one",
                    "name": "Beverly"
                },
                {
                    "key": "jyesxxlrezo0",
                    "value": "dude"
                },
                {
                    "key": "5feqybn7lb05",
                    "value": [
                        "NamaskƒÅra",
                        "hello",
                        "marhabaan",
                        "yeoboseyo"
                    ]
                }
            ]
        }
    }
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    put_many(
      items: list,
      *,
      expire_in: int = None,
      expire_at: typing.Union[int, float, datetime.datetime] = None,
    )
    ```

    ##### Parameters

    - **items** (required) ‚Äì Accepts: `list` of items, where each "item" can be an `dict` (JSON serializable), `str`, [`int`](#storing-numbers), `bool`, [`float`](#storing-numbers) or `list`.
        - Description: The list of items to be stored.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)



    ##### Code Example
    ```py
    db.put_many([
      {"name": "Beverly", "hometown": "Copernicus City", "key": "one"}, // key provided
      "dude", // key auto-generated
      ["NamaskƒÅra", "marhabaan", "hello", "yeoboseyo"] // key auto-generated
    ])

    # put many to expire in 300 seconds
    db.put_many(
      [{"key": "tmp-1", "value": "test-1"}, {"key": "tmp-2", "value": "test-2"}],
      expire_in=300,
    )

    # put many with expire at
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put_many(
      [{"key": "tmp-1", "value": "test-1"}, {"key": "tmp-2", "value": "test-2"}],
      expire_at=expire_at,
    )
    ```

    ##### Returns

    Returns a dict with `processed` and `failed`(if any) items .

    ```json
    {
        "processed": {
            "items": [
                {
                    "hometown": "Copernicus City",
                    "key": "one",
                    "name": "Beverly"
                },
                {
                    "key": "jyesxxlrezo0",
                    "value": "dude"
                },
                {
                    "key": "5feqybn7lb05",
                    "value": [
                        "NamaskƒÅra",
                        "hello",
                        "marhabaan",
                        "yeoboseyo"
                    ]
                }
            ]
        }
    }
    ```
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`PutMany(items interface{}) ([]string, error)`**

        ##### Parameters:
        - **items**: a slice of items, each item in the slice similar to the `item` parameter in [`Put`](#put)

        ##### Code Example:
        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // users
          u1 := &User{
            Key:      "kasdlj1",
            Username: "jimmy",
            Active:   true,
            Age:      20,
            Likes:    []string{"ramen"},
          }
          u2 := &User{
            Key:      "askdjf",
            Username: "joel",
            Active:   true,
            Age:      23,
            Likes:    []string{"coffee"},
          }
          users := []*User{u1, u2}

          // put items in the database
          keys, err := db.PutMany(users)
          if err != nil {
            fmt.Println("failed to put items:", err)
            return
          }
          fmt.Println("Successfully put item with keys:", keys)
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`PutMany(items interface{}) ([]string, error)`**

        ##### Parameters:
        - **items**: a slice of items, each item in the slice similar to the `item` parameter in [`Put`](#put)


        ##### Code Example:
        ```go

        import (
            "fmt"
            "github.com/deta/deta-go"
        )

        type User struct{
            Key string `json:"key"` // json struct tag 'key' used to denote the key
            Username string `json:"username"`
            Active bool `json:"active"`
            Age int `json:"age"`
            Likes []string `json:"likes"`
        }

        func main(){
            // error ignored for brevity
            d, _ := deta.New("project key")
            db, _ := d.NewBase("users")

            // users
            u1 := &User{
                Key: "kasdlj1",
                Username: "jimmy",
                Active: true,
                Age: 20,
                Likes: []string{"ramen"},
            }
            u2 := &User{
              Key: "askdjf",
              Username: "joel",
              Active: true,
              Age: 23,
              Likes: []string{"coffee"},
            }
            users := []*User{u1, u2}

            // put items in the database
            keys, err := db.PutMany(users)
            if err != nil {
                fmt.Println("failed to put items:", err)
                return
            }
            fmt.Println("Successfully put item with keys:", keys)
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns
    Returns the list of keys of the items stored and an `error`. In case of an error, none of the items are stored. Possible error values:

    - `ErrTooManyItems`: if there are more than 25 items
    - `ErrBadItem`: bad item/items, one or more item of unexpected type
    - `ErrBadRequest`: one or more item caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Update
`update` updates an existing item from the database.

<br />
<LangTabs>

  <Fragment slot="js">
    **`async update(updates, key, options)`**

    ##### Parameters

    - **updates** (required) - Accepts: `object` (JSON serializable)
        - Description: a json object describing the updates on the item
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of the item to be updated.
    - **options** (optional) - Accepts: `object`
      ```json
      {
        expireIn: number,
        expireAt: Date
      }
      ```
        - Description: Optional parameters.
          - **expireIn** : item will expire in `expireIn` seconds after a successfull update operation, see also [expiring items](./expiring_items).
          - **expireAt** : item will expire at `expireAt` date, see also [expiring items](./expiring_items).

    [Note for storing numbers](#storing-numbers)

    ###### Update operations
    - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided in the `set` object if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

    - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `base.util.increment(value)` should be used to increment the value. The *default value is 1* if not provided and it can also be negative.

    - **Append**: `Append` appends to a list. The util `base.util.append(value)` should be used to append the value. The value can be a `primitive type` or an `array`.

    - **Prepend**: `Prepend` prepends to a list. The util `base.util.prepend(value)` should be used to prepend the value. The value can be a `primitive type` or an `array`.

    - **Trim**: `Trim` removes an attribute from the item, the util `base.util.trim()` should be used as the value of an attribute.

    ##### Code Example

    Consider we have the following item in a base `const users = deta.Base('users')`:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the following update operation :

    ```js
    const updates = {
      "profile.age": 33, // set profile.age to 33
      "profile.active": true, // set profile.active to true
      "profile.email": "jimmy@deta.sh", // create a new attribute 'profile.email'
      "profile.hometown": users.util.trim(), // remove 'profile.hometown'
      "on_mobile": users.util.trim(), // remove 'on_mobile'
      "purchases": users.util.increment(2), // increment 'purchases' by 2, default value is 1
      "likes": users.util.append("ramen") // append 'ramen' to 'likes', also accepts an array
    }

    const res = await db.update(updates, "user-a");
    ```

    Results in the following item in the base:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes": ["anime", "ramen"],
      "purchases": 3
    }
    ```

    ##### Returns

    If the item is updated, the promise resolves to `null`. Otherwise, an error is raised.
  </Fragment>

  <Fragment slot="py">
    ```py
    update(
      updates: dict,
      key: str,
      *,
      expire_in: int = None,
      expire_at: typing.Union [int, float, datetime.datetime] = None
    )
    ```

    ##### Parameters

    - **updates** (required) - Accepts: `dict` (JSON serializable)
        - Description: a dict describing the updates on the item
    - **key** (required) ‚Äì Accepts: `string`
        - Description: the key of the item to be updated.
    - **expire_in** (optional) - Accepts: `int` and `None`
        - Description: seconds after which the item will expire in, see also [expiring items](./expiring_items)
    - **expire_at** (optional) - Accepts: `int`, `float`, `datetime.datetime` and `None`
        - Description: time at which the item will expire in, can provide the timestamp directly(`int` or `float`) or a [datetime.datetime](https://docs.python.org/3/library/datetime.html) object, see also [expiring items](./expiring_items)

    [Note for storing numbers](#storing-numbers)

    ###### Update operations
    - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided in the `set` dict if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

    - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `base.util.increment(value)` should be used to increment the value. The *default value is 1* if not provided and it can also be negative.

    - **Append**: `Append` appends to a list. The util `base.util.append(value)` should be used to append the value. The value can be a `primitive type` or a `list`.

    - **Prepend**: `Prepend` prepends to a list. The util `base.util.prepend(value)` should be used to prepend the value. The value can be a `primitive type` or a `list`.

    - **Trim**: `Trim` removes an attribute from the item, the util `base.util.trim()` should be used as the value of an attribute.

    ##### Code Example

    Consider we have the following item in a base `users = deta.Base('users')`:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 32,
        "active": false,
        "hometown": "pittsburgh"
      },
      "on_mobile": true,
      "likes": ["anime"],
      "purchases": 1
    }
    ```

    Then the following update operation:

    ```py
    updates = {
      "profile.age": 33,  # set profile.age to 33
      "profile.active": True, # set profile.active to true
      "profile.email": "jimmy@deta.sh", # create a new attribute 'profile.email'
      "profile.hometown": users.util.trim(), # remove 'profile.hometown'
      "on_mobile": users.util.trim(), # remove 'on_mobile'
      "purchases": users.util.increment(2), # increment by 2, default value is 1
      "likes": users.util.append("ramen") # append 'ramen' to 'likes', also accepts a list
    }

    db.update(updates, "user-a")
    ```

    Results in the following item in the base:

    ```json
    {
      "key": "user-a",
      "username": "jimmy",
      "profile": {
        "age": 33,
        "active": true,
        "email": "jimmy@deta.sh"
      },
      "likes":["anime", "ramen"],
      "purchases": 3
    }
    ```

    ##### Returns

    If the item is updated, returns `None`. Otherwise, an exception is raised.
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Update(key string, updates Updates) error`**

        ##### Parameters

        - **key**: the key of the item to update
        - **updates** : updates applied to the item, is of type `base.Updates` which is a `map[string]interface{}`

        [Note for storing numbers](#storing-numbers)

        ###### Update operations
        - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

        - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `Base.Util.Increment(value interface{})` should be used to increment the value. The value can also be negative.

        - **Append**: `Append` appends to a list. The util `Base.Util.Append(value interface{})` should be used to append the value. The value can be a slice.

        - **Prepend**: `Prepend` prepends to a list. The util `Base.Util.Prepend(value interface{})` should be used to prepend the value. The value can be a slice.

        - **Trim**: `Trim` removes an attribute from the item, the util `Base.Util.Trim()` should be used as the value of an attribute.

        ##### Code Example

        Consider we have the following item in a base `users`:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 32,
            "active": false,
            "hometown": "pittsburgh"
          },
          "likes": ["anime"],
          "purchases": 1
        }
        ```

        Then the following update operation :

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type Profile struct {
          Active   bool   `json:"active"`
          Age      int    `json:"age"`
          Hometown string `json:"hometown"`
        }

        type User struct {
          Key       string   `json:"key"` // json struct tag 'key' used to denote the key
          Username  string   `json:"username"`
          Profile   *Profile `json:"profile"`
          Purchases int      `json:"purchases"`
          Likes     []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // define the updates
          updates := base.Updates{
            "profile.age": 33, // set profile.age to 33
            "profile.active": true, // set profile.active to true
            "profile.hometown": db.Util.Trim(), // remove 'profile.hometown'
            "purchases": db.Util.Increment(2), // increment 'purchases' by 2
            "likes": db.Util.Append("ramen"), // append 'ramen' to 'likes', also accepts a slice
          }
          // update
          err = db.Update("user-a", updates)
          if err != nil {
            fmt.Println("failed to update", err)
            return
          }
        }
        ```

        Results in the following item in the base:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 33,
            "active": true,
          },
          "likes": ["anime", "ramen"],
          "purchases": 3
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Update(key string, updates Updates) error`**

        ##### Parameters

        - **key**: the key of the item to update
        - **updates** : updates applied to the item, is of type `deta.Updates` which is a `map[string]interface{}`

        [Note for storing numbers](#storing-numbers)

        ###### Update operations
        - **Set** : `Set` is practiced through normal key-value pairs. The operation changes the values of the attributes provided if the attribute already exists. If not, it adds the attribute to the item with the corresponding value.

        - **Increment**: `Increment` increments the value of an attribute. The attribute's value *must be a number*. The util `Base.Util.Increment(value interface{})` should be used to increment the value. The value can also be negative.

        - **Append**: `Append` appends to a list. The util `Base.Util.Append(value interface{})` should be used to append the value. The value can be a slice.

        - **Prepend**: `Prepend` prepends to a list. The util `Base.Util.Prepend(value interface{})` should be used to prepend the value. The value can be a slice.

        - **Trim**: `Trim` removes an attribute from the item, the util `Base.Util.Trim()` should be used as the value of an attribute.

        ##### Code Example

        Consider we have the following item in a base `users`:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 32,
            "active": false,
            "hometown": "pittsburgh"
          },
          "on_mobile": true,
          "likes": ["anime"],
          "purchases": 1
        }
        ```

        Then the following update operation :

        ```go
        // define the updates
        updates := deta.Updates{
          "profile.age": 33, // set profile.age to 33
          "profile.active": true, // set profile.active to true
          "profile.email": "jimmy@deta.sh", // create a new attribute 'profile.email'
          "profile.hometown": users.Util.Trim(), // remove 'profile.hometown'
          "on_mobile": users.Util.Trim(), // remove 'on_mobile'
          "purchases": users.Util.Increment(2), // increment 'purchases' by 2
          "likes": users.Util.Append("ramen") // append 'ramen' to 'likes', also accepts a slice
        }

        // update
        err := users.Util.Update("user-a", updates);
        ```

        Results in the following item in the base:

        ```json
        {
          "key": "user-a",
          "username": "jimmy",
          "profile": {
            "age": 33,
            "active": true,
            "email": "jimmy@deta.sh"
          },
          "likes": ["anime", "ramen"],
          "purchases": 3
        }
        ```
      </Fragment>

    </LangVariantsTabs>

    ##### Returns

    Returns an `error`. Possible error values:

    - `ErrBadRequest`: the update operation caused a bad request response from the server
    - `ErrUnauthorized`: unauthorized
    - `ErrInternalServerError`: internal server error
  </Fragment>

</LangTabs>



### Fetch
Fetch retrieves a list of items matching a query. It will retrieve everything if no query is provided.

A query is composed of a single [query](/docs/en/reference/base/queries) object or a list of [queries](/docs/en/reference/base/queries).
In the case of a list, the indvidual queries are OR'ed.

<br />
<LangTabs>

  <Fragment slot="js">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`async fetch(query, options)`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb).
        - **options**: optional params:
          - `limit`: the limit of the number of items you want to retreive, min value `1` if used.
          - `last`: the last key seen in a previous paginated response, provide this in a subsequent call to fetch further items.

        > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
        >
        > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

        ##### Returns

        A promise which resolves to an object with the following attributes:

        - `count` : The number of items in the response.

        - `last`: The last key seen in the fetch response. If `last` is not `undefined` further items are to be retreived.

        - `items`: The list of items retreived.


        ##### Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```js
        const { items: myFirstSet } = await db.fetch({"age?lt": 30});
        const { items: mySecondSet } = await db.fetch([
          { "age?gt": 50 },
          { "hometown": "Greenville" }
        ])
        ```

        ... will come back with following data:

        ###### `myFirstSet`:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `mySecondSet`:

        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Fetch All Items

        ```js
        let res = await db.fetch();
        let allItems = res.items;

        // continue fetching until last is not seen
        while (res.last){
          res = await db.fetch({}, {last: res.last});
          allItems = allItems.concat(res.items);
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`async fetch(query, pages=10, buffer=null)`**

        ##### Parameters

        - **query**: is a single [query object](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1 MB).
        - **pages**: how many pages of items should be returned.
        - **buffer**: the number of items which will be returned for each iteration (aka "page") on the return iterable. This is useful when your query is returning more than 1mb of data, so you could buffer the results in smaller chunks.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```js
        const {value: myFirstSet} = await db.fetch({"age?lt": 30}).next();
        const {value: mySecondSet} = await db.fetch([
          { "age?gt": 50 },
          { "hometown": "Greenville" }
        ]).next();
        ```

        ... will come back with following data:

        ###### `myFirstSet`:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `mySecondSet`:

        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```
        ##### Returns

        A promise which resolves to a generator of objects that meet the `query` criteria.

        The total number of items will not exceed the defined using `buffer` and `pages. Max. number of items

        Iterating through the generator yields arrays containing objects, each array of max length `buffer`.


        ##### Example using buffer, pages

        ```js
        const foo = async (myQuery, bar) => {

          items = db.fetch(myQuery, 10, 20) // items is up to the limit length (10*20)

          for await (const subArray of items) // each subArray is up to the buffer length, 20
            bar(subArray)
        }
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

  <Fragment slot="py">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`fetch(query=None, limit=1000, last=None):`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb or max 1000 items).
        - **limit**: the limit of the number of items you want to retreive, min value `1` if used
        - **last**: the last key seen in a previous paginated response

        > Upto 1 MB of data is retrieved before filtering with the query. Thus, in some cases you might get an empty list of items but still the `last` key evaluated in the response.
        >
        > To apply the query through all the items in your base, you have to call fetch until `last` is empty.

        ##### Returns

        Returns an instance of a `FetchResponse` class which has the following properties.

        - `count` : The number of items in the response.

        - `last`: The last key seen in the fetch response. If `last` is not `None` further items are to be retreived

        - `items`: The list of items retreived.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```py
        first_fetch_res = db.fetch({"age?lt": 30})
        second_fetch_res = db.fetch([{"age?gt": 50}, {"hometown": "Greenville"}])
        ```

        ... will come back with following data:

        ###### `first_fetch_res.items`:
        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `second_fetch_res.items`:
        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```


        ##### Fetch All Items

        ```py
        res = db.fetch()
        all_items = res.items

        # fetch until last is 'None'
        while res.last:
          res = db.fetch(last=res.last)
          all_items += res.items
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`fetch(query=None, buffer=None, pages=10):`**

        ##### Parameters

        - **query**: is a single [query object (`dict`)](/docs/en/reference/base/queries) or list of queries. If omitted, you will get all the items in the database (up to 1mb).
        - **pages**: how many pages of items should be returned.
        - **buffer**: the number of items which will be returned for each iteration (aka "page") on the return iterable. This is useful when your query is returning more 1mb of data, so you could buffer the results in smaller chunks.

        ##### Code Example

        For the examples, let's assume we have a **Base** with the following data:

        ```json

        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          }
        ]

        ```

        ```py
        my_first_set = next(db.fetch({"age?lt": 30}))
        my_second_set = next(db.fetch([{"age?gt": 50}, {"hometown": "Greenville"}]))
        ```

        ... will come back with following data:

        ###### `my_first_set`:
        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          }
        ]
        ```

        ###### `my_second_set`:
        ```json
        [
          {
            "key": "key-2",
            "name": "Beverly",
            "age": 51,
            "hometown": "Copernicus City",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Returns

        A generator of objects that meet the `query` criteria.

        The total number of items will not exceed the defined using `buffer` and `pages. Max. number of items

        Iterating through the generator yields lists containing objects, each list of max length `buffer`.


        ##### Example using buffer, pages

        ```py
        def foo(my_query, bar):
          items = db.fetch(my_query, pages=10, buffer=20) # items is up to the limit length (10*20)

          for sub_list in items: # each sub_list is up to the buffer length, 10
            bar(sub_list)
        ```
      </Fragment>

    </LangVariantsTabs>
  </Fragment>

  <Fragment slot="go">
    <LangVariantsTabs>

      <Fragment slot="current">
        **`Fetch(i *FetchInput) error`**

        ##### Parameters

        - **i**: is a pointer to a `FetchInput`

          ```go
          // FetchInput input to Fetch operation
          type FetchInput struct {
            // filters to apply to items
            // A nil value applies no queries and fetches all items
            Q Query
            // the destination to store the results
            Dest interface{}
            // the maximum number of items to fetch
            // value of 0 or less applies no limit
            Limit int
            // the last key evaluated in a paginated response
            // leave empty if not a subsequent fetch request
            LastKey string
          }
          ```
          - `Q`: fetch query, is of type `deta.Query` which is a `[]map[string]interface{}`
          - `Dest`: the results will be stored into the value pointed by `Dest`
          - `Limit`: the maximum number of items to fetch, value of `0` or less applies no limit
          - `LastKey`: the last key evaluated in a paginated response, leave empty if not a subsequent fetch request

        ##### Code Example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key string `json:"key"`
          Name string `json:"name"`
          Age int `json:"age"`
          Hometown string `json:"hometown"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // query to get users with age less than 30
          query := base.Query{
            {"age?lt": 50},
          }

          // variabe to store the results
          var results []*User

          // fetch items
          _, err = db.Fetch(&base.FetchInput{
            Q:    query,
            Dest: &results,
          })
          if err != nil {
            fmt.Println("failed to fetch items:", err)
          }
        }
        ```

        ... `results` will have the following data:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Paginated example

        ```go
        import (
          "fmt"

          "github.com/deta/deta-go/deta"
          "github.com/deta/deta-go/service/base"
        )

        type User struct {
          Key      string   `json:"key"` // json struct tag 'key' used to denote the key
          Username string   `json:"username"`
          Active   bool     `json:"active"`
          Age      int      `json:"age"`
          Likes    []string `json:"likes"`
        }

        func main() {
          d, err := deta.New(deta.WithProjectKey("project_key"))
          if err != nil {
            fmt.Println("failed to init new Deta instance:", err)
            return
          }

          db, err := base.New(d, "users")
          if err != nil {
            fmt.Println("failed to init new Base instance:", err)
          }

          // query to get users with age less than 30
          query := base.Query{
            {"age?lt": 50},
          }

          // variabe to store the results
          var results []*User

          // variable to store the page
          var page []*User

          // fetch input
          i := &base.FetchInput{
            Q:     query,
            Dest:  &page,
            Limit: 1, // limit provided so each page will only have one item
          }

          // fetch items
          lastKey, err := db.Fetch(i)
          if err != nil {
            fmt.Println("failed to fetch items:", err)
            return
          }

          // append page items to results
          results = append(results, page...)

          // get all pages
          for lastKey != "" {
            // provide the last key in the fetch input
            i.LastKey = lastKey

            // fetch
            lastKey, err = db.Fetch(i)
            if err != nil {
              fmt.Println("failed to fetch items:", err)
              return
            }

            // append page items to all results
            results = append(results, page...)
          }
        }
        ```
      </Fragment>

      <Fragment slot="legacy">
        **`Fetch(i *FetchInput) error`**

        ##### Parameters

        - **i**: is a pointer to a `FetchInput`

          ```go
          // FetchInput input to Fetch operation
          type FetchInput struct {
            // filters to apply to items
            // A nil value applies no queries and fetches all items
            Q Query
            // the destination to store the results
            Dest interface{}
            // the maximum number of items to fetch
            // value of 0 or less applies no limit
            Limit int
            // the last key evaluated in a paginated response
            // leave empty if not a subsequent fetch request
            LastKey string
          }
          ```
          - `Q`: fetch query, is of type `deta.Query` which is a `[]map[string]interface{}`
          - `Dest`: the results will be stored into the value pointed by `Dest`
          - `Limit`: the maximum number of items to fetch, value of `0` or less applies no limit
          - `LastKey`: the last key evaluated in a paginated response, leave empty if not a subsequent fetch request

        ##### Code Example

        ```go
        import (
            "github.com/deta/deta-go"
        )

        type User struct {
            Key string `json:"key"`
            Name string `json:"name"`
            Age int `json:"age"`
            Hometown string `json:"hometown"`
        }

        func main(){
            // errors ignored for brevity
            d, _ := deta.New("project key")
            db, _ := deta.NewBase("users")

            // query to get users with age less than 30
            query := deta.Query{
              {"age?lt": 50},
            }

            // variabe to store the results
            var results []*User

            // fetch items
            _, err := db.Fetch(&deta.FetchInput{
              Q: query,
              Dest: &results,
            })
            if err != nil {
                fmt.Println("failed to fetch items:", err)
            }
        }
        ```

        ... `results` will have the following data:

        ```json
        [
          {
            "key": "key-1",
            "name": "Wesley",
            "age": 27,
            "hometown": "San Francisco",
          },
          {
            "key": "key-3",
            "name": "Kevin Garnett",
            "age": 43,
            "hometown": "Greenville",
          },
        ]
        ```

        ##### Paginated example

        ```go
        import (
            "github.com/deta/deta-go"
        )

        type User struct {
            Key string `json:"key"`
            Name string `json:"name"`
            Age int `json:"age"`
            Hometown string `json:"hometown"`
        }

        func main(){
            // errors ignored for brevity
            d, _ := deta.New("project key")
            db, _ := deta.NewBase("users")

            // query to get users with age less than 30
            query := deta.Query{
              {"age?lt": 50},
            }

            // variabe to store the results
            var results []*User

            // variable to store the page
            var page []*User

            // fetch input
            i := &deta.FetchInput{
              Q: query,
              Dest: &page,
              Limit: 1, // limit provided so each page will only have one item
            }

            // fetch items
            lastKey, err := db.Fetch(i)
            if err != nil {
                fmt.Println("failed to fetch items:", err)
                return
            }

            // append page items to results
            results = append(allResults, page...)

            // get all pages
            for lastKey != ""{
              // provide the last key in the fetch input
              i.LastKey = lastKey

              // fetch
              lastKey, err := db.Fetch(i)
              if err != nil {
                  fmt.Println("failed to fetch items:", err)
                  return
              }

              // append page items to all results
              results = append(allResults, page...)
            }
        }
        ```
      </Fragment>

      ##### Returns

      Returns an `error`. Possible error values:

      - `ErrBadDestination`: bad destination, results could not be stored onto `dest`
      - `ErrBadRequest`: the fetch request caused a bad request response from the server
      - `ErrUnauthorized`: unauthorized
      - `ErrInternalServerError`: internal server error

    </LangVariantsTabs>
  </Fragment>

</LangTabs>



# queries.md
## Operators

Queries support the following operators:

### Equal

```json
{"age": 22, "name": "Beverly"}

// hierarchical
{"user.profile.age": 22, "user.profile.name": "Beverly"}
```

```json
{"fav_numbers": [2, 4, 8]}
```

```json
{"time": {"day": "Tuesday", "hour": "08:00"}}
```

### Not Equal

```json
{"user.profile.age?ne": 22}
```

### Less Than

```json
{"user.profile.age?lt": 22}
```

### Greater Than

```json
{"user.profile.age?gt": 22}
```

### Less Than or Equal

```json
{"user.profile.age?lte": 22}
```

### Greater Than or Equal

```json
{"user.profile.age?gte": 22}
```

### Prefix

```json
{"user.id?pfx": "afdk"}
```

### Range

```json
{"user.age?r": [22, 30]}
```

### Contains

```json
{
  // if user email contains the substring @deta.sh
  "user.email?contains": "@deta.sh"
}
```

```json
{
  // if berlin is in a list of places lived
  "user.places_lived_list?contains": "berlin"
}
```

### Not Contains

```json
{
  // if user email does not contain @deta.sh
  "user.email?not_contains": "@deta.sh" // 'user.email?!contains' also valid
}
```

```json
{
  // if berlin is not in a list of places lived
  "user.places_lived_list?not_contains": "berlin" // 'user.places_lived_list?!contains' also valid
}
```

> `?contains` and `?not_contains` only works for a list of strings if checking for membership in a list; it does not apply to list of other data types. You can store your lists always as a list of strings if you want to check for membership.

## Logical Operators

### AND

The entries in a single query object are `AND` ed together. For e.g. the query:

```json
{
    "active": true,
    "age?gte": 22
}
```

will retrieve items where `active` is `true` **and** `age` is greater than or equal to `22`.

The query above would translate to `SQL` as:

```sql
SELECT * FROM base WHERE active=1 AND age>=22;
```


### OR

Multiple query objects in a list are `OR` ed together. For eg. the queries:

```json
[{"age?lte": 30}, {"age?gte": 40}]
```

will retrieve items where `age` is less than equal to `30` **or** `age` is greater than equal to `40`.

The query above would translate to `SQL` as:

```sql
SELECT * FROM base WHERE age<=30 OR age>=40;
```


## Hierarchy

You can use the period character `.` to query for hierarchical fields within the data. For instance if you have the following item in the base:

```json
{
    "key": "user-key",
    "profile": {
        "age": 22,
        "active": true
    }
}
```

Then you can query for the `active` and `age` within `profile` directly:

```json
{
    "profile.age": 22,
    "profile.active": true
}
```

## Querying Keys

You need to consider the following when querying on keys:

- The keys must be strings hence the operation values **must** also be strings.
- The [contains](#contains) and [not-contains](#not-contains) operators **are not supported**.
- The [`AND`](#and) and [`OR`](#or) operations for different query values **are not supported**.
    For e.g. **the following queries are invalid**:
    ```json
    {
        // different AND key queries (invalid query)
        "key": "a",
        "key?pfx": "b"
    }
    ```

    ```json
    {
        // different OR key queries (invalid query)
        [{"key?pfx":"a"}, {"key?pfx": "b"}]
    }
    ```


# expiring_items.mdx
## Storing

Items specify the expiration timestamp value in a field name `__expires` in the item itself. The value is a [Unix time](https://en.wikipedia.org/wiki/Unix_time), a number.

For e.g.
```json
{
  "key": "item_key",
  "msg": "this will be deleted",
  "__expires": 1672531200
}
```

The item above will be deleted automatically on `2023-01-01 00:00:00 GMT` (the equivalent date of the timestamp above).

You can use the [Base SDK](./sdk.md) to [`put`](./sdk#put), [`put_many`](./sdk#put_many) or [`insert`](./sdk#insert) items with an expiration timestamp (or the [HTTP API](./HTTP.md) directly).

> ‚ö†Ô∏è Storing an item with an already expired timestamp will not fail but the item will be immediately deleted.

> ‚ÑπÔ∏è Base SDKs might offer higher level methods with easier APIs to specify the expiration timestamp. If they do so, they still store the timestamp in the item itself as mentioned above.

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    const Deta = require('deta');
    const db = Deta("project_key").Base('examples');

    const item = {'value': 'temp'};

    // expire in 300 seconds
    await db.put(item, 'temp_key', {expireIn:300})

    // expire at date
    await db.put(item, 'temp_key', {expireAt: new Date('2023-01-01T00:00:00')})
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    import datetime
    from deta import Deta

    db = Deta("project_key").Base("examples")

    item = {"key": "temp_key", "value": "temp"}

    # expire in 300 seconds
    db.put(item, expire_in=300)

    # expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.put(item, expire_at=expire_at)
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    import (
      "log"
      "time"

      "github.com/deta/deta-go/deta"
      "github.com/deta/deta-go/service/base"
    )

    type TmpData struct {
      Key string `json: "key"`
      Value string `json:"value"`
      // json struct tag `__expires` for expiration timestamp
      // 'omitempty' to prevent default 0 value
      Expires int64 `json:"__expires,omitempty"`
    }

    func main() {
      // errors ignored for brevity
      d, _ := deta.New(deta.WithProjectKey("project_key"))
      db, _ := base.New(d, "examples")

      tmp := &TmpData{
        Key: "temp_key",
        Value: "temp",
        Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
      }
      _, err := db.Put(tmp)
      if err != nil {
        log.Fatal("failed to put item:", err)
      }
    }
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl -X PUT "https://database.deta.sh/v1/test_project_id/examples/items" \
        -H "Content-Type: application/json" \
        -H "X-Api-Key: test_project_key" \
        -d {"items":[{"key": "temp_key", "value": "temp", "__expires": 1672531200}]}
    ```
  </Fragment>

</LangTabsExtended>

## Retrieving

When you retrieve items with an expiration timestamp, the timestamp value will be present in the `__expires` field. The value is a [Unix time](https://en.wikipedia.org/wiki/Unix_time).

`Get` and `Query` operations will not retrieve already expired items.

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    const { __expires } = await db.get("temp_key");
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    expires = db.get("temp_key").get("__expires")
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    dest := struct{
      Key     string `json:"key"`
      Expires int64  `json:"__expires,omitempty"`
    }{}

    if err := db.Get("temp_key", &dest); err != nil {
      log.Fatal("failed to get item:", err)
    }

    expires := dest.Expires
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl "https://database.deta.sh/v1/test_project_id/examples/items/temp_key" \
        -H "X-Api-Key: test_project_key"

    {"key": "temp_key", "value": "temp", "__expires": 1672531200}
    ```
  </Fragment>

</LangTabsExtended>




## Updating

You can update the expiration timestamp with a new timestamp by updating the value of the `__expires` as long as the item has not already expired.

Updating other fields of the item **does not** update (or renew) the expiration timestamp. You **must** update the value of `__expires` field.

You can use the [Base SDK](./sdk.md) to [`update`](./sdk#update) the expiration timestamp (or the [HTTP API](./HTTP.md) directly).

### Examples

<LangTabsExtended>
  <Fragment slot="js">
    ```js
    // update item to expire in 300 seconds from now
    await db.update(null, "temp_key", {expireIn: 300})

    // update item to expire at date
    await db.update(null, "temp_key", {expireAt: new Date('2023-01-01T00:00:00')})
    ```
  </Fragment>

  <Fragment slot="py">
    ```py
    # update item to expire in 300 seconds from now
    db.update(None, "temp_key", expire_in=300)

    # update item to expire at date
    expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
    db.update(None, "temp_key", expire_at=expire_at)
    ```
  </Fragment>

  <Fragment slot="go">
    ```go
    updates := base.Updates{
      "__expires": 1672531200,
    }
    if err := db.Update("temp_key", updates); err != nil {
      log.Fatal("failed to update item:", err)
    }
    ```
  </Fragment>

  <Fragment slot="http">
    ```shell
    curl -X PATCH "https://database.data.sh/v1/test_project_id/examples/items/temp_key" \
        -H "Content-Type: application/json" \
        -H "X-Api-Key: test_project_key" \
        -d {"set": {"__expires": 1672531200}}
    ```
  </Fragment>

</LangTabsExtended>




# py_tutorial.md
## Building a Simple CRUD with Deta Base


### Setup

Two dependencies are needed for this project, `deta` and `flask`:

```shell
pip install deta flask
```


To configure the app, import the dependencies and instantiate your database.

```py
from flask import Flask, request, jsonify
from deta import Deta


deta = Deta('myProjectKey') # configure your Deta project
db = deta.Base('simpleDB')  # access your DB
app = Flask(__name__)
```


### Creating Records

For our database we are going to store records of users under a unique `key`. Users can have three properties:

```py
{
    "name": str,
    "age": int,
    "hometown": str
}

```


We'll expose a function that creates user records to HTTP `POST` requests on the route `/users`.


```py
@app.route('/users', methods=["POST"])
def create_user():
    name = request.json.get("name")
    age = request.json.get("age")
    hometown = request.json.get("hometown")

    user = db.put({
        "name": name,
        "age": age,
        "hometown": hometown
    })

    return jsonify(user, 201)
```

##### Request

`POST` a payload to the endpoint:

```json
{
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

##### Response

Our server should respond with a status of `201` and a body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Reading Records

To read records, we can simply use `db.get(key)`.

If we tie a `GET` request to the `/users` path with a param giving a user id (i.e. `/users/dl9e6w6859a9`), we can return a record of the user over HTTP.


```py
@app.route("/users/<key>")
def get_user(key):
    user = db.get(key)
    return user if user else jsonify({"error": "Not found"}, 404)
```

##### Request

Let's try reading the record we just created.

Make a `GET` to the path (for example) `/users/dl9e6w6859a9`.

##### Response

The server should return the same record:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Updating Records

To update records under a given `key`, we can use `db.put()`, which will replace the record under a given key.

We can tie a `PUT` request to the path `/users/{id}` to update a given user record over HTTP.


```py
@app.route("/users/<key>", methods=["PUT"])
def update_user(key):
    user = db.put(request.json, key)
    return user
```

##### Request

We can update the record by passing a `PUT` to the path `/users/dl9e6w6859a9` with the following payload:

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with the new body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```


### Deleting Records

To delete records under a given `key`, we can use `Base.delete(key)`, which will remove the record under a given key.

We can tie a `DELETE` request to the path `/users/{id}` to delete a given user record over HTTP.

```js
@app.route("/users/<key>", methods=["DELETE"])
def delete_user(key):
    db.delete(key)
    return jsonify({"status": "ok"}, 200)
```

##### Request

We can delete the record by passing a `DELETE` to the path `/users/dl9e6w6859a9`.

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with:

```json
None
```


# about.md
## What can Deta Base be used for?

Deta Base is great for projects where configuring and maintaining a database is overkill or when you want to store data as part of [building a Space app](/docs/en/basics/data).

Examples:

- Serverless Applications
- Internal Tools
- Stateful Integrations
- Hackathons and Side Projects
- Prototyping

## Getting started

- [Dealing with data in a Space App](/docs/en/basics/data)
- [Base UI](/docs/en/reference/base/base_ui)
- [Base SDK](/docs/en/reference/base/sdk)
- [Base HTTP API](/docs/en/reference/base/HTTP)


# base_ui.md
### Opening Base UI

You can open the Base UI of an app instance by opening an app's context menu and clicking "View Data"

<img src="/docs_assets/instance/context_menu.png" alt="drive_ui_1" width="200"/>

In the now open dialog navigate to the "Base" tab and all the data from your Base should load into the table view.

You can edit individual cells directly, if they do not contain an array or an object. Modified cells will turn yellow.

<img src="/docs_assets/base_ui/base_ui_2.png" alt="base_ui_2" width="500"/>


### Advanced Editing

You can expand any cell if you want to do advanced editing (like the editing of objects and arrays or type changes).

<img src="/docs_assets/base_ui/base_ui_3.png" alt="base_ui_3" width="500"/>

### Queries

If you don't want to deal with all of your data at once, you can use Deta Base's queries to get a filtered view. Click the **Query** button, enter your query, and hit enter or click **Fetch**.

<img src="/docs_assets/base_ui/base_ui_4.png" alt="base_ui_4" width="600"/>


### Adding Items

You can add new items by clicking **+ Add**.

<img src="/docs_assets/base_ui/base_ui_6.png" alt="base_ui_6" width="600"/>

New rows and edited rows will appear in yellow.

You can permanently save these modifications by clicking **Save edits**.

### Deleting Items

To delete items, click on the checkbox(es) for any item(s) and then click the **Delete** button.

<img src="/docs_assets/base_ui/base_ui_7.png" alt="base_ui_7" width="600"/>

### Undoing Changes

You can revert your local changes, restoring the BaseUI state to the last fetch by clicking the **Undo** button.

<img src="/docs_assets/base_ui/base_ui_8.png" alt="base_ui_8" width="300"/>

### Final Notes

We hope you enjoy Base UI!

Base UI is still in Beta; it has been internally tested but may have some uncaught bugs or issues.


# node_tutorial.mdx
## Building a Simple CRUD with Deta Base

### Setup

Two dependencies are needed for this project, `deta` and `express`:
```shell
npm install deta express
```

To configure the app, import the dependencies and instantiate your database.

```js
const express = require('express');
const { Deta } = require('deta');

const deta = Deta('myProjectKey'); // configure your Deta project
const db = deta.Base('simpleDB');  // access your DB


const app = express(); // instantiate express

app.use(express.json()) // for parsing application/json bodies
```



### Creating Records

For our database we are going to store records of users under a unique `key`. Users can have three properties:
```js
{
    "name": "string",
    "age": number,
    "hometown": "string"
}

```

We'll expose a function that creates user records to HTTP `POST` requests on the route `/users`.
```js
app.post('/users', async (req, res) => {
    const { name, age, hometown } = req.body;
    const toCreate = { name, age, hometown};
    const insertedUser = await db.put(toCreate); // put() will autogenerate a key for us
    res.status(201).json(insertedUser);
});
```



##### Request

`POST` a payload to the endpoint:
```json
{
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```



##### Response

Our server should respond with a status of `201` and a body of:
```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Reading Records

To read records, we can simply use `Base.get(key)`.

If we tie a `GET` request to the `/users` path with a path param giving a user id (i.e. `/users/dl9e6w6859a9`), we can return a record of the user over HTTP.

```js
app.get('/users/:id', async (req, res) => {
    const { id } = req.params;
    const user = await db.get(id);
    if (user) {
        res.json(user);
    } else {
        res.status(404).json({"message": "user not found"});
    }
});
```

Another option would to use `Base.fetch(query)` to search for records to return, like so:

<LangVariantsTabs>

  <Fragment slot="current">
    ```js
    app.get('/search-by-age/:age, async (req, res) => {
        const { age } = req.params;
        const { items } = await db.fetch({'age': age});
        return items;
    });
    ```
  </Fragment>

  <Fragment slot="legacy">
    ```js
    app.get('/search-by-age/:age, async (req, res) => {
        const { age } = req.params;
        return (await db.fetch({'age': age}).next()).value;
    });
    ```
  </Fragment>

</LangVariantsTabs>

##### Request

Let's try reading the record we just created.

Make a `GET` to the path `/users/dl9e6w6859a9`.

##### Response

The server should return the same record:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Beverly",
    "age": 44,
    "hometown": "Copernicus City"
}
```

### Updating Records

To update records under a given `key`, we can use `Base.put()`, which will replace the record under a given key.

We can tie a `PUT` request to the path `/users/{id}` to update a given user record over HTTP.

```js
app.put('/users/:id', async (req, res) => {
    const { id } = req.params;
    const { name, age, hometown } = req.body;
    const toPut = { key: id, name, age, hometown };
    const newItem = await db.put(toPut);
    return res.json(newItem)
});
```

##### Request

We can update the record by passing a `PUT` to the path `/users/dl9e6w6859a9` with the following payload:

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with the new body of:

```json
{
    "key": "dl9e6w6859a9",
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```


### Deleting Records

To delete records under a given `key`, we can use `Base.delete(key)`, which will remove the record under a given key.

We can tie a `DELETE` request to the path `/users/{id}` to delete a given user record over HTTP.

```js
app.delete('/users/:id', async (req, res) => {
    const { id } = req.params;
    await db.delete(id);
    res.json({"message": "deleted"})
});
```

##### Request

We can delete the record by passing a `DELETE` to the path `/users/dl9e6w6859a9`.

```json
{
    "name": "Wesley",
    "age": 24,
    "hometown": "San Francisco"
}
```

##### Response

Our server should respond with:

```json
{
    "message": "deleted"
}
```


# HTTP.mdx
## General

> üí° You can get your **Project Key** and your **Project ID** of your project in [Builder](https://deta.space/builder). You need these to talk with the Deta Drive API.

### Root URL
This URL is the base for all your HTTP requests:

**`https://drive.deta.sh/v1/{project_id}/{drive_name}`**

> The `drive_name` is the name given to your drive. If you already have a **Drive**, then you can go ahead and provide it's name here. Additionally, you could provide any name here when doing any `PUT` or `POST` request and our backend will automatically create a new drive for you if it does not exist. There is no limit on how many "Drives" you can create.

### Auth
A **Project Key** _must_ be provided in the request **headers** as a value for the `X-Api-Key` key for authentication and authorization.

Example `X-Api-Key: a0kjsdfjda_thisIsYourSecretKey`

### File Names And Directories
Each file needs a unique `name` which identifies the file. Directorial hierarchies are represented logically by the `name` of the file itself with the use of backslash `/`.

For example, if you want to store a file `world.txt` under the directory `hello` , the `name` of the file should be `hello/world.txt`.

The file name **must not** end with a `/`. This also means that you can not create an empty directory.

A directory ceases to exist if there are no more files in it.
## Endpoints
### Put File
`POST /files?name={name}`

Stores a smaller file in a single request. Use this endpoint if the file size is small enough to be sent in a single request. The file is overwritten if the file with given `name` already exists.

> We do not accept payloads larger than 10 Mb on this endpoint. For larger uploads, use chunked uploads.

<RequestTabs>

<Fragment slot="request">

| Headers | Required | Description |
| --|--|-|
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories).

</Fragment>
<Fragment slot="response">

##### `201 Created`

```js
Content-Type: application/json

{
    "name": "file name",
    "project_id": "deta project id",
    "drive_name": "deta drive_name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: "application/json"
{
    "errors": [
        // error messages
    ]
}
```

`413 Payload Too Large`

```html
Content-Type: text/html
<h1> 413 - Request Entity Too Large </h1>
```

</Fragment>
</RequestTabs>

### Initialize Chunked Upload

Initializes a chunked file upload. If the file is larger than 10 MB, use this endpoint to initialize a chunked file upload.

`POST /uploads?name={name}`

<RequestTabs>

<Fragment slot="request">

|Params | Required | Description |
||-||
|`upload_id`| Yes | The `upload_id` received after [initiating a chunked upload](#initialize-chunked-upload) |
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories). |
|`part`| Yes | The chunk part number, start with `1` |



</Fragment>
<Fragment slot="response">

##### `200 Ok`

```js
Content-Type: application/json

{
    "name": "file name",
    "upload_id": "a unique upload id"
    "part": 1, // upload part number
    "project_id": "deta project id",
    "drive_name": "deta drive name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`413 Payload Too Large`

```html
Content-Type: text/html
<h1> 413 Request Entity Too Large </h1>
```
</Fragment>
</RequestTabs>

### End Chunked Upload

End a chunked upload.

`PATCH /uploads/{upload_id}?name={name}`

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
||-||
|`upload_id`| Yes | The `upload_id` received after [initiating a chunked upload](#initialize-chunked-upload) |
|`name`| Yes | The `name` of the file. More [here](#file-names-and-directories). |


</Fragment>
<Fragment slot="response">

##### `200 Ok`

```js
Content-Type: application/json

{
    "name": "file name",
    "upload_id": "a unique upload id"
    "project_id": "deta project id",
    "drive_name": "deta drive name"
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```
</Fragment>
</RequestTabs>

### Download File

Download a file from drive.

` GET /files/download?name={name}`

<RequestTabs>

<Fragment slot="request">

| Params | Required | Description |
||-||
|`limit`| No | The `limit` of number of file names to get, defaults to `1000`|
|`prefix`| No | The `prefix` that each file name must have. |
|`last` | No | The `last` file name seen in a paginated response. |


</Fragment>
<Fragment slot="response">

##### `200 Ok`

The response is paginated based on the `limit` provided in the request. By default, maximum `1000` file names are sent.

If the response is paginated, the response contains a `paging` object with `size` and `last` keys; `size` is the number of file
names in the response, and `last` is the last file name seen in the response. The value of `last` should be used in subsequent
requests to continue recieving further pages.

```js
Content-Type: application/json

{
    "paging": {
        "size": 1000, // the number of file names in the response
        "last": "last file name in response"
    },
    "names": ["file1", "file2", ...]
}
```

##### Client Errors

`400 Bad Request`

```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

`404 Not Found`
```js
Content-Type: application/json
{
    "errors": [
        // error messages
    ]
}
```

</Fragment>
</RequestTabs>

### Delete Files

Delete files from drive.

`DELETE /files`

<RequestTabs>

<Fragment slot="request">

```js
Content-Type: "application/json"
{
    "names": ["file_1", "file_2"]
}
```

| Params | Required | Description |
||---|
|`names`| Yes | The `names` of the files to delete, maximum `1000` file names|

</Fragment>
<Fragment slot="response">

##### `200 Ok`


```js
Content-Type: application/json

{
    "deleted": ["file_1", "file_2", ...] // deleted file names
    "failed": {
        "file_3": "reason why file could not be deleted",
        "file_4": "reason why file could not be deleted",
        //...
    }
}
```

> File names that did not exist will also be under `deleted`, `failed` will only contain names of files that existed but were not deleted for some reason

</Fragment>
</RequestTabs>


# sdk.mdx
## Installing

<br />
<LangTabs>
  <Fragment slot="js">
  Using NPM:

    ```shell
    npm install deta
    ```

    Using Yarn:
    ```shell
    yarn add deta
    ```

  </Fragment>
  <Fragment slot="py">
  ```shell
	pip install deta
	```
  </Fragment>
  <Fragment slot="go">
  ```shell
	go get github.com/deta/deta-go
	```
  </Fragment>
</LangTabs>

## Instantiating

To start working with your Drive, you need to import the `Deta` class and initialize it with a **Project Key**. Then instantiate a subclass called `Drive` with a database name of your choosing.

<br />

<LangTabs>
  <Fragment slot="js">
	```js
	const { Deta } = require('deta'); // import Deta

    // this also works
    import { Deta } from 'deta';

    // Initialize with a Project Key
    const deta = Deta('project key');

    // You can create as many as you want
    const photos = deta.Drive('photos');
    const docs = deta.Drive('docs');
    ```

    If you are using Deta Drive within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your `package.json` file to install the latest sdk version.

    A valid project key is pre-set in the Micro's environment. There is no need to pass a key in the initialization step.

    ```js
    const { Drive } = require('deta');
    const drive = Drive('simple_drive');
    ```

    If you are using the `deta` npm package of `0.0.6` or below, `Deta` is the single default export and should be imported as such.

    ```js
    const Deta = require('deta');
    ```

  </Fragment>
  <Fragment slot="py">
  	```py
	from deta import Deta  # Import Deta

    # Initialize with a Project Key
    deta = Deta("project key")

    # This how to connect to or create a database.
    drive = deta.Drive("simple_drive")

    # You can create as many as you want
    photos = deta.Drive("photos")
    docs = deta.Drive("docs")

    ```

    If you are using Deta Drive within a [Deta Micro](/docs/en/basics/micros#whats-a-micro), you must include `deta` in your `requirements.txt` file to install the latest sdk version.

    A valid project key is pre-set in the Micro's environment. There is no need to pass a key in the the initialization step.

    ```py
    from deta import Drive

    drive = Drive("simple_drive")
    ```

  </Fragment>
  <Fragment slot="go">
  	```go
	import (
		"fmt"

    	"github.com/deta/deta-go/deta"
    	"github.com/deta/deta-go/service/drive"
    )

    func main() {

    	// initialize with project key
    	// returns ErrBadProjectKey if project key is invalid
    	d, err := deta.New(deta.WithProjectKey("project_key"))
    	if err != nil {
    		fmt.Println("failed to init new Deta instance:", err)
    		return
    	}

    	// initialize with drive name
    	// returns ErrBadDriveName if base name is invalid
    	drive, err := drive.New(d, "drive_name")
    	if err != nil {
    		fmt.Println("failed to init new Drive instance:", err)
    		return
    	}
    }
    ```

  </Fragment>
</LangTabs>

> ‚ö†Ô∏è Your project key is confidential and meant to be used by you. Anyone who has your project key can access your database. Please, do not share it or commit it in your code.

## Using

Deta's **`Drive`** offers the following methods to interact with your Deta Drive:

[**`put`**](#put) - Stores a file to drive. It will overwrite the file if the file already exists.

[**`get`**](#get) - Retrieves a file from drive by the file name.

[**`delete`**](#delete) - Deletes a file from drive.

[**`list`**](#list) - Lists the file names in a drive.

### Put

`Put` uploads and stores a file in a drive with a given `name`. It will overwrite the file if the file name already exists.

<LangTabs>
  <Fragment slot="js">

**`async put(name, options)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file.
- **options** (required) - `{data : string | Uint8Array | Buffer, path: string, contentType: string}`

  - Description: An object with three optional parameters.
    - **data** - `string` or `Buffer`
      - Description: Either the data string or a buffer.
    - **path** - `string`
      - Description: The path of the file to be uploaded to drive.
    - **contentType** - `string`
      - Description: The content type of the file to be uploaded to drive. If the content type is not provided, `drive` tries to figure out the content type from the `name` provided. It defaults to `application/octet-stream` if the content type can not be figured out from the file name.

  `options` must have at least and at most one of two properties `data` or `path` defined.

##### Returns

Returns a promise which resolves to the name of the item on a successful `put`, otherwise, it throws an `Error` on error.

##### Example

```js
drive.put('hello.txt', {data: "Hello world"});
drive.put('hello.txt', {data: "Hello world", contentType: 'text/plain'});

drive.put('hello.txt', {data: Buffer.from('Hello World'), contentType: 'text/plain'});
drive.put('hello.txt', {path: './my/file/path/file.txt'});
drive.put('hello.txt', {path: './my/file/path/file.txt', contentType: 'text/plain'}});
```

  </Fragment>
  <Fragment slot="py">
  **`put(name, data, *, path, content_type)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file.
- **data** - `string | bytes | io.TextIOBase | io.BufferedIOBase | io.RawIOBase`
  - Description: The data content of the file.
- **path** - `string`
  - Description: The local path of the file to be uploaded to drive.
- **content_type** - `string`

  - Description: The content type of the file to be uploaded to drive. If the content type is not provided, `drive` tries to figure out the content type from the `name` provided. It defaults to `application/octet-stream` if the content type can not be figured out from the file name.

  At least and at most one of two args `data` or `path` must be provided. `path` and `content_type` must be provided with the key words.

##### Returns

Returns the name of the file on a successful `put`, otherwise, raises an `Exception` on error.

##### Example

```py
drive.put('hello.txt', 'Hello world')
drive.put(b'hello.txt', 'Hello world')
drive.put('hello.txt', content_type='text/plain')

import io
drive.put('hello.txt', io.StringIO('hello world'))
drive.put('hello.txt', io.BytesIO(b'hello world'))

f = open('./hello.txt', 'r')
drive.put('hello.txt', f)
f.close()

drive.put('hello.txt', path='./hello.txt')
```

  </Fragment>
  <Fragment slot="go">
  **`Put(i *PutInput) (string, error)`**

##### Parameters

- **i** (required) - pointer to a `PutInput`
  - ```go
    // PutInput input to Put operation
    type PutInput struct {
      // Name of the file
      Name string
      // io.Reader with contents of the file
      Body io.Reader
      // ContentType of the file to be uploaded to drive.
      ContentType string
    }
    ```
  - `Name` (required) - `string`
    - Description: Name of the file to be uploaded.
  - `Body` (required) - `io.Reader`
    - Description: File content to be uploaded.
  - `ContentType` - `string`
    - Description: If the content type is not provided, drive tries to figure out the content type from Name provided. It defaults to application/octet-stream if the content type can not be figured out from the file name.

##### Returns

Returns the `name` of the file on a successful put (otherwise empty name), and an `error`.

##### Example

```go
import (
	"bufio"
	"fmt"
	"os"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}
	// PUT
	// reading from a local file
	file, err := os.Open("./art.svg")
	defer file.Close()

	name, err := drawings.Put(&drive.PutInput{
		Name:        "art.svg",
		Body:        bufio.NewReader(file),
		ContentType: "image/svg+xml",
	})
	if err != nil {
		fmt.Println("failed to put file:", err)
		return
	}
	fmt.Println("Successfully put file with name:", name)
}
```

  </Fragment>
</LangTabs>

### Get

`Get` retrieves a file from a drive by its name.

<LangTabs>
  <Fragment slot="js">

**`async get(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a promise that resolves to a `blob` of data if found, else `null`.
Throws an `Error` on errors.

##### Example

```js
const buf = await drive.get("hello.txt");
```

</Fragment>

<Fragment slot="py">

**`get(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a instance of a `DriveStreamingBody` class which has the following methods/properties.

- `read(size=None)` : Reads all or up to the next `size` bytes. Calling `read` after all the content has been read will return empty bytes.

- `iter_chunks(chunk_size:int=1024)` : Returns an iterator that yields chunks of bytes of `chunk_size` at a time.

- `iter_lines(chunk_size:int=1024)` : Returns an iterator that yields lines from the stream. Bytes of `chunk_size` at a time is read from the raw stream and lines are yielded from there. The line delimiter is always `b'\n'`.

- `close()` : Closes the stream.

- `closed` : Returns `True` if the stream has been closed.

##### Example

```py
hello = drive.get('hello.txt')
content = hello.read()
hello.close()

# larger files
# iterate chunks of size 4096 and save to disk
large_file = drive.get('large_file.txt')
with open("large_file.txt", "wb+") as f:
  for chunk in large_file.iter_chunks(4096):
      f.write(chunk)
  large_file.close()
```

</Fragment>

<Fragment slot="go">

**`Get(name string) (io.ReadCloser, error)`**

##### Parameters

- **name** (required) - `string`
  - Description: The `name` of the file to get.

##### Returns

Returns a `io.ReadCloser` for the file.

##### Example

```go
import (
	"fmt"
	"io/ioutil"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	// GET
	name := "art.svg"
	f, err := drawings.Get(name)
	if err != nil {
		fmt.Println("failed to get file with name:", name)
		return
	}
	defer f.Close()

	c, err := ioutil.ReadAll(f)
	if err != nil {
		fmt.Println("failed read file content with err:", err)
		return
	}
	fmt.Println("file content:", string(c))
}
```

</Fragment>

</LangTabs>

### Delete

`Delete` deletes a file from drive.

<LangTabs>
<Fragment slot="js">

**`async delete(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns a promise that resolves to the `name` of the deleted file on successful deletions, otherwise raises an `Error`

> If the file did not exist, the file is still returned as deleted.

##### Example

```js
const deletedFile = await drive.delete("hello.txt");
```

</Fragment>

<Fragment slot="py">

**`delete(name)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns the `name` of the deleted file on successful deletions, otherwise raises an `Exception`

> If the file did not exist, the file is still returned as deleted.

##### Example

```py
deleted_file = drive.delete("hello.txt")
```

</Fragment>
<Fragment slot="go">

**`Delete(name string) (string, error)`**

##### Parameters

- **name** (required) - `string`
  - Description: The name of the file to delete

##### Returns

Returns the `name` of the deleted file on successful deletions, and an `error`.

> If the file did not exist, the name is still returned.

##### Example

```go
import (
	"fmt"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	// DELETE
	name, err := drawings.Delete("art.svg")
	if err != nil {
		fmt.Println("failed to delete file with name:", name)
		return
	}
	fmt.Println("Successfully deleted file with name:", name)
}
```

</Fragment>
</LangTabs>

### Delete Many

Deletes multiple files (up to 1000) from a drive.

<LangTabs>

<Fragment slot="js">

**`async deleteMany(names)`**

##### Parameters

- **names** (required) - `Array of string`
  - description: The names of the files to be deleted.

##### Returns

Returns a promise which resolves to an object with `deleted` and `failed` keys indicating deleted and failed file names.

```js
{
  deleted : ["file1.txt", "file2.txt", ...],
  failed: {
    "file_3.txt": "reason for failure",
  }
}
```

> If a file did not exist, the file is still returned as deleted.

##### Example

```js
const result = await drive.DeleteMany(["file1.txt", "file2.txt"]);
console.log("deleted:", result.deleted);
console.log("failed:", result.failed);
```

</Fragment>

<Fragment slot="py">

**`delete_many(names)`**

##### Parameters

- **names** (required): `string`
  - Description: The names of the files to be deleted.

##### Returns

Returns a `dict` with `deleted` and `failed` keys indicating deleted and failed file names.

```py
{
  "deleted" : ["file1.txt", "file2.txt", ...],
  "failed": {
    "file_3.txt": "reason for failure"
  }
}
```

> If a file did not exist, the file is still returned as deleted.

##### Example

```py
result = drive.delete_many(["file1.txt", "file2.txt"]);
print("deleted:", result.get("deleted"))
print("failed:", result.get("failed"))
```

</Fragment>
	<Fragment slot="go">

	**`DeleteMany(names []string) (*DeleteManyOutput, error)`**

	##### Parameters

	- **names** (required): `[]string`
	- Description: The names of the files to be deleted.

	##### Returns

	Returns a pointer to a `DeleteManyOutput` and an `error`.

	```go
	// DeleteManyOutput output to DeleteMany operation
	type DeleteManyOutput struct {
		Deleted []string          `json:"deleted"`
		Failed  map[string]string `json:"failed"`
	}
	```

	- `Deleted` - string slice indicating deleted file names.
	- `Failled` - map indicating the names of failed file names along with an error message.

	##### Example

	```go
	import (
		"fmt"

		"github.com/deta/deta-go/deta"
		"github.com/deta/deta-go/service/drive"
	)

	func main() {
		// initialize with project key
		// returns ErrBadProjectKey if project key is invalid
		d, err := deta.New(deta.WithProjectKey("project_key"))
		if err != nil {
			fmt.Println("failed to init new Deta instance:", err)
			return
		}

		// initialize with drive name
		// returns ErrBadDriveName if drive name is invalid
		drawings, err := drive.New(d, "drawings")
		if err != nil {
			fmt.Println("failed to init new Drive instance:", err)
			return
		}

		names := []string{"a", "b", "c"}
		dr, err := drawings.DeleteMany(names)

		if err != nil {
			fmt.Println("failed to delete files")
			return
		}
		fmt.Println("deleted:", dr.Deleted)
		fmt.Println("failed:", dr.Failed)
	}
	```

	</Fragment>
</LangTabs>

### List

`List` files in your drive.

<LangTabs>

<Fragment slot="js">

**`async list(options)`**

##### Parameters

- **options** (required) : `{prefix: string, limit: number, last: string}`
  - Description: An object with three optional parameters.
    - **prefix**: `string`
      - Description: The prefix that file names must have.
    - **limit**: `number`
      - Description: The maximum number of files names to be returned, defaults to `1000`
    - **last**: `string`
      - Description: The `last` name seen in a previous paginated result. Provide `last` to fetch further pages.

##### Returns

Returns a promise which resolves to an `object` with `paging` and `names` keys.

```js
{
  names: ["file1.txt", "file2.txt", ...],
  paging: {
    size: 2,
    last: "file_2.txt"
  }
}
```

- `names`: The names of the files
- `paging`: Contains paging information.
  - `size` : The number of files returned.
  - `last` : The last name seen in the paginated response. Provide this value in subsequent api calls to fetch further pages. For the last page, `last` is not present in the response.

##### Example

```js
// get all files
let result = await drive.list();
let allFiles = result.names;
let last = result.paging.last;

while (last) {
  // provide last from previous call
  result = await drive.list({ last: result.paging.last });

  allFiles = allFiles.concat(result.names);

  // update last
  last = result.paging.last;
}
console.log("all files:", allFiles);

const resultWithPrefix = await drive.list({ prefix: "blog/" });
const resultWithLimit = await drive.list({ limit: 100 });
const resultWIthLimitAndPrefix = await drive.list({
  limit: 100,
  prefix: "blog/",
});
```

</Fragment>

<Fragment slot="py">

**`list(limit, prefix, last)`**

##### Parameters

- **limit**: `int`
  - Description: The maximum number of files names to be returned, defaults to `1000`
- **prefix**: `string`
  - Description: The prefix that file names must have.
- **last**: `string`
  - Description: The `last` name seen in a previous paginated result. Provide `last` from previous response to fetch further pages.

##### Returns

Returns a `dict` with `paging` and `names` keys.

```py
{
  "names": ["file1.txt", "file2.txt", ...],
  "paging": {
    "size": 2,
    "last": "file_2.txt"
  }
}
```

- `names`: The names of the files
- `paging`: Contains paging information.
  - `size` : The number of files returned.
  - `last` : The last name seen in the paginated response. Provide this value in subsequent api calls to fetch further pages. For the last page, `last` is not present in the response.

##### Example

```py
# get all files
result = drive.list()

all_files = result.get("names")
paging = result.get("paging")
last = paging.get("last") if paging else None

while (last):
  # provide last from previous call
  result = drive.list(last=last)

  all_files += result.get("names")
  # update last
  paging = result.get("paging")
  last = paging.get("last") if paging else None

print("all files:", all_files)

res_with_prefix = drive.list(prefix="/blog")
res_with_limit = drive.list(limit=100)
res_with_prefix_limit = drive.list(prefix="/blog", limit=100)
```

</Fragment>

<Fragment slot="go">

**`List(limit int, prefix, last string) (*ListOutput, error)`**

##### Parameters

- **limit** (required) - `int`
  - Description: Maximum number of file names to be returned.
- **prefix** (required) - `string`
  - Description: The prefix that file names must have.
- **last** (required) - `string`
  - Description: The `last` name seen in a previous paginated result. Provide `last` from previous response to fetch further pages.

##### Returns

Returns a pointer to a `ListOutput`

```go
type ListOutput struct {
	Paging *paging  `json:"paging"`
	Names  []string `json:"names"`
}

type paging struct {
	Size int     `json:"size"`
	Last *string `json:"last"`
}
```

- `Paging` - indicates the size and last name of the current page. `nil` if there are no further pages.
- `Names` - names of the files.

##### Example

```go
import (
	"fmt"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/service/drive"
)

func main() {

	// initialize with project key
	// returns ErrBadProjectKey if project key is invalid
	d, err := deta.New(deta.WithProjectKey("project_key"))
	if err != nil {
		fmt.Println("failed to init new Deta instance:", err)
		return
	}

	// initialize with drive name
	// returns ErrBadDriveName if drive name is invalid
	drawings, err := drive.New(d, "drawings")
	if err != nil {
		fmt.Println("failed to init new Drive instance:", err)
		return
	}

	lr, err := drawings.List(1000, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// ["a", "b", "c/d"]
	fmt.Println("names:", lr.Names)

	lr, err = drawings.List(1, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// ["a"]
	fmt.Println("names:", lr.Names)


	lr, err = drawings.List(2, "", "")
	if err != nil {
		fmt.Println("failed to list names from drive with err:", err)
	}
	// "b"
	fmt.Println("last:", *lr.Paging.Last)
}
```

</Fragment>
</LangTabs>


# drive_ui.md
### Opening Drive UI

You can open the Drive UI of an app instance by opening an app's context menu and clicking "View Data".

<img src="/docs_assets/instance/context_menu.png" alt="drive_ui_1" width="200"/>

In the now open dialog navigate to the "Drive" tab and all the files and folders from within the path `/` should load into the table view.


### Preview and Navigation

Files that are previewable (and folders) are marked in blue.

<img src="/docs_assets/drive_ui/drive_ui_2.png" alt="drive_ui_2" width="600"/>


Clicking a folder will navigate to that folder, while clicking a file will open up a preview.

<img src="/docs_assets/drive_ui/drive_ui_3.png" alt="drive_ui_3" width="600"/>

<p />

Your current location is highlighted in black in the navigation bar at the top of Drive UI.

<img src="/docs_assets/drive_ui/drive_ui_4.png" alt="drive_ui_4" width="600"/>

You can click a parent folder, or the Drive name, to jump to that location.

### Uploading & Downloading Files

You can upload a file by dragging it into the list of files & folders. This will upload the file in the current directory.

<img src="/docs_assets/drive_ui/drive_ui_5.png" alt="drive_ui_5" width="600"/>

To download a file, click the download icon, which is on the right side of the the table.

### Deleting Files

To delete files, click on the checkbox(es) for any files(s) and then click the trash icon in the top right corner of the Drive UI panel.

<img src="/docs_assets/drive_ui/drive_ui_6.png" alt="drive_ui_6" width="600"/>

You will be asked to confirm you want to delete the file(s).


### Final Notes

We hope you enjoy Drive UI!

Drive UI is still in Beta; it has been internally tested but may have some uncaught bugs or issues.


# py_tutorial.md
## Building a Simple Image Server with Deta Drive

### Setup
To get started, create a directory `image-server` and change the current directory into it.
```shell
$ mkdir image-server && cd image-server
```
Before we begin, let's install all the necessary dependencies for this project. Create a `requirements.txt` with the following lines:
```json
fastapi
uvicorn
deta
python-multipart
```

> If you are using Deta Drive within a Deta Micro, you should ignore `uvicorn`, but you must include `deta` in your `requirements.txt` file to install the lastest sdk version, other than that it won't work.

We are using `FastAPI` to build our simple image server, and `python-multipart` allows us access the uploaded files.

Run the following command to install the dependencies.
```shell
$ pip install -r requirements.txt
```

To configure the app, import the dependencies and instantiate drive in `main.py`

```python
from fastapi import FastAPI, File, UploadFile
from fastapi.responses import HTMLResponse, StreamingResponse
from deta import Deta

app = FastAPI()
deta = Deta("Project_Key")  # configure your Deta project
drive = deta.Drive("images") # access to your drive
```

We have everything we need to üöÄ

### Uploading Images
First, we need to render a HTML snippet to display the file upload interface.

We'll expose a function that renders the HTML snippet on the base route `/`
```python
@app.get("/", response_class=HTMLResponse)
def render():
    return """
    <form action="/upload" enctype="multipart/form-data" method="post">
        <input name="file" type="file">
        <input type="submit">
    </form>
    """
```

We are simply rendering a form that sends a HTTP `POST` request to the route `/upload` with file data.

Let's complete file upload by creating a function to handle `/upload`

```python
@app.post("/upload")
def upload_img(file: UploadFile = File(...)):
    name = file.filename
    f = file.file
    res = drive.put(name, f)
    return res
```

Thanks to the amazing tools from FastAPI, we can simply wrap the input around `UploadFile` and `File` to access the image data. We can retrieve the name as well as bytes from `file` and store it in Drive.

### Downloading images
To download images, we can simply use `drive.get(name)`

If we tie a `GET` request to the `/download` path with a param giving a name (i.e `/download/space.png`), we can return the image over HTTP.
```python
@app.get("/download/{name}")
def download_img(name: str):
    res = drive.get(name)
    return StreamingResponse(res.iter_chunks(1024), media_type="image/png")
```

You can learn more about `StreamingResponse` [here](https://fastapi.tiangolo.com/advanced/custom-response/#streamingresponse).

### Running the server
To run the server locally, navigate to the terminal in the project directory (`image-server`) and run the following command:
```shell
$ uvicorn main:app
```

Your image server is now ready! You can interact with it at `/` and check it out!

<img src="/docs_assets/img/drive/drive-py-tut.png" alt="/"/>
<img src="/docs_assets/img/drive/drive-py-tut-1.png" alt="/download/tut.jpg"/>


```shell

curl -X 'POST' \
  'http://127.0.0.1:8000/upload' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'file=@space.png;type=image/png'

Response
"space.png"


curl -X 'GET' \
  'http://127.0.0.1:8000/download/space.png' \
  -H 'accept: application/json'

Response
The server should respond with the image.
```


# node_tutorial.md
## Building a Simple Image Server with Deta Drive

### Setup

To get started, create a directory `image-server` and change the current directory into it.
```shell
$ mkdir image-server && cd image-server
```
Before we begin, let's install all the necessary dependencies for this project.

```shell
$ npm install deta express express-fileupload
```
In this tutorial, we are using `express` to build our server, and `express-fileupload` allows us to access the uploaded file data.

To configure the app, import the dependencies and instantiate drive in `index.js`

```js
const { Deta } = require("deta");
const express = require("express");
const upload = require("express-fileupload");

const app = express();

app.use(upload());

const deta = Deta("Project_Key");
const drive = deta.Drive("images");
```


We have everything we need to üöÄ

### Uploading Images
First, we need to render a HTML snippet to display the file upload interface.

We'll expose a function that renders the HTML snippet on the base route `/`
```javascript
app.get('/', (req, res) => {
    res.send(`
    <form action="/upload" enctype="multipart/form-data" method="post">
      <input type="file" name="file">
      <input type="submit" value="Upload">
    </form>`);
});
```

We are simply rendering a HTML form that sends a HTTP `POST` request to the route `/upload` with file data.

Let's complete file upload by creating a function to handle `/upload`

```javascript
app.post("/upload", async (req, res) => {
    const name = req.files.file.name;
    const contents = req.files.file.data;
    const img = await drive.put(name, {data: contents});
    res.send(img);
});
```
We can access the image details from `req` and store it in Drive.

### Downloading Images
To download images, we can simply use `drive.get(name)`

If we tie a `GET` request to the `/download` path with a param giving a name (i.e `/download/space.png`), we can return the image over HTTP.

```javascript
app.get("/download/:name", async (req, res) => {
    const name = req.params.name;
    const img = await drive.get(name);
    const buffer = await img.arrayBuffer();
    res.send(Buffer.from(buffer));
});

app.listen(3000);
```

### Running the server
To run the server locally, navigate to the terminal in the project directory (`image-server`) and run the following command:
```shell
$ node index.js
```

<img src="/docs_assets/img/drive/drive-py-tut.png" alt="/"/>
<img src="/docs_assets/img/drive/drive-py-tut-1.png" alt="/download/tut.jpg"/>


```shell
curl -X 'POST' \
  'http://127.0.0.1:3000/upload' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'file=@space.png;type=image/png'

Response
"space.png"

curl -X 'GET' \
  'http://127.0.0.1:3000/download/space.png' \
  -H 'accept: application/json'

Response
The server should respond with the image.
```


# about.md
## What can Deta Drive be used for?

Deta Drive is great for projects where you need to store files or when you want to store files as part of [building a Space app](/docs/en/basics/data).

## Getting started

- [Dealing with data in a Space App](/docs/en/basics/data)
- [Drive UI](/docs/en/reference/drive/base_ui)
- [Drive SDK](/docs/en/reference/drive/sdk)
- [Drive HTTP API](/docs/en/reference/drive/HTTP)


# personal-cloud.md
## What is the personal cloud?

The ‚Äòpersonal cloud‚Äô is pretty simple conceptually. It is just a departure from the common model of web application development on 'public cloud'.

### The public cloud

In a public cloud application, end users of an app by-and-large share infrastructure resources: servers, databases, file stores, etc. These resources are controlled by (and operated by) the providers of the web application, and accessed by end users when they login to the app.

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/public_cloud.png" width="500px" />
<div style="max-width: 100%; white-space: pre-wrap; word-break: break-word; caret-color: rgb(55, 53, 47); font-size: 14px; line-height: 1.4; color: rgba(55, 53, 47, 0.65); padding-top: 6px; padding-bottom: 6px; padding-left: 2px;" data-content-editable-leaf="true" contenteditable="false">Public cloud application architecture</div>
</div>

In this model, if the provider of the app shuts down this infrastructure, the user loses access. Meanwhile, the user can't directly delete their trace data, as it is in the provider's hands.

### The personal cloud

The personal cloud is a return to the personal computer model of applications, but in the cloud. Instead of one giant shared pool of resources for all users, *each user gets their own complete and sandboxed cloud application instance, consisting of the resources needed to power their app.*

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/personal_cloud.png" width="500px" />
<div style="max-width: 100%; white-space: pre-wrap; word-break: break-word; caret-color: rgb(55, 53, 47); font-size: 14px; line-height: 1.4; color: rgba(55, 53, 47, 0.65); padding-top: 6px; padding-bottom: 6px; padding-left: 2px;" data-content-editable-leaf="true" contenteditable="false">Personal cloud application architecture</div>
</div>

In this case, the users control the infrastructure which runs the app.  We think this shift solves a number of hairy problems for developers and users.

## 0 Infrastructure, ‚àû Scale

Due to the personal cloud architecture, each user owns their own infra. What this means for you as a developer, *is that you have effectively 0 infrastructure burden, no matter how many users your app scales to.* No servers or DBs to manage, secure, or maintain. All you need to do is build your application logic.

## Distribution

We've discovered two routes in which we think the personal cloud model improves application distribution today:


1. When a developer has built an application, but wants nothing to do with building auth layer or managing any infrastructure. These applications are really cool demo apps, or even use something like local storage for data persistence, but they aren't reaching their full potential for end users. We think these apps find a happy channel to end users on a personal cloud.
2. Where users really need to their own copy of an app for whatever reason. As it stands now, self hosting applications fill this niche, but it‚Äôs a niche: it requires a lot of time consuming expertise on the part of end users. With the personal cloud, we think many of the benefits of self-hosting are made accessible, which loops back to benefit app developers‚Äô distribution possibilities.

## Turn-key payments (planned for Space)

Developers have told us two things about taking their app to the next level:

1. They'd like to add some type of paywall & earn money once they start bringing external users onboard
2. Payments work ‚Äî in and of itself ‚Äî is fuss-y, infra like work. App devs would rather not do it.

So we thought about it, and wondered:
- Why should multiple app developers all have to implement a similar payment system into their app?
- Why should application users have to give billing information to every app they want to buy?

We think we can solve these problems with Deta Space, removing the payments work, just like we do for the other infra work. As a developer, we'd like you to have 'turn key' payments. Ideally you turn on a pricing knob, select a pricing model, provide your payment information and Deta will send you money every month.

## Control & interoperability (planned for Space)

On the personal cloud, we think control of the app and data is the biggest draw for end-users. This helps ensure that apps keep working if an app's developer decides to call it quits, while also providing privacy advantages.

For *users who are also developers*, we think control is a huge win, for an additional reason. This is because developers are fundamentally hackers and tinkerers who turn ideas into software, and personal computing fundamentally empowers them to do this. With personal control over apps and data, developers can hack and tinker their apps and data into more apps and data. We think this will allow developers to discover new frontiers in their own computational lives, paving the way for everyone else.

Build your first app on the personal cloud with Deta Space [here](/docs/en/introduction/first-app).


# first-app.mdx
## Prerequisites

The first thing to do is to create a Deta account if you haven‚Äôt already. You can [signup](https://deta.space/signup) in seconds, it‚Äôs completely free!

In this tutorial, we will launch a Space app built with Svelte. Deta Space supports any frontend framework alongside backend APIs built with Node, Python, Go, Rust or other custom binaries. We will only use Svelte for illustration purposes, but you can use any framework of your choice for this guide.

We will start by creating our Svelte app using the official instructions found on [Svelte.dev](https://svelte.dev/):

```bash
npm create vite@latest my-space-app -- --template svelte
```

Afterwards, let's make sure to go into the directory of our new Svelte app:

```bash
cd my-space-app
```

Now we are ready to continue with the Space specific steps.

## Installing the CLI

In this tutorial, we will use the Space [CLI](/docs/en/reference/cli) to create a new project on Space and then release it as a Space app.


<OSTabs>
  <Fragment slot="mac">
    To install the Space CLI on MacOS, open a Terminal session and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="win">
    To install the Space CLI on Windows, open PowerShell and enter:

    ```bash
    iwr https://get.deta.dev/space-cli.ps1 -useb | iex
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

  <Fragment slot="linux">
    To install the Space CLI on Linux, open a Terminal and enter:

    ```bash
    curl -fsSL https://get.deta.dev/space-cli.sh | sh
    ```

    This will download the binary which contains the CLI code. It will try to export the `space` command to your path. If it does not succeed, follow the directions output by the install script to export `space` to your path.
  </Fragment>

</OSTabs>

Once you have successfully installed the Space CLI, you'll need to log in to Space.

The Space CLI authenticates itself with 'Access Tokens'. You can create an access token under Settings in your Space. Just type 'settings' in Teletype to open them.

After you have generated a new key you can add it to the CLI using `space login`. It will prompt you for the key and then store it safely.

From a terminal type:

```bash
space login
```

After you've entered the key the Space CLI is ready to be used!

## Creating a project

A "[project](/docs/en/basics/projects)" allows you to start building an app, experiment with different Space features, test if your app works in a Space environment and finally release it to the public so others can get their own copies in their own personal clouds.

Let's create a new project inside our local directory with the following command:

```bash
space new
```

The CLI will ask you to name your project, we will call ours "awesome-app". Then it will try to detect which framework or language you are using and show you what's found. In our case it should correctly identify our Svelte app with the following message, prompting you to confirm:

```bash
‚öôÔ∏è No Spacefile found, trying to auto-detect configuration ...
üëá Deta detected the following configuration:

Micros:
name: frontend
 L src: .
 L engine: svelte

? Do you want to bootstrap "awesome-app" with this configuration? (y/n)
```

After confirming it will create a new project in [Builder](/docs/en/basics/projects#projects-in-builder) (a Space App for building and releasing Space Apps) and generate a [Spacefile](/docs/en/reference/spacefile) in your local directory:

```yaml
v: 0
micros:
  - name: frontend
    src: .
    engine: svelte
```

For now, it's enough to say that your `Spacefile` contains the configuration of your app which is used by Space to understand what your app looks like and how to run it.

The CLI also created a hidden `.space` directory locally which contains information necessary to work with your project in Builder. This file should not be included in your version control and was automatically added to your `.gitignore`, if you have initialized a Git repository.

After you've created a project you can view and manage it in [Builder](/docs/en/basics/projects#projects-in-builder). Builder is available on your Space Canvas.

## Pushing to Space

Now that we have created our project, we can push our local changes to a live Space environment.

Let's use another CLI command to do this:

```yaml
space push
```

`space push` will package and upload all the necessary files to create a new "[revision](/docs/en/basics/revisions#whats-a-revision)". A revision is a complete package of your app at a single point in time. New Revisions are created with each push. You can view this new revision by opening your project inside Builder. It will be shown on the "Develop" tab.

## Creating a release

The last step is to create a "[release](/docs/en/basics/releases)" out of our revision. A release makes your app installable to others.

Let's use one final CLI command:

```bash
space release
```

That's it, you can now share the release link with *anyone* you want and they will be able to install their own copy of your app in their Space.

Welcome to the Detaverse! üöÄ

# why-deta.md
## Computers, ideas, and their authors

<div style="display: flex; width: 100%; justify-content: center;">
<img src="/docs_assets/developer.gif" width="400px" />
</div>

We believe computers are incredible: one single tool can activate a tremendous diversity of human ideas. For this to happen, software developers play a *magical* role. They encode these ideas into a format usable to the computer, which puts them to work at a wonderous efficiency. This combination, of computers & apps, helps us throughout much of our everyday lives, automating much of the boring and routine. But it also lets us explore & author our own ideas, and create our own worlds. This is all made possible because a software developer sat down and turned an idea into an app. With computing, many of the limits of the doable are defined by the limits placed on the people sitting down and turning dreams into software.

## The modern cloud: destroying dreams

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/broken.gif" width="400px" />
<a target=‚Äù_blank‚Äù rel="noopener noreferrer" style="max-width: 100%; white-space: pre-wrap; word-break: break-word font-size: 9px; line-height: 1.15; padding-top: 4px; padding-bottom: 6px; padding-left: 2px; color: rgba(55, 53, 47, 0.65); font-style: italic;" href="https://64.media.tumblr.com/437f41a5c3525e3f5252b03f1c55b38c/tumblr_myhf2vr7Hy1r34zhyo6_400.gifv">source
</a>
</div>

In theory, combining computers and the internet is a huge win for activating these ideas. With ‚Äòcloud computing‚Äô, software becomes accessible to any human or computer with an internet connection. An idea is not tied to a single device and it can serve others, regardless of where they are. This magnifies the limits of the doable: we can instantly interact with & use the ideas of others, collaborate on authorship of new ideas, share our own worlds, and explore the worlds of others.

In practice, there are two big problems with cloud computing on today‚Äôs large ‚Äòpublic clouds‚Äô, *particularly for the  special group we mentioned earlier: software developers.*

First, the public cloud asks way too much from developers who want to move from an idea to working app. To deliver web applications that others can use, developers have to fight a steep tooth and nail battle creating, operating, and paying for a complex web of cloud infrastructure. We think this is holding back millions of developers around the world from delivering billions of incredible dreams that do.

Second, software developers are not just authors, they are critical *users* of computers. Many of their most important ideas for the rest of us come from dreaming and tinkering for themselves. Personal computing empowers them to do this, but the public cloud & its apps do not. Instead, developers have little control of their own personal 'cloud stuff', which is crucial raw material to build on top of, explore, and extend.

Without these issues, we think developers can unlock these frontiers in their own computing lives, paving the way for everyone else.

## Deta's next act: *the personal cloud*

<div style="display: flex; flex-direction: column; width: 100%; align-items: center;">
<img src="/docs_assets/drive.gif" width="400px" />
<a target=‚Äù_blank‚Äù rel="noopener noreferrer" style="max-width: 100%; white-space: pre-wrap; word-break: break-word font-size: 9px; line-height: 1.15; padding-top: 4px; padding-bottom: 6px; padding-left: 2px; color: rgba(55, 53, 47, 0.65); font-style: italic;" data-content-editable-leaf="true" contenteditable="false" href="https://64.media.tumblr.com/4951e22fd1e5d2fb91fa04057ec1b149/tumblr_mji8cbwQ921r34zhyo8_500.gifv">source
</a>
</div>

In short, at Deta we believe:
1. individual software developers around the world are the key to getting cloud computing right
2. the ‚Äòpublic cloud‚Äô is crippling their creativity with unnecessary complexity, costs, and limits

We've run into these issues ourselves and got pretty frustrated. So we decided to build a cloud that's a lot more personal and friendly for the individual developer. We see it as two things, to start:

- a personal launchpad for devs to bring their ideas into the world with ***0-ops***
- a personal computer in the cloud for devs to host and use their own apps and data

[Read on](/docs/en/introduction/personal-cloud) to learn about how the personal cloud works and some of the benefits we see for developers.


# start.md
## ‚ú® Key features

Deta Space is standing behind you, fully.

- **Fully managed servers**: App developers have an ops burden of zero, as they scale their users to space.

- **Fully managed data**: App developers don't have to worry about user data/compliance.

- **Fully managed security**: App developers don't think about security and auth - each user gets their own sandboxed app with managed auth.

- **Fully managed payments**: App developers can earn money with their apps, activated easy-peasy (planned).

## üíª Build your first Space app

Follow our [guide](/docs/en/introduction/first-app) on how to build your first app for Space. We also have tutorials on how to launch your favorite frameworks on Space in the **Quickstarts** section.

## üìö Learn Space

Learn about the key concepts of Space:

- [Apps](/docs/en/introduction/app-anatomy)
- [Micros](/docs/en/basics/micros)
- [Data storage](/docs/en/basics/data)
- [Development](/docs/en/basics/revisions)
- [Publishing](/docs/en/basics/releases)

*‚Ä¶ find our full API documentation under the **Reference** section.*

## üí¨ Join our community

We have a growing community of like minded developers who are happy to help or provide feedback on your Space projects. Join us on [Discord](https://go.deta.dev/discord)!

You can also follow us on [Twitter](https://twitter.com/detahq) to stay up to date on all the shenanigans.


# app-anatomy.md
## Computing with Micros

The 'brains' of an app are made up of what are called [Micros](/docs/en/basics/micros#whats-a-micro). A Micro is essentially a lightweight runtime capable of running different frameworks and languages. Micros are exposed via an HTTP endpoint. Micros within the same app can talk to one another.

## Storing and retrieving data

In addition to the compute provided by Micros, each app instance also has its own database called [Base](/docs/en/basics/data#base) and file store called [Drive](/docs/en/basics/drive#base). This data is sandboxed at the level of a single copy of the app; the data is separate from both other apps belonging to the same user and other users' copies of the same app. Nonetheless, the data is shared between all Micros inside a single copy of an app.

As a Space app developer, you'll code your app slightly differently than you would on the '[public cloud](/docs/en/introduction/personal-cloud#the-public-cloud)'. The good news is you do not have to worry about data separation or user authentication & authorization. You will end up writing a lot less code; you can code your app as if there is only one user, where auth 'just works'.

## Resource limits

A single app can consist of up to five Micros and an unlimited number of Bases and Drives. All these resources do not have to be created. Micros can be defined in your [Spacefile](/docs/en/reference/spacefile), while Bases and Drives can be created by your app during runtime.

On the public cloud, as a developer, you would pay and take responsibility for the resources 3rd party users consume through an app you wrote. On the personal cloud, this is completely different: the resources live with the users, so you do not need to worry about either.

## Developing and releasing your app

During development, you have access to a [Builder instance](/docs/en/basics/revisions#testing-changes) of your app. This instance gets continuously updated with your latest changes as soon as you push them to Deta. You can use this instance in Deta Space before "releasing" it.

On the personal cloud, Space apps are not "deployed" once, but they are "[released](/docs/en/basics/releases)". People can install releases of a Space app in their own Space.


# accessing-client-ip-address.md


You might want to collect some information about the clients accessing your app, like their IP address, which can be useful for analytics or security purposes. However, you might have noticed that when you directly try to access the IP address in your app, you receive `127.0.0.1` or an undefined response due to technical limitations.

Fortunately, there is a workaround that you can use to access the client's IP address. This is by using the [`CF-Connecting-IP` header](https://developers.cloudflare.com/fundamentals/get-started/reference/http-request-headers/#cf-connecting-ip), which is available when using [Cloudflare](https://www.cloudflare.com/) as the DNS provider for your [custom domain](/docs/en/basics/micros#custom-domains) with Cloudflare Proxy enabled. Cloudflare is a content delivery network (CDN) that acts as an intermediary between your website and your visitors, improving the speed and security of your site.

Once you've added your domain to Cloudflare, follow these steps:

1. Open [Canvas](https://deta.space/), click on the three dots (...) at the bottom right of your app's icon and select **Configuration** (or **Settings** if your app has been released) to open your app's settings

2. Click **Add Custom Domain** (in the Domains tab for released apps) and enter your domain name (e.g. `app-name.example.com`)

3. Go to the DNS settings in your [Cloudflare Dashboard](https://dash.cloudflare.com/) and add the required records. Make sure that **Cloudflare Proxy** is enabled when adding the A record.

![Cloudflare Proxy](/docs_assets/guides/accessing-client-ip-address/cloudflare-proxy.png)

> Make sure to change your SSL/TLS encryption mode to **Full** in the [Cloudflare Dashboard](https://dash.cloudflare.com/) before doing this to avoid any unexpected issues

4. Verify that your domain has been added. Now, you can use the `CF-Connecting-IP` header to determine your client's IP address when your app is accessed via the custom domain.

Here's an example of how to access the header in ExpressJS:

```js
app.get("/endpoint", (req, res) => {
  const ipAddress = req.get("CF-Connecting-IP");
  res.send(`Your IP address is ${ipAddress}`);
})
```

It's important to be note that the `CF-Connecting-IP` header can be spoofed, so you should always use additional security measures in conjunction with it.

# sveltekit.md
## Configure your SvelteKit app
To run a SvelteKit app on Space, you'll need to use the SvelteKit node adapter: [`@sveltejs/adapter-node`](https://kit.svelte.dev/docs/adapter-node). If you already use the Node adapter, skip to the [next section](#run-it-on-space).


First, install the `@sveltejs/adapter-node` dependency:

```sh
npm install @sveltejs/adapter-node
```

Then, in your `svelte.config.js` file, replace the current adapter with the node adapter:

```js
import adapter from '@sveltejs/adapter-node';
// rest of the file
```


Your project is now configured to run on Space. Let's run it!

## Run it on Space
After making sure you've installed the [Space CLI](/docs/en/basics/cli), run the following command in your project's directory:

```sh
space new
```
Follow the prompts to give your app a name. Once that's done, let's push your app to Space:

```sh
space push
```

Great job! You've just deployed your first SvelteKit app on Space. You can now access your app at the URL provided by the CLI.

# go.md


Space supports Go Micros, but it requires a bit more configuration.

- `engine` needs to be set to `custom`
- `commands` needs to include commands that build a binary
- `include` should be set to the binary file that is built as a result of running `commands`
- `dev` should be the command to start the program in development mode
- `run` should be the command to run the binary

Here is an example:

```yaml
v: 0
micros:
  - name: go-app
    src: ./src/go-app
    engine: custom
    dev: go run main.go
    commands:
      - go get
      - go build main.go
    run: ./main
    include:
      - main
```

- The first command `go get` installs any external packages/modules.
- The second command `go build main.go` builds the program into an executable file.
- `include` specifies which file(s) to include in the final package of the micro. In this case only our build binary file.
- Finally, `run` specifies the command that should be run to start the program. In this case, it is running the executable that was generated from the previous step.


# next.md


> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

If you don't have an existing Next app already you can create a new one by following the offical [Next instructions](https://nextjs.org/docs#automatic-setup).

For Space to be able to run Next it needs to be configured to ouput a standalone app. This ensures that the app is built to be served by a NodeJS server, refer to the [Next Docs](https://nextjs.org/docs/advanced-features/output-file-tracing#automatically-copying-traced-files) for more information.

Please modify `next.config.js` to set the output to `standalone`:

```jsx
/** @type {import('next').NextConfig} */
const nextConfig = {
    output: "standalone",
}

module.exports = nextConfig
```

Once you've edited your `next.config.js` file, just modify your [Spacefile](/docs/en/reference/spacefile/) file before [pushing changes](/docs/en/basics/revisions/) to Space.

Spacefile Configuration:

```yaml
v: 0
micros:
  - name: next-app
    src: ./src/fullstack/next-app
    engine: next
```


# custom.md


Deta Space supports most runtimes and frameworks out of the box without much configuration. The only requirements you have to keep in mind are:

- All web servers need to run on the port specified in the environment variable `PORT`
- 250 MB is the max size of the package


# nuxt.md


> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

If you don't have an existing Nuxt app already you can create a new one by following the offical [Nuxt instructions](https://v3.nuxtjs.org/getting-started/installation#new-project). Only Nuxt 3 is supported out of the box.

By default Nuxt will automatically output a standalone server which Space can run without additional configuration.

Once you've got a Nuxt 3 app locally paired with a [Space Project](/docs/en/basics/projects/), just modify your [Space Spacefile](/docs/en/reference/spacefile/) file before [pushing changes](/docs/en/basics/revisions/) to Space.

Space Spacefile configuration for Nuxt 3:

```yaml
v: 0
micros:
  - name: nuxt
    src: ./src/fullstack/nuxt
    engine: nuxt
```

# node.md


To run a Node.js app on a Space Micro, **it is recommended to use Node.js v16** since it works with Space out of the box.

> ‚ö†Ô∏è Make sure that your Micro is configured to listen on the port number specified in the environment variable `PORT`.

Here's the Spacefile needed to get a basic Node.js app running on Space:

```yaml
v: 0
micros:
  - name: node-micro
    src: src/node
    engine: nodejs16
    dev: nodemon index.js
    run: "node index.js"
```

index.js

```js
const express = require('express')
const app = express()

const port = process.env.PORT

app.get('/', (req, res) => {
  res.send('Hello from Space!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
```

> ‚ÑπÔ∏è We use [`nodemon`](https://www.npmjs.com/package/nodemon) to watch for changes in our code and restart the server automatically. You can use any other tool you like.

If your Node Micro has a build step (e.g. because you are using TypeScript) use a config similar to the following:

```yaml
v: 0
micros:
  - name: node-micro
    src: src/node
    engine: nodejs16
    dev: "npm run dev"
    commands:
      - npm run build
    include:
      - build
    run: "node build/index.js"
```

- `commands` specifies which commands to run during build, in our case our NPM script `build`
- `include` specifies which directory to include in the final app package, everything else will be ignored. In our case we set it to the directory of our build output
- `dev` specifies the command to start your Micro in development mode. In our case running the `dev` script in our `package.json`
- `run` specifies the command to start your Micro. In our case running the `index.js` file in our `build` directory using `node`

> ‚ÑπÔ∏è Support for Node.js v18 is coming soon.


# static.md


> If this is your first Space app take a look at the [getting started guide](/docs/en/introduction/first-app).

Static micros work out of the box with most frontend frameworks like React, Vue, and Svelte. Just set the right `engine` value in your [Space Spacefile](/docs/en/reference/spacefile/) and you are good to go:

```yaml
v: 0
micros:
  - name: frontend
    src: src/frontend-app
    engine: svelte # or react/vue
```

The following frameworks are supported configuration-free using `engine`:

- `react`
- `svelte`
- `vue`

For other frameworks the configuration is minimal.

Set the engine to `static` and specify the directory to serve with `serve`. If your framework has a build step, include your build command with the `commands` field:

```yaml
v: 0
micros:
  - name: frontend
    src: src/frontend-app
    engine: static
    dev: npm run dev
    commands:
      - npm run build
    serve: dist
```


# rust.md
## Step 1: Create a Space project
Make sure you have the [Space CLI installed and set up](/docs/en/basics/cli). Then, in the root directory of your Rust project, run the following to create a Space project and an empty [`Spacefile`](/docs/en/reference/spacefile):

```sh
space new
```

## Step 2: Configure your Spacefile

Configuring your project for Rust requires two steps. First, replace the contents of the `Spacefile` with the following:

```yaml
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: main
    src: .
    engine: custom
    dev: cargo run
    commands:
      - cargo build --release
    run: ./nameofyourbinary
    include:
      - target/release/nameofyourbinary
```

Make sure to replace `nameofyourbinary` with the name of your binary. Feel free to adjust the `commands` and `run` to your needs.

> __Explanation of the Spacefile:__
> - We are using the `custom` engine, which allows us to run any command we want
> - We are building the Rust app using `cargo build --release`
> - We are running the binary that was created in the previous step
> - We are including the binary in the final image (using `include`)
> - We are setting `src: .` as the current directory is the root of the Rust project
> - We are specifying a command to run during development using `dev`

Second,  create a `.spaceignore` file in the root of your project and add the following:

```
.git
target
```

## Step 3: Run it on Space

Now you can run your Rust app on Space:

```sh
space push
```

This will build your Rust app and push it to Space. You can now access your app at the URL provided by the CLI.
The build process will take a few minutes, as it has to build the Rust app from scratch.

`space push` is the same command you would also use to update your app.

Done! ‚ú®


# python.md
## Step 1: Code configuration

For Space to run your Python app, you need to have a file called `main.py` that contains the the main instance of your app, which __must__ be called `app`. You can structure your app however you want, but the `main.py` file must be in the root of your project. Make sure you also have a `requirements.txt` file that contains the dependencies of your app.

### Starlette
Here is an example of a simple Starlette app:

```yaml
v: 0
micros:
  - name: python-app
    src: ./src/python
    engine: python3.9
```

`main.py`
```python
from starlette.responses import PlainTextResponse


async def app(scope, receive, send):
    assert scope['type'] == 'http'
    response = PlainTextResponse('Hello, Space!')
    await response(scope, receive, send)
```

### FastAPI
Here is an example of a simple FastAPI app:

`main.py`
```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def read_root():
    return {"Hello": "Space!"}
```

### Flask
Here is an example of a simple Flask app:

`main.py`
```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello_world():
    return "Hello, Space!"
```


## Step 2: Run it on Space
Make sure you have the Space CLI installed & authenticated, then run the following command:

```bash
space new
```
This will create a new Space project in the current directory. You can then run the following command to push your code to Space:
> __Important__: before `space push`, we recommend creating a [`.spaceignore`](/docs/en/basics/revisions#ignoring-files-and-directories) file to ignore files that you don't want to be deployed to Space. For example, you should ignore `.git` and `.venv` folders.


```bash
space push
```

Great job! You've just deployed your Python app on Space. You can now access your app at the URL provided by the CLI.

## Limitations
- Space only supports Python 3.8 and 3.9
- Space only supports ASGI and WSGI apps (HTTP servers). So raw scripts won't work.
- Only `/tmp` is writable
- SQLite, MySQL, and PostgreSQL are not supported (we recommend using [Deta Base](/docs/en/reference/base/sdk), which is built into every Space app by default)
- Total size of deployed app is limited to 250MB (including dependencies, source code, etc). So many large dependencies like `numpy` or `streamlit` might not work, as well as larger models.

## Setting up local development

We recommend using virtual environment for local development. If you have listed your app dependencies in a `requirements.txt` file, you can install them to your virtual environment with the following commands:

```bash
# Create a virtual environment in the current directory
python -m venv .venv
# Activate the virtual environment
source .venv/bin/activate
# Install dependencies
pip install -r requirements.txt

# If you are using FastAPI, you will also need to install uvicorn
pip install uvicorn[standard]
```

Then you will need to setup the dev command inside your Spacefile. Just reference the executable file from your virtual environment:

```yaml
  - name: python-app
    src: ./src/python
    engine: python3.9
    dev: .venv/bin/uvicorn main:app --reload
```

# guide.md
## The application

For this guide we will use a simple "Hello World" Next app.

TODO: show how to create a sample next app and how to run it locally

## Install the Deta CLI and login

Now we are ready to launch our app to Space which means we will need the Deta CLI. If you've already installed it, just carry on. If not, checkout our [installation guide](/docs/en/basics/cli).

## Create a Builder Project

We can create a new project inside our local directory with the `deta new` command:

```bash
deta new
```

The CLI will ask you for your project‚Äôs name and will try to detect which framework or language you are using based on your source code. It will show you the configuration it detected for your app and prompt you to confirm it. In our case it correctly indentified our Next app.

After confirming it will create a new project with Builder and generate a `space.yml` file in your local directory:

```yaml
v: 0
micros:
  - name: app
    src: ./src
    engine: next
```

This file contains the configuration of your app which is used by Space to understand what your app looks like and how to run it.

As you can see above it added a single [Micro](/docs/en/basics/micros#whats-a-micro) to our project.

## Configuring our Micro

You can find more information about the properties of `space.yml` file in the [Spacefile Reference](/docs/en/reference/spacefile).

TODO: show how to configure this micro

## Pushing to Space

Now that we have created our project we can push our local changes to Space.

We will once again use the CLI to do this:

```yaml
deta push
```

This will package and upload all the necessary files and create a new [revision](/docs/en/basics/revisions#whats-a-revision). A revision is a complete package of your app at a single point in time. New revisions are created with each push. You can view this new revision by opening your project inside Builder. It will be shown on the "Develop" tab.

## Creating a release

The last step is to create a [release](/docs/en/basics/releases) out of our revision. A release makes your app installable to others.

TODO: use the CLI instead of builder

To do this head to the ‚ÄúPublish‚Äù tab in Builder and click ‚ÄúCreate new release‚Äù.

There you can select a revision (choose the latest one in our case) and enter a version/tag. Since this is our first release we will call it `v1.0`. On the next page you can add a short description and listing text to this release. This will be shown on the [Discovery]() page before users will install your app. Once you are happy with everything hit ‚ÄúRelease‚Äù and watch your app take off!

You can share the release link with anyone you want and they will be able to install your app inside their Space.

Welcome to the Detaverse! üöÄ